Documentation as generated by 'pydoc3' (default Python documentation
viewer). You can view this at the command line by typing
'pydoc3 MODULE_NAME'.
# module `torchmore.__init__`

```
Help on module torchmore.__init__ in torchmore:

NAME
    torchmore.__init__

FILE
    /home/tmb/proj/torchmore/torchmore/__init__.py


```

# module `torchmore.combos`

```
Help on module torchmore.combos in torchmore:

NAME
    torchmore.combos

CLASSES
    torch.nn.modules.module.Module(builtins.object)
        UnetLayer
    
    class UnetLayer(torch.nn.modules.module.Module)
     |  UnetLayer(d, r=3, sub=None, post=None)
     |  
     |  Resolution pyramid layer using convolutions and upscaling.
     |  
     |  Method resolution order:
     |      UnetLayer
     |      torch.nn.modules.module.Module
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, d, r=3, sub=None, post=None)
     |      Initializes internal Module state, shared by both nn.Module and ScriptModule.
     |  
     |  forward(self, x)
     |      Defines the computation performed at every call.
     |      
     |      Should be overridden by all subclasses.
     |      
     |      .. note::
     |          Although the recipe for forward pass needs to be defined within
     |          this function, one should call the :class:`Module` instance afterwards
     |          instead of this since the former takes care of running the
     |          registered hooks while the latter silently ignores them.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from torch.nn.modules.module.Module:
     |  
     |  __call__(self, *input, **kwargs)
     |      Call self as a function.
     |  
     |  __delattr__(self, name)
     |      Implement delattr(self, name).
     |  
     |  __dir__(self)
     |      Default dir() implementation.
     |  
     |  __getattr__(self, name)
     |  
     |  __repr__(self)
     |      Return repr(self).
     |  
     |  __setattr__(self, name, value)
     |      Implement setattr(self, name, value).
     |  
     |  __setstate__(self, state)
     |  
     |  add_module(self, name, module)
     |      Adds a child module to the current module.
     |      
     |      The module can be accessed as an attribute using the given name.
     |      
     |      Args:
     |          name (string): name of the child module. The child module can be
     |              accessed from this module using the given name
     |          module (Module): child module to be added to the module.
     |  
     |  apply(self, fn)
     |      Applies ``fn`` recursively to every submodule (as returned by ``.children()``)
     |      as well as self. Typical use includes initializing the parameters of a model
     |      (see also :ref:`nn-init-doc`).
     |      
     |      Args:
     |          fn (:class:`Module` -> None): function to be applied to each submodule
     |      
     |      Returns:
     |          Module: self
     |      
     |      Example::
     |      
     |          >>> def init_weights(m):
     |          >>>     print(m)
     |          >>>     if type(m) == nn.Linear:
     |          >>>         m.weight.data.fill_(1.0)
     |          >>>         print(m.weight)
     |          >>> net = nn.Sequential(nn.Linear(2, 2), nn.Linear(2, 2))
     |          >>> net.apply(init_weights)
     |          Linear(in_features=2, out_features=2, bias=True)
     |          Parameter containing:
     |          tensor([[ 1.,  1.],
     |                  [ 1.,  1.]])
     |          Linear(in_features=2, out_features=2, bias=True)
     |          Parameter containing:
     |          tensor([[ 1.,  1.],
     |                  [ 1.,  1.]])
     |          Sequential(
     |            (0): Linear(in_features=2, out_features=2, bias=True)
     |            (1): Linear(in_features=2, out_features=2, bias=True)
     |          )
     |          Sequential(
     |            (0): Linear(in_features=2, out_features=2, bias=True)
     |            (1): Linear(in_features=2, out_features=2, bias=True)
     |          )
     |  
     |  buffers(self, recurse=True)
     |      Returns an iterator over module buffers.
     |      
     |      Args:
     |          recurse (bool): if True, then yields buffers of this module
     |              and all submodules. Otherwise, yields only buffers that
     |              are direct members of this module.
     |      
     |      Yields:
     |          torch.Tensor: module buffer
     |      
     |      Example::
     |      
     |          >>> for buf in model.buffers():
     |          >>>     print(type(buf.data), buf.size())
     |          <class 'torch.FloatTensor'> (20L,)
     |          <class 'torch.FloatTensor'> (20L, 1L, 5L, 5L)
     |  
     |  children(self)
     |      Returns an iterator over immediate children modules.
     |      
     |      Yields:
     |          Module: a child module
     |  
     |  cpu(self)
     |      Moves all model parameters and buffers to the CPU.
     |      
     |      Returns:
     |          Module: self
     |  
     |  cuda(self, device=None)
     |      Moves all model parameters and buffers to the GPU.
     |      
     |      This also makes associated parameters and buffers different objects. So
     |      it should be called before constructing optimizer if the module will
     |      live on GPU while being optimized.
     |      
     |      Arguments:
     |          device (int, optional): if specified, all parameters will be
     |              copied to that device
     |      
     |      Returns:
     |          Module: self
     |  
     |  double(self)
     |      Casts all floating point parameters and buffers to ``double`` datatype.
     |      
     |      Returns:
     |          Module: self
     |  
     |  eval(self)
     |      Sets the module in evaluation mode.
     |      
     |      This has any effect only on certain modules. See documentations of
     |      particular modules for details of their behaviors in training/evaluation
     |      mode, if they are affected, e.g. :class:`Dropout`, :class:`BatchNorm`,
     |      etc.
     |      
     |      This is equivalent with :meth:`self.train(False) <torch.nn.Module.train>`.
     |      
     |      Returns:
     |          Module: self
     |  
     |  extra_repr(self)
     |      Set the extra representation of the module
     |      
     |      To print customized extra information, you should reimplement
     |      this method in your own modules. Both single-line and multi-line
     |      strings are acceptable.
     |  
     |  float(self)
     |      Casts all floating point parameters and buffers to float datatype.
     |      
     |      Returns:
     |          Module: self
     |  
     |  half(self)
     |      Casts all floating point parameters and buffers to ``half`` datatype.
     |      
     |      Returns:
     |          Module: self
     |  
     |  load_state_dict(self, state_dict, strict=True)
     |      Copies parameters and buffers from :attr:`state_dict` into
     |      this module and its descendants. If :attr:`strict` is ``True``, then
     |      the keys of :attr:`state_dict` must exactly match the keys returned
     |      by this module's :meth:`~torch.nn.Module.state_dict` function.
     |      
     |      Arguments:
     |          state_dict (dict): a dict containing parameters and
     |              persistent buffers.
     |          strict (bool, optional): whether to strictly enforce that the keys
     |              in :attr:`state_dict` match the keys returned by this module's
     |              :meth:`~torch.nn.Module.state_dict` function. Default: ``True``
     |      
     |      Returns:
     |          ``NamedTuple`` with ``missing_keys`` and ``unexpected_keys`` fields:
     |              * **missing_keys** is a list of str containing the missing keys
     |              * **unexpected_keys** is a list of str containing the unexpected keys
     |  
     |  modules(self)
     |      Returns an iterator over all modules in the network.
     |      
     |      Yields:
     |          Module: a module in the network
     |      
     |      Note:
     |          Duplicate modules are returned only once. In the following
     |          example, ``l`` will be returned only once.
     |      
     |      Example::
     |      
     |          >>> l = nn.Linear(2, 2)
     |          >>> net = nn.Sequential(l, l)
     |          >>> for idx, m in enumerate(net.modules()):
     |                  print(idx, '->', m)
     |      
     |          0 -> Sequential(
     |            (0): Linear(in_features=2, out_features=2, bias=True)
     |            (1): Linear(in_features=2, out_features=2, bias=True)
     |          )
     |          1 -> Linear(in_features=2, out_features=2, bias=True)
     |  
     |  named_buffers(self, prefix='', recurse=True)
     |      Returns an iterator over module buffers, yielding both the
     |      name of the buffer as well as the buffer itself.
     |      
     |      Args:
     |          prefix (str): prefix to prepend to all buffer names.
     |          recurse (bool): if True, then yields buffers of this module
     |              and all submodules. Otherwise, yields only buffers that
     |              are direct members of this module.
     |      
     |      Yields:
     |          (string, torch.Tensor): Tuple containing the name and buffer
     |      
     |      Example::
     |      
     |          >>> for name, buf in self.named_buffers():
     |          >>>    if name in ['running_var']:
     |          >>>        print(buf.size())
     |  
     |  named_children(self)
     |      Returns an iterator over immediate children modules, yielding both
     |      the name of the module as well as the module itself.
     |      
     |      Yields:
     |          (string, Module): Tuple containing a name and child module
     |      
     |      Example::
     |      
     |          >>> for name, module in model.named_children():
     |          >>>     if name in ['conv4', 'conv5']:
     |          >>>         print(module)
     |  
     |  named_modules(self, memo=None, prefix='')
     |      Returns an iterator over all modules in the network, yielding
     |      both the name of the module as well as the module itself.
     |      
     |      Yields:
     |          (string, Module): Tuple of name and module
     |      
     |      Note:
     |          Duplicate modules are returned only once. In the following
     |          example, ``l`` will be returned only once.
     |      
     |      Example::
     |      
     |          >>> l = nn.Linear(2, 2)
     |          >>> net = nn.Sequential(l, l)
     |          >>> for idx, m in enumerate(net.named_modules()):
     |                  print(idx, '->', m)
     |      
     |          0 -> ('', Sequential(
     |            (0): Linear(in_features=2, out_features=2, bias=True)
     |            (1): Linear(in_features=2, out_features=2, bias=True)
     |          ))
     |          1 -> ('0', Linear(in_features=2, out_features=2, bias=True))
     |  
     |  named_parameters(self, prefix='', recurse=True)
     |      Returns an iterator over module parameters, yielding both the
     |      name of the parameter as well as the parameter itself.
     |      
     |      Args:
     |          prefix (str): prefix to prepend to all parameter names.
     |          recurse (bool): if True, then yields parameters of this module
     |              and all submodules. Otherwise, yields only parameters that
     |              are direct members of this module.
     |      
     |      Yields:
     |          (string, Parameter): Tuple containing the name and parameter
     |      
     |      Example::
     |      
     |          >>> for name, param in self.named_parameters():
     |          >>>    if name in ['bias']:
     |          >>>        print(param.size())
     |  
     |  parameters(self, recurse=True)
     |      Returns an iterator over module parameters.
     |      
     |      This is typically passed to an optimizer.
     |      
     |      Args:
     |          recurse (bool): if True, then yields parameters of this module
     |              and all submodules. Otherwise, yields only parameters that
     |              are direct members of this module.
     |      
     |      Yields:
     |          Parameter: module parameter
     |      
     |      Example::
     |      
     |          >>> for param in model.parameters():
     |          >>>     print(type(param.data), param.size())
     |          <class 'torch.FloatTensor'> (20L,)
     |          <class 'torch.FloatTensor'> (20L, 1L, 5L, 5L)
     |  
     |  register_backward_hook(self, hook)
     |      Registers a backward hook on the module.
     |      
     |      The hook will be called every time the gradients with respect to module
     |      inputs are computed. The hook should have the following signature::
     |      
     |          hook(module, grad_input, grad_output) -> Tensor or None
     |      
     |      The :attr:`grad_input` and :attr:`grad_output` may be tuples if the
     |      module has multiple inputs or outputs. The hook should not modify its
     |      arguments, but it can optionally return a new gradient with respect to
     |      input that will be used in place of :attr:`grad_input` in subsequent
     |      computations.
     |      
     |      Returns:
     |          :class:`torch.utils.hooks.RemovableHandle`:
     |              a handle that can be used to remove the added hook by calling
     |              ``handle.remove()``
     |      
     |      .. warning ::
     |      
     |          The current implementation will not have the presented behavior
     |          for complex :class:`Module` that perform many operations.
     |          In some failure cases, :attr:`grad_input` and :attr:`grad_output` will only
     |          contain the gradients for a subset of the inputs and outputs.
     |          For such :class:`Module`, you should use :func:`torch.Tensor.register_hook`
     |          directly on a specific input or output to get the required gradients.
     |  
     |  register_buffer(self, name, tensor)
     |      Adds a persistent buffer to the module.
     |      
     |      This is typically used to register a buffer that should not to be
     |      considered a model parameter. For example, BatchNorm's ``running_mean``
     |      is not a parameter, but is part of the persistent state.
     |      
     |      Buffers can be accessed as attributes using given names.
     |      
     |      Args:
     |          name (string): name of the buffer. The buffer can be accessed
     |              from this module using the given name
     |          tensor (Tensor): buffer to be registered.
     |      
     |      Example::
     |      
     |          >>> self.register_buffer('running_mean', torch.zeros(num_features))
     |  
     |  register_forward_hook(self, hook)
     |      Registers a forward hook on the module.
     |      
     |      The hook will be called every time after :func:`forward` has computed an output.
     |      It should have the following signature::
     |      
     |          hook(module, input, output) -> None or modified output
     |      
     |      The hook can modify the output. It can modify the input inplace but
     |      it will not have effect on forward since this is called after
     |      :func:`forward` is called.
     |      
     |      Returns:
     |          :class:`torch.utils.hooks.RemovableHandle`:
     |              a handle that can be used to remove the added hook by calling
     |              ``handle.remove()``
     |  
     |  register_forward_pre_hook(self, hook)
     |      Registers a forward pre-hook on the module.
     |      
     |      The hook will be called every time before :func:`forward` is invoked.
     |      It should have the following signature::
     |      
     |          hook(module, input) -> None or modified input
     |      
     |      The hook can modify the input. User can either return a tuple or a
     |      single modified value in the hook. We will wrap the value into a tuple
     |      if a single value is returned(unless that value is already a tuple).
     |      
     |      Returns:
     |          :class:`torch.utils.hooks.RemovableHandle`:
     |              a handle that can be used to remove the added hook by calling
     |              ``handle.remove()``
     |  
     |  register_parameter(self, name, param)
     |      Adds a parameter to the module.
     |      
     |      The parameter can be accessed as an attribute using given name.
     |      
     |      Args:
     |          name (string): name of the parameter. The parameter can be accessed
     |              from this module using the given name
     |          param (Parameter): parameter to be added to the module.
     |  
     |  requires_grad_(self, requires_grad=True)
     |      Change if autograd should record operations on parameters in this
     |      module.
     |      
     |      This method sets the parameters' :attr:`requires_grad` attributes
     |      in-place.
     |      
     |      This method is helpful for freezing part of the module for finetuning
     |      or training parts of a model individually (e.g., GAN training).
     |      
     |      Args:
     |          requires_grad (bool): whether autograd should record operations on
     |                                parameters in this module. Default: ``True``.
     |      
     |      Returns:
     |          Module: self
     |  
     |  share_memory(self)
     |  
     |  state_dict(self, destination=None, prefix='', keep_vars=False)
     |      Returns a dictionary containing a whole state of the module.
     |      
     |      Both parameters and persistent buffers (e.g. running averages) are
     |      included. Keys are corresponding parameter and buffer names.
     |      
     |      Returns:
     |          dict:
     |              a dictionary containing a whole state of the module
     |      
     |      Example::
     |      
     |          >>> module.state_dict().keys()
     |          ['bias', 'weight']
     |  
     |  to(self, *args, **kwargs)
     |      Moves and/or casts the parameters and buffers.
     |      
     |      This can be called as
     |      
     |      .. function:: to(device=None, dtype=None, non_blocking=False)
     |      
     |      .. function:: to(dtype, non_blocking=False)
     |      
     |      .. function:: to(tensor, non_blocking=False)
     |      
     |      Its signature is similar to :meth:`torch.Tensor.to`, but only accepts
     |      floating point desired :attr:`dtype` s. In addition, this method will
     |      only cast the floating point parameters and buffers to :attr:`dtype`
     |      (if given). The integral parameters and buffers will be moved
     |      :attr:`device`, if that is given, but with dtypes unchanged. When
     |      :attr:`non_blocking` is set, it tries to convert/move asynchronously
     |      with respect to the host if possible, e.g., moving CPU Tensors with
     |      pinned memory to CUDA devices.
     |      
     |      See below for examples.
     |      
     |      .. note::
     |          This method modifies the module in-place.
     |      
     |      Args:
     |          device (:class:`torch.device`): the desired device of the parameters
     |              and buffers in this module
     |          dtype (:class:`torch.dtype`): the desired floating point type of
     |              the floating point parameters and buffers in this module
     |          tensor (torch.Tensor): Tensor whose dtype and device are the desired
     |              dtype and device for all parameters and buffers in this module
     |      
     |      Returns:
     |          Module: self
     |      
     |      Example::
     |      
     |          >>> linear = nn.Linear(2, 2)
     |          >>> linear.weight
     |          Parameter containing:
     |          tensor([[ 0.1913, -0.3420],
     |                  [-0.5113, -0.2325]])
     |          >>> linear.to(torch.double)
     |          Linear(in_features=2, out_features=2, bias=True)
     |          >>> linear.weight
     |          Parameter containing:
     |          tensor([[ 0.1913, -0.3420],
     |                  [-0.5113, -0.2325]], dtype=torch.float64)
     |          >>> gpu1 = torch.device("cuda:1")
     |          >>> linear.to(gpu1, dtype=torch.half, non_blocking=True)
     |          Linear(in_features=2, out_features=2, bias=True)
     |          >>> linear.weight
     |          Parameter containing:
     |          tensor([[ 0.1914, -0.3420],
     |                  [-0.5112, -0.2324]], dtype=torch.float16, device='cuda:1')
     |          >>> cpu = torch.device("cpu")
     |          >>> linear.to(cpu)
     |          Linear(in_features=2, out_features=2, bias=True)
     |          >>> linear.weight
     |          Parameter containing:
     |          tensor([[ 0.1914, -0.3420],
     |                  [-0.5112, -0.2324]], dtype=torch.float16)
     |  
     |  train(self, mode=True)
     |      Sets the module in training mode.
     |      
     |      This has any effect only on certain modules. See documentations of
     |      particular modules for details of their behaviors in training/evaluation
     |      mode, if they are affected, e.g. :class:`Dropout`, :class:`BatchNorm`,
     |      etc.
     |      
     |      Args:
     |          mode (bool): whether to set training mode (``True``) or evaluation
     |                       mode (``False``). Default: ``True``.
     |      
     |      Returns:
     |          Module: self
     |  
     |  type(self, dst_type)
     |      Casts all parameters and buffers to :attr:`dst_type`.
     |      
     |      Arguments:
     |          dst_type (type or string): the desired type
     |      
     |      Returns:
     |          Module: self
     |  
     |  zero_grad(self)
     |      Sets gradients of all model parameters to zero.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from torch.nn.modules.module.Module:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from torch.nn.modules.module.Module:
     |  
     |  dump_patches = False

FUNCTIONS
    ResnetBlock(d, r=3, identity=None, post=None)
    
    ResnetBottleneck(d, b, r=3, identity=None, post=None)
    
    conv2d_block(d, r=3, mp=None, fmp=None, repeat=1, batchnorm=True, nonlin=<class 'torch.nn.modules.activation.ReLU'>)
        Generate a conv layer with batchnorm and optional maxpool.
    
    fc_block(sizes, batchnorm=True, nonlin=<class 'torch.nn.modules.activation.ReLU'>, flatten=True)
    
    make_unet(sizes, r=3, repeat=3, sub=None)
    
    resnet_blocks(n, d, r=3)

FILE
    /home/tmb/proj/torchmore/torchmore/combos.py


```

# module `torchmore.flex`

```
Help on module torchmore.flex in torchmore:

NAME
    torchmore.flex

DESCRIPTION
    # Copyright (c) 2017-2019 TBD. All rights reserved.
    # This file is part of TBD (see TBD).
    # See the LICENSE file for licensing terms (TBD).
    #

CLASSES
    torch.nn.modules.module.Module(builtins.object)
        Flex
    
    class Flex(torch.nn.modules.module.Module)
     |  Flex(creator)
     |  
     |  Base class for all neural network modules.
     |  
     |  Your models should also subclass this class.
     |  
     |  Modules can also contain other Modules, allowing to nest them in
     |  a tree structure. You can assign the submodules as regular attributes::
     |  
     |      import torch.nn as nn
     |      import torch.nn.functional as F
     |  
     |      class Model(nn.Module):
     |          def __init__(self):
     |              super(Model, self).__init__()
     |              self.conv1 = nn.Conv2d(1, 20, 5)
     |              self.conv2 = nn.Conv2d(20, 20, 5)
     |  
     |          def forward(self, x):
     |              x = F.relu(self.conv1(x))
     |              return F.relu(self.conv2(x))
     |  
     |  Submodules assigned in this way will be registered, and will have their
     |  parameters converted too when you call :meth:`to`, etc.
     |  
     |  Method resolution order:
     |      Flex
     |      torch.nn.modules.module.Module
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, creator)
     |      Initializes internal Module state, shared by both nn.Module and ScriptModule.
     |  
     |  __repr__(self)
     |      Return repr(self).
     |  
     |  __str__(self)
     |      Return str(self).
     |  
     |  forward(self, *args)
     |      Defines the computation performed at every call.
     |      
     |      Should be overridden by all subclasses.
     |      
     |      .. note::
     |          Although the recipe for forward pass needs to be defined within
     |          this function, one should call the :class:`Module` instance afterwards
     |          instead of this since the former takes care of running the
     |          registered hooks while the latter silently ignores them.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from torch.nn.modules.module.Module:
     |  
     |  __call__(self, *input, **kwargs)
     |      Call self as a function.
     |  
     |  __delattr__(self, name)
     |      Implement delattr(self, name).
     |  
     |  __dir__(self)
     |      Default dir() implementation.
     |  
     |  __getattr__(self, name)
     |  
     |  __setattr__(self, name, value)
     |      Implement setattr(self, name, value).
     |  
     |  __setstate__(self, state)
     |  
     |  add_module(self, name, module)
     |      Adds a child module to the current module.
     |      
     |      The module can be accessed as an attribute using the given name.
     |      
     |      Args:
     |          name (string): name of the child module. The child module can be
     |              accessed from this module using the given name
     |          module (Module): child module to be added to the module.
     |  
     |  apply(self, fn)
     |      Applies ``fn`` recursively to every submodule (as returned by ``.children()``)
     |      as well as self. Typical use includes initializing the parameters of a model
     |      (see also :ref:`nn-init-doc`).
     |      
     |      Args:
     |          fn (:class:`Module` -> None): function to be applied to each submodule
     |      
     |      Returns:
     |          Module: self
     |      
     |      Example::
     |      
     |          >>> def init_weights(m):
     |          >>>     print(m)
     |          >>>     if type(m) == nn.Linear:
     |          >>>         m.weight.data.fill_(1.0)
     |          >>>         print(m.weight)
     |          >>> net = nn.Sequential(nn.Linear(2, 2), nn.Linear(2, 2))
     |          >>> net.apply(init_weights)
     |          Linear(in_features=2, out_features=2, bias=True)
     |          Parameter containing:
     |          tensor([[ 1.,  1.],
     |                  [ 1.,  1.]])
     |          Linear(in_features=2, out_features=2, bias=True)
     |          Parameter containing:
     |          tensor([[ 1.,  1.],
     |                  [ 1.,  1.]])
     |          Sequential(
     |            (0): Linear(in_features=2, out_features=2, bias=True)
     |            (1): Linear(in_features=2, out_features=2, bias=True)
     |          )
     |          Sequential(
     |            (0): Linear(in_features=2, out_features=2, bias=True)
     |            (1): Linear(in_features=2, out_features=2, bias=True)
     |          )
     |  
     |  buffers(self, recurse=True)
     |      Returns an iterator over module buffers.
     |      
     |      Args:
     |          recurse (bool): if True, then yields buffers of this module
     |              and all submodules. Otherwise, yields only buffers that
     |              are direct members of this module.
     |      
     |      Yields:
     |          torch.Tensor: module buffer
     |      
     |      Example::
     |      
     |          >>> for buf in model.buffers():
     |          >>>     print(type(buf.data), buf.size())
     |          <class 'torch.FloatTensor'> (20L,)
     |          <class 'torch.FloatTensor'> (20L, 1L, 5L, 5L)
     |  
     |  children(self)
     |      Returns an iterator over immediate children modules.
     |      
     |      Yields:
     |          Module: a child module
     |  
     |  cpu(self)
     |      Moves all model parameters and buffers to the CPU.
     |      
     |      Returns:
     |          Module: self
     |  
     |  cuda(self, device=None)
     |      Moves all model parameters and buffers to the GPU.
     |      
     |      This also makes associated parameters and buffers different objects. So
     |      it should be called before constructing optimizer if the module will
     |      live on GPU while being optimized.
     |      
     |      Arguments:
     |          device (int, optional): if specified, all parameters will be
     |              copied to that device
     |      
     |      Returns:
     |          Module: self
     |  
     |  double(self)
     |      Casts all floating point parameters and buffers to ``double`` datatype.
     |      
     |      Returns:
     |          Module: self
     |  
     |  eval(self)
     |      Sets the module in evaluation mode.
     |      
     |      This has any effect only on certain modules. See documentations of
     |      particular modules for details of their behaviors in training/evaluation
     |      mode, if they are affected, e.g. :class:`Dropout`, :class:`BatchNorm`,
     |      etc.
     |      
     |      This is equivalent with :meth:`self.train(False) <torch.nn.Module.train>`.
     |      
     |      Returns:
     |          Module: self
     |  
     |  extra_repr(self)
     |      Set the extra representation of the module
     |      
     |      To print customized extra information, you should reimplement
     |      this method in your own modules. Both single-line and multi-line
     |      strings are acceptable.
     |  
     |  float(self)
     |      Casts all floating point parameters and buffers to float datatype.
     |      
     |      Returns:
     |          Module: self
     |  
     |  half(self)
     |      Casts all floating point parameters and buffers to ``half`` datatype.
     |      
     |      Returns:
     |          Module: self
     |  
     |  load_state_dict(self, state_dict, strict=True)
     |      Copies parameters and buffers from :attr:`state_dict` into
     |      this module and its descendants. If :attr:`strict` is ``True``, then
     |      the keys of :attr:`state_dict` must exactly match the keys returned
     |      by this module's :meth:`~torch.nn.Module.state_dict` function.
     |      
     |      Arguments:
     |          state_dict (dict): a dict containing parameters and
     |              persistent buffers.
     |          strict (bool, optional): whether to strictly enforce that the keys
     |              in :attr:`state_dict` match the keys returned by this module's
     |              :meth:`~torch.nn.Module.state_dict` function. Default: ``True``
     |      
     |      Returns:
     |          ``NamedTuple`` with ``missing_keys`` and ``unexpected_keys`` fields:
     |              * **missing_keys** is a list of str containing the missing keys
     |              * **unexpected_keys** is a list of str containing the unexpected keys
     |  
     |  modules(self)
     |      Returns an iterator over all modules in the network.
     |      
     |      Yields:
     |          Module: a module in the network
     |      
     |      Note:
     |          Duplicate modules are returned only once. In the following
     |          example, ``l`` will be returned only once.
     |      
     |      Example::
     |      
     |          >>> l = nn.Linear(2, 2)
     |          >>> net = nn.Sequential(l, l)
     |          >>> for idx, m in enumerate(net.modules()):
     |                  print(idx, '->', m)
     |      
     |          0 -> Sequential(
     |            (0): Linear(in_features=2, out_features=2, bias=True)
     |            (1): Linear(in_features=2, out_features=2, bias=True)
     |          )
     |          1 -> Linear(in_features=2, out_features=2, bias=True)
     |  
     |  named_buffers(self, prefix='', recurse=True)
     |      Returns an iterator over module buffers, yielding both the
     |      name of the buffer as well as the buffer itself.
     |      
     |      Args:
     |          prefix (str): prefix to prepend to all buffer names.
     |          recurse (bool): if True, then yields buffers of this module
     |              and all submodules. Otherwise, yields only buffers that
     |              are direct members of this module.
     |      
     |      Yields:
     |          (string, torch.Tensor): Tuple containing the name and buffer
     |      
     |      Example::
     |      
     |          >>> for name, buf in self.named_buffers():
     |          >>>    if name in ['running_var']:
     |          >>>        print(buf.size())
     |  
     |  named_children(self)
     |      Returns an iterator over immediate children modules, yielding both
     |      the name of the module as well as the module itself.
     |      
     |      Yields:
     |          (string, Module): Tuple containing a name and child module
     |      
     |      Example::
     |      
     |          >>> for name, module in model.named_children():
     |          >>>     if name in ['conv4', 'conv5']:
     |          >>>         print(module)
     |  
     |  named_modules(self, memo=None, prefix='')
     |      Returns an iterator over all modules in the network, yielding
     |      both the name of the module as well as the module itself.
     |      
     |      Yields:
     |          (string, Module): Tuple of name and module
     |      
     |      Note:
     |          Duplicate modules are returned only once. In the following
     |          example, ``l`` will be returned only once.
     |      
     |      Example::
     |      
     |          >>> l = nn.Linear(2, 2)
     |          >>> net = nn.Sequential(l, l)
     |          >>> for idx, m in enumerate(net.named_modules()):
     |                  print(idx, '->', m)
     |      
     |          0 -> ('', Sequential(
     |            (0): Linear(in_features=2, out_features=2, bias=True)
     |            (1): Linear(in_features=2, out_features=2, bias=True)
     |          ))
     |          1 -> ('0', Linear(in_features=2, out_features=2, bias=True))
     |  
     |  named_parameters(self, prefix='', recurse=True)
     |      Returns an iterator over module parameters, yielding both the
     |      name of the parameter as well as the parameter itself.
     |      
     |      Args:
     |          prefix (str): prefix to prepend to all parameter names.
     |          recurse (bool): if True, then yields parameters of this module
     |              and all submodules. Otherwise, yields only parameters that
     |              are direct members of this module.
     |      
     |      Yields:
     |          (string, Parameter): Tuple containing the name and parameter
     |      
     |      Example::
     |      
     |          >>> for name, param in self.named_parameters():
     |          >>>    if name in ['bias']:
     |          >>>        print(param.size())
     |  
     |  parameters(self, recurse=True)
     |      Returns an iterator over module parameters.
     |      
     |      This is typically passed to an optimizer.
     |      
     |      Args:
     |          recurse (bool): if True, then yields parameters of this module
     |              and all submodules. Otherwise, yields only parameters that
     |              are direct members of this module.
     |      
     |      Yields:
     |          Parameter: module parameter
     |      
     |      Example::
     |      
     |          >>> for param in model.parameters():
     |          >>>     print(type(param.data), param.size())
     |          <class 'torch.FloatTensor'> (20L,)
     |          <class 'torch.FloatTensor'> (20L, 1L, 5L, 5L)
     |  
     |  register_backward_hook(self, hook)
     |      Registers a backward hook on the module.
     |      
     |      The hook will be called every time the gradients with respect to module
     |      inputs are computed. The hook should have the following signature::
     |      
     |          hook(module, grad_input, grad_output) -> Tensor or None
     |      
     |      The :attr:`grad_input` and :attr:`grad_output` may be tuples if the
     |      module has multiple inputs or outputs. The hook should not modify its
     |      arguments, but it can optionally return a new gradient with respect to
     |      input that will be used in place of :attr:`grad_input` in subsequent
     |      computations.
     |      
     |      Returns:
     |          :class:`torch.utils.hooks.RemovableHandle`:
     |              a handle that can be used to remove the added hook by calling
     |              ``handle.remove()``
     |      
     |      .. warning ::
     |      
     |          The current implementation will not have the presented behavior
     |          for complex :class:`Module` that perform many operations.
     |          In some failure cases, :attr:`grad_input` and :attr:`grad_output` will only
     |          contain the gradients for a subset of the inputs and outputs.
     |          For such :class:`Module`, you should use :func:`torch.Tensor.register_hook`
     |          directly on a specific input or output to get the required gradients.
     |  
     |  register_buffer(self, name, tensor)
     |      Adds a persistent buffer to the module.
     |      
     |      This is typically used to register a buffer that should not to be
     |      considered a model parameter. For example, BatchNorm's ``running_mean``
     |      is not a parameter, but is part of the persistent state.
     |      
     |      Buffers can be accessed as attributes using given names.
     |      
     |      Args:
     |          name (string): name of the buffer. The buffer can be accessed
     |              from this module using the given name
     |          tensor (Tensor): buffer to be registered.
     |      
     |      Example::
     |      
     |          >>> self.register_buffer('running_mean', torch.zeros(num_features))
     |  
     |  register_forward_hook(self, hook)
     |      Registers a forward hook on the module.
     |      
     |      The hook will be called every time after :func:`forward` has computed an output.
     |      It should have the following signature::
     |      
     |          hook(module, input, output) -> None or modified output
     |      
     |      The hook can modify the output. It can modify the input inplace but
     |      it will not have effect on forward since this is called after
     |      :func:`forward` is called.
     |      
     |      Returns:
     |          :class:`torch.utils.hooks.RemovableHandle`:
     |              a handle that can be used to remove the added hook by calling
     |              ``handle.remove()``
     |  
     |  register_forward_pre_hook(self, hook)
     |      Registers a forward pre-hook on the module.
     |      
     |      The hook will be called every time before :func:`forward` is invoked.
     |      It should have the following signature::
     |      
     |          hook(module, input) -> None or modified input
     |      
     |      The hook can modify the input. User can either return a tuple or a
     |      single modified value in the hook. We will wrap the value into a tuple
     |      if a single value is returned(unless that value is already a tuple).
     |      
     |      Returns:
     |          :class:`torch.utils.hooks.RemovableHandle`:
     |              a handle that can be used to remove the added hook by calling
     |              ``handle.remove()``
     |  
     |  register_parameter(self, name, param)
     |      Adds a parameter to the module.
     |      
     |      The parameter can be accessed as an attribute using given name.
     |      
     |      Args:
     |          name (string): name of the parameter. The parameter can be accessed
     |              from this module using the given name
     |          param (Parameter): parameter to be added to the module.
     |  
     |  requires_grad_(self, requires_grad=True)
     |      Change if autograd should record operations on parameters in this
     |      module.
     |      
     |      This method sets the parameters' :attr:`requires_grad` attributes
     |      in-place.
     |      
     |      This method is helpful for freezing part of the module for finetuning
     |      or training parts of a model individually (e.g., GAN training).
     |      
     |      Args:
     |          requires_grad (bool): whether autograd should record operations on
     |                                parameters in this module. Default: ``True``.
     |      
     |      Returns:
     |          Module: self
     |  
     |  share_memory(self)
     |  
     |  state_dict(self, destination=None, prefix='', keep_vars=False)
     |      Returns a dictionary containing a whole state of the module.
     |      
     |      Both parameters and persistent buffers (e.g. running averages) are
     |      included. Keys are corresponding parameter and buffer names.
     |      
     |      Returns:
     |          dict:
     |              a dictionary containing a whole state of the module
     |      
     |      Example::
     |      
     |          >>> module.state_dict().keys()
     |          ['bias', 'weight']
     |  
     |  to(self, *args, **kwargs)
     |      Moves and/or casts the parameters and buffers.
     |      
     |      This can be called as
     |      
     |      .. function:: to(device=None, dtype=None, non_blocking=False)
     |      
     |      .. function:: to(dtype, non_blocking=False)
     |      
     |      .. function:: to(tensor, non_blocking=False)
     |      
     |      Its signature is similar to :meth:`torch.Tensor.to`, but only accepts
     |      floating point desired :attr:`dtype` s. In addition, this method will
     |      only cast the floating point parameters and buffers to :attr:`dtype`
     |      (if given). The integral parameters and buffers will be moved
     |      :attr:`device`, if that is given, but with dtypes unchanged. When
     |      :attr:`non_blocking` is set, it tries to convert/move asynchronously
     |      with respect to the host if possible, e.g., moving CPU Tensors with
     |      pinned memory to CUDA devices.
     |      
     |      See below for examples.
     |      
     |      .. note::
     |          This method modifies the module in-place.
     |      
     |      Args:
     |          device (:class:`torch.device`): the desired device of the parameters
     |              and buffers in this module
     |          dtype (:class:`torch.dtype`): the desired floating point type of
     |              the floating point parameters and buffers in this module
     |          tensor (torch.Tensor): Tensor whose dtype and device are the desired
     |              dtype and device for all parameters and buffers in this module
     |      
     |      Returns:
     |          Module: self
     |      
     |      Example::
     |      
     |          >>> linear = nn.Linear(2, 2)
     |          >>> linear.weight
     |          Parameter containing:
     |          tensor([[ 0.1913, -0.3420],
     |                  [-0.5113, -0.2325]])
     |          >>> linear.to(torch.double)
     |          Linear(in_features=2, out_features=2, bias=True)
     |          >>> linear.weight
     |          Parameter containing:
     |          tensor([[ 0.1913, -0.3420],
     |                  [-0.5113, -0.2325]], dtype=torch.float64)
     |          >>> gpu1 = torch.device("cuda:1")
     |          >>> linear.to(gpu1, dtype=torch.half, non_blocking=True)
     |          Linear(in_features=2, out_features=2, bias=True)
     |          >>> linear.weight
     |          Parameter containing:
     |          tensor([[ 0.1914, -0.3420],
     |                  [-0.5112, -0.2324]], dtype=torch.float16, device='cuda:1')
     |          >>> cpu = torch.device("cpu")
     |          >>> linear.to(cpu)
     |          Linear(in_features=2, out_features=2, bias=True)
     |          >>> linear.weight
     |          Parameter containing:
     |          tensor([[ 0.1914, -0.3420],
     |                  [-0.5112, -0.2324]], dtype=torch.float16)
     |  
     |  train(self, mode=True)
     |      Sets the module in training mode.
     |      
     |      This has any effect only on certain modules. See documentations of
     |      particular modules for details of their behaviors in training/evaluation
     |      mode, if they are affected, e.g. :class:`Dropout`, :class:`BatchNorm`,
     |      etc.
     |      
     |      Args:
     |          mode (bool): whether to set training mode (``True``) or evaluation
     |                       mode (``False``). Default: ``True``.
     |      
     |      Returns:
     |          Module: self
     |  
     |  type(self, dst_type)
     |      Casts all parameters and buffers to :attr:`dst_type`.
     |      
     |      Arguments:
     |          dst_type (type or string): the desired type
     |      
     |      Returns:
     |          Module: self
     |  
     |  zero_grad(self)
     |      Sets gradients of all model parameters to zero.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from torch.nn.modules.module.Module:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from torch.nn.modules.module.Module:
     |  
     |  dump_patches = False

FUNCTIONS
    BDHW_LSTM(*args, **kw)
    
    BDL_LSTM(*args, **kw)
    
    BatchNorm(*args, **kw)
    
    BatchNorm1d(*args, **kw)
    
    BatchNorm2d(*args, **kw)
    
    BatchNorm3d(*args, **kw)
    
    Conv1d(*args, **kw)
    
    Conv2d(*args, **kw)
    
    Conv3d(*args, **kw)
    
    ConvTranspose1d(*args, **kw)
    
    ConvTranspose2d(*args, **kw)
    
    ConvTranspose3d(*args, **kw)
    
    LSTM(*args, **kw)
    
    Linear(*args, **kw)
    
    Lstm1 = BDL_LSTM(*args, **kw)
    
    Lstm1d = BDL_LSTM(*args, **kw)
    
    Lstm2 = BDHW_LSTM(*args, **kw)
    
    Lstm2d = BDHW_LSTM(*args, **kw)
    
    delete_modules(model, f)
    
    flex_freeze(model)
    
    flex_replacer(module)
    
    freeze(model)
    
    replace_modules(model, f)
    
    shape_inference(model, tensor, dtype=None)

DATA
    verbose = False

FILE
    /home/tmb/proj/torchmore/torchmore/flex.py


```

# module `torchmore.helpers`

```
Help on module torchmore.helpers in torchmore:

NAME
    torchmore.helpers

DESCRIPTION
    A set of helper functions for dealing uniformly with tensors and
    ndarrays.

CLASSES
    builtins.object
        LearningRateSchedule
    
    class LearningRateSchedule(builtins.object)
     |  LearningRateSchedule(schedule)
     |  
     |  Methods defined here:
     |  
     |  __call__(self, count)
     |      Call self as a function.
     |  
     |  __init__(self, schedule)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)

FUNCTIONS
    assign(dest, src, transpose_on_convert=None)
        Resizes the destination and copies the source.
    
    bdhw2bhwd(images, depth1=False)
    
    bhwd2bdhw(images, depth1=False)
    
    ctc_align(prob, target)
        Perform CTC alignment on torch sequence batches (using ocrolstm)
    
    ctc_loss(probs, target)
        A CTC loss function for BLD sequence training.
    
    reorder(batch, inp, out)
        Reorder the dimensions of the batch from inp to out order.
        
        E.g. BHWD -> BDHW.
    
    sequence_is_normalized(a, dim=-1)
    
    typeas(a, b)

FILE
    /home/tmb/proj/torchmore/torchmore/helpers.py


```

# module `torchmore.layers`

```
Help on module torchmore.layers in torchmore:

NAME
    torchmore.layers

DESCRIPTION
    # Copyright (c) 2017-2019 TBD. All rights reserved.
    # This file is part of TBD (see TBD).
    # See the LICENSE file for licensing terms (TBD).
    #

CLASSES
    torch.autograd.function.Function(torch._C._FunctionBase, torch.autograd.function._ContextMethodMixin, torch.autograd.function._HookMixin)
        WeightedGrad
    torch.nn.modules.module.Module(builtins.object)
        AcrossPooling2d
        Additive
        BDHW_LSTM
        BDHW_LSTM_to_BDH
        BDL_LSTM
        CheckOrder
        CheckRange
        CheckSizes
        Device
        Fun
        Fun_
        Info
        Input
        KeepSize
        LSTM
        NoopSub
        Parallel
        Permute
        Reorder
        Reshape
        SimplePooling2d
        Viewer
    
    class AcrossPooling2d(torch.nn.modules.module.Module)
     |  AcrossPooling2d(sub, across, mp=2, **kw)
     |  
     |  Perform max pooling/unpooling with across accumulation.
     |  
     |  Method resolution order:
     |      AcrossPooling2d
     |      torch.nn.modules.module.Module
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, sub, across, mp=2, **kw)
     |      Initializes internal Module state, shared by both nn.Module and ScriptModule.
     |  
     |  forward(self, x)
     |      Defines the computation performed at every call.
     |      
     |      Should be overridden by all subclasses.
     |      
     |      .. note::
     |          Although the recipe for forward pass needs to be defined within
     |          this function, one should call the :class:`Module` instance afterwards
     |          instead of this since the former takes care of running the
     |          registered hooks while the latter silently ignores them.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from torch.nn.modules.module.Module:
     |  
     |  __call__(self, *input, **kwargs)
     |      Call self as a function.
     |  
     |  __delattr__(self, name)
     |      Implement delattr(self, name).
     |  
     |  __dir__(self)
     |      Default dir() implementation.
     |  
     |  __getattr__(self, name)
     |  
     |  __repr__(self)
     |      Return repr(self).
     |  
     |  __setattr__(self, name, value)
     |      Implement setattr(self, name, value).
     |  
     |  __setstate__(self, state)
     |  
     |  add_module(self, name, module)
     |      Adds a child module to the current module.
     |      
     |      The module can be accessed as an attribute using the given name.
     |      
     |      Args:
     |          name (string): name of the child module. The child module can be
     |              accessed from this module using the given name
     |          module (Module): child module to be added to the module.
     |  
     |  apply(self, fn)
     |      Applies ``fn`` recursively to every submodule (as returned by ``.children()``)
     |      as well as self. Typical use includes initializing the parameters of a model
     |      (see also :ref:`nn-init-doc`).
     |      
     |      Args:
     |          fn (:class:`Module` -> None): function to be applied to each submodule
     |      
     |      Returns:
     |          Module: self
     |      
     |      Example::
     |      
     |          >>> def init_weights(m):
     |          >>>     print(m)
     |          >>>     if type(m) == nn.Linear:
     |          >>>         m.weight.data.fill_(1.0)
     |          >>>         print(m.weight)
     |          >>> net = nn.Sequential(nn.Linear(2, 2), nn.Linear(2, 2))
     |          >>> net.apply(init_weights)
     |          Linear(in_features=2, out_features=2, bias=True)
     |          Parameter containing:
     |          tensor([[ 1.,  1.],
     |                  [ 1.,  1.]])
     |          Linear(in_features=2, out_features=2, bias=True)
     |          Parameter containing:
     |          tensor([[ 1.,  1.],
     |                  [ 1.,  1.]])
     |          Sequential(
     |            (0): Linear(in_features=2, out_features=2, bias=True)
     |            (1): Linear(in_features=2, out_features=2, bias=True)
     |          )
     |          Sequential(
     |            (0): Linear(in_features=2, out_features=2, bias=True)
     |            (1): Linear(in_features=2, out_features=2, bias=True)
     |          )
     |  
     |  buffers(self, recurse=True)
     |      Returns an iterator over module buffers.
     |      
     |      Args:
     |          recurse (bool): if True, then yields buffers of this module
     |              and all submodules. Otherwise, yields only buffers that
     |              are direct members of this module.
     |      
     |      Yields:
     |          torch.Tensor: module buffer
     |      
     |      Example::
     |      
     |          >>> for buf in model.buffers():
     |          >>>     print(type(buf.data), buf.size())
     |          <class 'torch.FloatTensor'> (20L,)
     |          <class 'torch.FloatTensor'> (20L, 1L, 5L, 5L)
     |  
     |  children(self)
     |      Returns an iterator over immediate children modules.
     |      
     |      Yields:
     |          Module: a child module
     |  
     |  cpu(self)
     |      Moves all model parameters and buffers to the CPU.
     |      
     |      Returns:
     |          Module: self
     |  
     |  cuda(self, device=None)
     |      Moves all model parameters and buffers to the GPU.
     |      
     |      This also makes associated parameters and buffers different objects. So
     |      it should be called before constructing optimizer if the module will
     |      live on GPU while being optimized.
     |      
     |      Arguments:
     |          device (int, optional): if specified, all parameters will be
     |              copied to that device
     |      
     |      Returns:
     |          Module: self
     |  
     |  double(self)
     |      Casts all floating point parameters and buffers to ``double`` datatype.
     |      
     |      Returns:
     |          Module: self
     |  
     |  eval(self)
     |      Sets the module in evaluation mode.
     |      
     |      This has any effect only on certain modules. See documentations of
     |      particular modules for details of their behaviors in training/evaluation
     |      mode, if they are affected, e.g. :class:`Dropout`, :class:`BatchNorm`,
     |      etc.
     |      
     |      This is equivalent with :meth:`self.train(False) <torch.nn.Module.train>`.
     |      
     |      Returns:
     |          Module: self
     |  
     |  extra_repr(self)
     |      Set the extra representation of the module
     |      
     |      To print customized extra information, you should reimplement
     |      this method in your own modules. Both single-line and multi-line
     |      strings are acceptable.
     |  
     |  float(self)
     |      Casts all floating point parameters and buffers to float datatype.
     |      
     |      Returns:
     |          Module: self
     |  
     |  half(self)
     |      Casts all floating point parameters and buffers to ``half`` datatype.
     |      
     |      Returns:
     |          Module: self
     |  
     |  load_state_dict(self, state_dict, strict=True)
     |      Copies parameters and buffers from :attr:`state_dict` into
     |      this module and its descendants. If :attr:`strict` is ``True``, then
     |      the keys of :attr:`state_dict` must exactly match the keys returned
     |      by this module's :meth:`~torch.nn.Module.state_dict` function.
     |      
     |      Arguments:
     |          state_dict (dict): a dict containing parameters and
     |              persistent buffers.
     |          strict (bool, optional): whether to strictly enforce that the keys
     |              in :attr:`state_dict` match the keys returned by this module's
     |              :meth:`~torch.nn.Module.state_dict` function. Default: ``True``
     |      
     |      Returns:
     |          ``NamedTuple`` with ``missing_keys`` and ``unexpected_keys`` fields:
     |              * **missing_keys** is a list of str containing the missing keys
     |              * **unexpected_keys** is a list of str containing the unexpected keys
     |  
     |  modules(self)
     |      Returns an iterator over all modules in the network.
     |      
     |      Yields:
     |          Module: a module in the network
     |      
     |      Note:
     |          Duplicate modules are returned only once. In the following
     |          example, ``l`` will be returned only once.
     |      
     |      Example::
     |      
     |          >>> l = nn.Linear(2, 2)
     |          >>> net = nn.Sequential(l, l)
     |          >>> for idx, m in enumerate(net.modules()):
     |                  print(idx, '->', m)
     |      
     |          0 -> Sequential(
     |            (0): Linear(in_features=2, out_features=2, bias=True)
     |            (1): Linear(in_features=2, out_features=2, bias=True)
     |          )
     |          1 -> Linear(in_features=2, out_features=2, bias=True)
     |  
     |  named_buffers(self, prefix='', recurse=True)
     |      Returns an iterator over module buffers, yielding both the
     |      name of the buffer as well as the buffer itself.
     |      
     |      Args:
     |          prefix (str): prefix to prepend to all buffer names.
     |          recurse (bool): if True, then yields buffers of this module
     |              and all submodules. Otherwise, yields only buffers that
     |              are direct members of this module.
     |      
     |      Yields:
     |          (string, torch.Tensor): Tuple containing the name and buffer
     |      
     |      Example::
     |      
     |          >>> for name, buf in self.named_buffers():
     |          >>>    if name in ['running_var']:
     |          >>>        print(buf.size())
     |  
     |  named_children(self)
     |      Returns an iterator over immediate children modules, yielding both
     |      the name of the module as well as the module itself.
     |      
     |      Yields:
     |          (string, Module): Tuple containing a name and child module
     |      
     |      Example::
     |      
     |          >>> for name, module in model.named_children():
     |          >>>     if name in ['conv4', 'conv5']:
     |          >>>         print(module)
     |  
     |  named_modules(self, memo=None, prefix='')
     |      Returns an iterator over all modules in the network, yielding
     |      both the name of the module as well as the module itself.
     |      
     |      Yields:
     |          (string, Module): Tuple of name and module
     |      
     |      Note:
     |          Duplicate modules are returned only once. In the following
     |          example, ``l`` will be returned only once.
     |      
     |      Example::
     |      
     |          >>> l = nn.Linear(2, 2)
     |          >>> net = nn.Sequential(l, l)
     |          >>> for idx, m in enumerate(net.named_modules()):
     |                  print(idx, '->', m)
     |      
     |          0 -> ('', Sequential(
     |            (0): Linear(in_features=2, out_features=2, bias=True)
     |            (1): Linear(in_features=2, out_features=2, bias=True)
     |          ))
     |          1 -> ('0', Linear(in_features=2, out_features=2, bias=True))
     |  
     |  named_parameters(self, prefix='', recurse=True)
     |      Returns an iterator over module parameters, yielding both the
     |      name of the parameter as well as the parameter itself.
     |      
     |      Args:
     |          prefix (str): prefix to prepend to all parameter names.
     |          recurse (bool): if True, then yields parameters of this module
     |              and all submodules. Otherwise, yields only parameters that
     |              are direct members of this module.
     |      
     |      Yields:
     |          (string, Parameter): Tuple containing the name and parameter
     |      
     |      Example::
     |      
     |          >>> for name, param in self.named_parameters():
     |          >>>    if name in ['bias']:
     |          >>>        print(param.size())
     |  
     |  parameters(self, recurse=True)
     |      Returns an iterator over module parameters.
     |      
     |      This is typically passed to an optimizer.
     |      
     |      Args:
     |          recurse (bool): if True, then yields parameters of this module
     |              and all submodules. Otherwise, yields only parameters that
     |              are direct members of this module.
     |      
     |      Yields:
     |          Parameter: module parameter
     |      
     |      Example::
     |      
     |          >>> for param in model.parameters():
     |          >>>     print(type(param.data), param.size())
     |          <class 'torch.FloatTensor'> (20L,)
     |          <class 'torch.FloatTensor'> (20L, 1L, 5L, 5L)
     |  
     |  register_backward_hook(self, hook)
     |      Registers a backward hook on the module.
     |      
     |      The hook will be called every time the gradients with respect to module
     |      inputs are computed. The hook should have the following signature::
     |      
     |          hook(module, grad_input, grad_output) -> Tensor or None
     |      
     |      The :attr:`grad_input` and :attr:`grad_output` may be tuples if the
     |      module has multiple inputs or outputs. The hook should not modify its
     |      arguments, but it can optionally return a new gradient with respect to
     |      input that will be used in place of :attr:`grad_input` in subsequent
     |      computations.
     |      
     |      Returns:
     |          :class:`torch.utils.hooks.RemovableHandle`:
     |              a handle that can be used to remove the added hook by calling
     |              ``handle.remove()``
     |      
     |      .. warning ::
     |      
     |          The current implementation will not have the presented behavior
     |          for complex :class:`Module` that perform many operations.
     |          In some failure cases, :attr:`grad_input` and :attr:`grad_output` will only
     |          contain the gradients for a subset of the inputs and outputs.
     |          For such :class:`Module`, you should use :func:`torch.Tensor.register_hook`
     |          directly on a specific input or output to get the required gradients.
     |  
     |  register_buffer(self, name, tensor)
     |      Adds a persistent buffer to the module.
     |      
     |      This is typically used to register a buffer that should not to be
     |      considered a model parameter. For example, BatchNorm's ``running_mean``
     |      is not a parameter, but is part of the persistent state.
     |      
     |      Buffers can be accessed as attributes using given names.
     |      
     |      Args:
     |          name (string): name of the buffer. The buffer can be accessed
     |              from this module using the given name
     |          tensor (Tensor): buffer to be registered.
     |      
     |      Example::
     |      
     |          >>> self.register_buffer('running_mean', torch.zeros(num_features))
     |  
     |  register_forward_hook(self, hook)
     |      Registers a forward hook on the module.
     |      
     |      The hook will be called every time after :func:`forward` has computed an output.
     |      It should have the following signature::
     |      
     |          hook(module, input, output) -> None or modified output
     |      
     |      The hook can modify the output. It can modify the input inplace but
     |      it will not have effect on forward since this is called after
     |      :func:`forward` is called.
     |      
     |      Returns:
     |          :class:`torch.utils.hooks.RemovableHandle`:
     |              a handle that can be used to remove the added hook by calling
     |              ``handle.remove()``
     |  
     |  register_forward_pre_hook(self, hook)
     |      Registers a forward pre-hook on the module.
     |      
     |      The hook will be called every time before :func:`forward` is invoked.
     |      It should have the following signature::
     |      
     |          hook(module, input) -> None or modified input
     |      
     |      The hook can modify the input. User can either return a tuple or a
     |      single modified value in the hook. We will wrap the value into a tuple
     |      if a single value is returned(unless that value is already a tuple).
     |      
     |      Returns:
     |          :class:`torch.utils.hooks.RemovableHandle`:
     |              a handle that can be used to remove the added hook by calling
     |              ``handle.remove()``
     |  
     |  register_parameter(self, name, param)
     |      Adds a parameter to the module.
     |      
     |      The parameter can be accessed as an attribute using given name.
     |      
     |      Args:
     |          name (string): name of the parameter. The parameter can be accessed
     |              from this module using the given name
     |          param (Parameter): parameter to be added to the module.
     |  
     |  requires_grad_(self, requires_grad=True)
     |      Change if autograd should record operations on parameters in this
     |      module.
     |      
     |      This method sets the parameters' :attr:`requires_grad` attributes
     |      in-place.
     |      
     |      This method is helpful for freezing part of the module for finetuning
     |      or training parts of a model individually (e.g., GAN training).
     |      
     |      Args:
     |          requires_grad (bool): whether autograd should record operations on
     |                                parameters in this module. Default: ``True``.
     |      
     |      Returns:
     |          Module: self
     |  
     |  share_memory(self)
     |  
     |  state_dict(self, destination=None, prefix='', keep_vars=False)
     |      Returns a dictionary containing a whole state of the module.
     |      
     |      Both parameters and persistent buffers (e.g. running averages) are
     |      included. Keys are corresponding parameter and buffer names.
     |      
     |      Returns:
     |          dict:
     |              a dictionary containing a whole state of the module
     |      
     |      Example::
     |      
     |          >>> module.state_dict().keys()
     |          ['bias', 'weight']
     |  
     |  to(self, *args, **kwargs)
     |      Moves and/or casts the parameters and buffers.
     |      
     |      This can be called as
     |      
     |      .. function:: to(device=None, dtype=None, non_blocking=False)
     |      
     |      .. function:: to(dtype, non_blocking=False)
     |      
     |      .. function:: to(tensor, non_blocking=False)
     |      
     |      Its signature is similar to :meth:`torch.Tensor.to`, but only accepts
     |      floating point desired :attr:`dtype` s. In addition, this method will
     |      only cast the floating point parameters and buffers to :attr:`dtype`
     |      (if given). The integral parameters and buffers will be moved
     |      :attr:`device`, if that is given, but with dtypes unchanged. When
     |      :attr:`non_blocking` is set, it tries to convert/move asynchronously
     |      with respect to the host if possible, e.g., moving CPU Tensors with
     |      pinned memory to CUDA devices.
     |      
     |      See below for examples.
     |      
     |      .. note::
     |          This method modifies the module in-place.
     |      
     |      Args:
     |          device (:class:`torch.device`): the desired device of the parameters
     |              and buffers in this module
     |          dtype (:class:`torch.dtype`): the desired floating point type of
     |              the floating point parameters and buffers in this module
     |          tensor (torch.Tensor): Tensor whose dtype and device are the desired
     |              dtype and device for all parameters and buffers in this module
     |      
     |      Returns:
     |          Module: self
     |      
     |      Example::
     |      
     |          >>> linear = nn.Linear(2, 2)
     |          >>> linear.weight
     |          Parameter containing:
     |          tensor([[ 0.1913, -0.3420],
     |                  [-0.5113, -0.2325]])
     |          >>> linear.to(torch.double)
     |          Linear(in_features=2, out_features=2, bias=True)
     |          >>> linear.weight
     |          Parameter containing:
     |          tensor([[ 0.1913, -0.3420],
     |                  [-0.5113, -0.2325]], dtype=torch.float64)
     |          >>> gpu1 = torch.device("cuda:1")
     |          >>> linear.to(gpu1, dtype=torch.half, non_blocking=True)
     |          Linear(in_features=2, out_features=2, bias=True)
     |          >>> linear.weight
     |          Parameter containing:
     |          tensor([[ 0.1914, -0.3420],
     |                  [-0.5112, -0.2324]], dtype=torch.float16, device='cuda:1')
     |          >>> cpu = torch.device("cpu")
     |          >>> linear.to(cpu)
     |          Linear(in_features=2, out_features=2, bias=True)
     |          >>> linear.weight
     |          Parameter containing:
     |          tensor([[ 0.1914, -0.3420],
     |                  [-0.5112, -0.2324]], dtype=torch.float16)
     |  
     |  train(self, mode=True)
     |      Sets the module in training mode.
     |      
     |      This has any effect only on certain modules. See documentations of
     |      particular modules for details of their behaviors in training/evaluation
     |      mode, if they are affected, e.g. :class:`Dropout`, :class:`BatchNorm`,
     |      etc.
     |      
     |      Args:
     |          mode (bool): whether to set training mode (``True``) or evaluation
     |                       mode (``False``). Default: ``True``.
     |      
     |      Returns:
     |          Module: self
     |  
     |  type(self, dst_type)
     |      Casts all parameters and buffers to :attr:`dst_type`.
     |      
     |      Arguments:
     |          dst_type (type or string): the desired type
     |      
     |      Returns:
     |          Module: self
     |  
     |  zero_grad(self)
     |      Sets gradients of all model parameters to zero.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from torch.nn.modules.module.Module:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from torch.nn.modules.module.Module:
     |  
     |  dump_patches = False
    
    class Additive(torch.nn.modules.module.Module)
     |  Additive(*args, post=None)
     |  
     |  Additive wrap-around module for Resnet-style architectures.
     |  
     |  :args: modules whose output is to be added
     |  :post: module to execute after everything has been added
     |  
     |  Method resolution order:
     |      Additive
     |      torch.nn.modules.module.Module
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, *args, post=None)
     |      Initializes internal Module state, shared by both nn.Module and ScriptModule.
     |  
     |  forward(self, x)
     |      Defines the computation performed at every call.
     |      
     |      Should be overridden by all subclasses.
     |      
     |      .. note::
     |          Although the recipe for forward pass needs to be defined within
     |          this function, one should call the :class:`Module` instance afterwards
     |          instead of this since the former takes care of running the
     |          registered hooks while the latter silently ignores them.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from torch.nn.modules.module.Module:
     |  
     |  __call__(self, *input, **kwargs)
     |      Call self as a function.
     |  
     |  __delattr__(self, name)
     |      Implement delattr(self, name).
     |  
     |  __dir__(self)
     |      Default dir() implementation.
     |  
     |  __getattr__(self, name)
     |  
     |  __repr__(self)
     |      Return repr(self).
     |  
     |  __setattr__(self, name, value)
     |      Implement setattr(self, name, value).
     |  
     |  __setstate__(self, state)
     |  
     |  add_module(self, name, module)
     |      Adds a child module to the current module.
     |      
     |      The module can be accessed as an attribute using the given name.
     |      
     |      Args:
     |          name (string): name of the child module. The child module can be
     |              accessed from this module using the given name
     |          module (Module): child module to be added to the module.
     |  
     |  apply(self, fn)
     |      Applies ``fn`` recursively to every submodule (as returned by ``.children()``)
     |      as well as self. Typical use includes initializing the parameters of a model
     |      (see also :ref:`nn-init-doc`).
     |      
     |      Args:
     |          fn (:class:`Module` -> None): function to be applied to each submodule
     |      
     |      Returns:
     |          Module: self
     |      
     |      Example::
     |      
     |          >>> def init_weights(m):
     |          >>>     print(m)
     |          >>>     if type(m) == nn.Linear:
     |          >>>         m.weight.data.fill_(1.0)
     |          >>>         print(m.weight)
     |          >>> net = nn.Sequential(nn.Linear(2, 2), nn.Linear(2, 2))
     |          >>> net.apply(init_weights)
     |          Linear(in_features=2, out_features=2, bias=True)
     |          Parameter containing:
     |          tensor([[ 1.,  1.],
     |                  [ 1.,  1.]])
     |          Linear(in_features=2, out_features=2, bias=True)
     |          Parameter containing:
     |          tensor([[ 1.,  1.],
     |                  [ 1.,  1.]])
     |          Sequential(
     |            (0): Linear(in_features=2, out_features=2, bias=True)
     |            (1): Linear(in_features=2, out_features=2, bias=True)
     |          )
     |          Sequential(
     |            (0): Linear(in_features=2, out_features=2, bias=True)
     |            (1): Linear(in_features=2, out_features=2, bias=True)
     |          )
     |  
     |  buffers(self, recurse=True)
     |      Returns an iterator over module buffers.
     |      
     |      Args:
     |          recurse (bool): if True, then yields buffers of this module
     |              and all submodules. Otherwise, yields only buffers that
     |              are direct members of this module.
     |      
     |      Yields:
     |          torch.Tensor: module buffer
     |      
     |      Example::
     |      
     |          >>> for buf in model.buffers():
     |          >>>     print(type(buf.data), buf.size())
     |          <class 'torch.FloatTensor'> (20L,)
     |          <class 'torch.FloatTensor'> (20L, 1L, 5L, 5L)
     |  
     |  children(self)
     |      Returns an iterator over immediate children modules.
     |      
     |      Yields:
     |          Module: a child module
     |  
     |  cpu(self)
     |      Moves all model parameters and buffers to the CPU.
     |      
     |      Returns:
     |          Module: self
     |  
     |  cuda(self, device=None)
     |      Moves all model parameters and buffers to the GPU.
     |      
     |      This also makes associated parameters and buffers different objects. So
     |      it should be called before constructing optimizer if the module will
     |      live on GPU while being optimized.
     |      
     |      Arguments:
     |          device (int, optional): if specified, all parameters will be
     |              copied to that device
     |      
     |      Returns:
     |          Module: self
     |  
     |  double(self)
     |      Casts all floating point parameters and buffers to ``double`` datatype.
     |      
     |      Returns:
     |          Module: self
     |  
     |  eval(self)
     |      Sets the module in evaluation mode.
     |      
     |      This has any effect only on certain modules. See documentations of
     |      particular modules for details of their behaviors in training/evaluation
     |      mode, if they are affected, e.g. :class:`Dropout`, :class:`BatchNorm`,
     |      etc.
     |      
     |      This is equivalent with :meth:`self.train(False) <torch.nn.Module.train>`.
     |      
     |      Returns:
     |          Module: self
     |  
     |  extra_repr(self)
     |      Set the extra representation of the module
     |      
     |      To print customized extra information, you should reimplement
     |      this method in your own modules. Both single-line and multi-line
     |      strings are acceptable.
     |  
     |  float(self)
     |      Casts all floating point parameters and buffers to float datatype.
     |      
     |      Returns:
     |          Module: self
     |  
     |  half(self)
     |      Casts all floating point parameters and buffers to ``half`` datatype.
     |      
     |      Returns:
     |          Module: self
     |  
     |  load_state_dict(self, state_dict, strict=True)
     |      Copies parameters and buffers from :attr:`state_dict` into
     |      this module and its descendants. If :attr:`strict` is ``True``, then
     |      the keys of :attr:`state_dict` must exactly match the keys returned
     |      by this module's :meth:`~torch.nn.Module.state_dict` function.
     |      
     |      Arguments:
     |          state_dict (dict): a dict containing parameters and
     |              persistent buffers.
     |          strict (bool, optional): whether to strictly enforce that the keys
     |              in :attr:`state_dict` match the keys returned by this module's
     |              :meth:`~torch.nn.Module.state_dict` function. Default: ``True``
     |      
     |      Returns:
     |          ``NamedTuple`` with ``missing_keys`` and ``unexpected_keys`` fields:
     |              * **missing_keys** is a list of str containing the missing keys
     |              * **unexpected_keys** is a list of str containing the unexpected keys
     |  
     |  modules(self)
     |      Returns an iterator over all modules in the network.
     |      
     |      Yields:
     |          Module: a module in the network
     |      
     |      Note:
     |          Duplicate modules are returned only once. In the following
     |          example, ``l`` will be returned only once.
     |      
     |      Example::
     |      
     |          >>> l = nn.Linear(2, 2)
     |          >>> net = nn.Sequential(l, l)
     |          >>> for idx, m in enumerate(net.modules()):
     |                  print(idx, '->', m)
     |      
     |          0 -> Sequential(
     |            (0): Linear(in_features=2, out_features=2, bias=True)
     |            (1): Linear(in_features=2, out_features=2, bias=True)
     |          )
     |          1 -> Linear(in_features=2, out_features=2, bias=True)
     |  
     |  named_buffers(self, prefix='', recurse=True)
     |      Returns an iterator over module buffers, yielding both the
     |      name of the buffer as well as the buffer itself.
     |      
     |      Args:
     |          prefix (str): prefix to prepend to all buffer names.
     |          recurse (bool): if True, then yields buffers of this module
     |              and all submodules. Otherwise, yields only buffers that
     |              are direct members of this module.
     |      
     |      Yields:
     |          (string, torch.Tensor): Tuple containing the name and buffer
     |      
     |      Example::
     |      
     |          >>> for name, buf in self.named_buffers():
     |          >>>    if name in ['running_var']:
     |          >>>        print(buf.size())
     |  
     |  named_children(self)
     |      Returns an iterator over immediate children modules, yielding both
     |      the name of the module as well as the module itself.
     |      
     |      Yields:
     |          (string, Module): Tuple containing a name and child module
     |      
     |      Example::
     |      
     |          >>> for name, module in model.named_children():
     |          >>>     if name in ['conv4', 'conv5']:
     |          >>>         print(module)
     |  
     |  named_modules(self, memo=None, prefix='')
     |      Returns an iterator over all modules in the network, yielding
     |      both the name of the module as well as the module itself.
     |      
     |      Yields:
     |          (string, Module): Tuple of name and module
     |      
     |      Note:
     |          Duplicate modules are returned only once. In the following
     |          example, ``l`` will be returned only once.
     |      
     |      Example::
     |      
     |          >>> l = nn.Linear(2, 2)
     |          >>> net = nn.Sequential(l, l)
     |          >>> for idx, m in enumerate(net.named_modules()):
     |                  print(idx, '->', m)
     |      
     |          0 -> ('', Sequential(
     |            (0): Linear(in_features=2, out_features=2, bias=True)
     |            (1): Linear(in_features=2, out_features=2, bias=True)
     |          ))
     |          1 -> ('0', Linear(in_features=2, out_features=2, bias=True))
     |  
     |  named_parameters(self, prefix='', recurse=True)
     |      Returns an iterator over module parameters, yielding both the
     |      name of the parameter as well as the parameter itself.
     |      
     |      Args:
     |          prefix (str): prefix to prepend to all parameter names.
     |          recurse (bool): if True, then yields parameters of this module
     |              and all submodules. Otherwise, yields only parameters that
     |              are direct members of this module.
     |      
     |      Yields:
     |          (string, Parameter): Tuple containing the name and parameter
     |      
     |      Example::
     |      
     |          >>> for name, param in self.named_parameters():
     |          >>>    if name in ['bias']:
     |          >>>        print(param.size())
     |  
     |  parameters(self, recurse=True)
     |      Returns an iterator over module parameters.
     |      
     |      This is typically passed to an optimizer.
     |      
     |      Args:
     |          recurse (bool): if True, then yields parameters of this module
     |              and all submodules. Otherwise, yields only parameters that
     |              are direct members of this module.
     |      
     |      Yields:
     |          Parameter: module parameter
     |      
     |      Example::
     |      
     |          >>> for param in model.parameters():
     |          >>>     print(type(param.data), param.size())
     |          <class 'torch.FloatTensor'> (20L,)
     |          <class 'torch.FloatTensor'> (20L, 1L, 5L, 5L)
     |  
     |  register_backward_hook(self, hook)
     |      Registers a backward hook on the module.
     |      
     |      The hook will be called every time the gradients with respect to module
     |      inputs are computed. The hook should have the following signature::
     |      
     |          hook(module, grad_input, grad_output) -> Tensor or None
     |      
     |      The :attr:`grad_input` and :attr:`grad_output` may be tuples if the
     |      module has multiple inputs or outputs. The hook should not modify its
     |      arguments, but it can optionally return a new gradient with respect to
     |      input that will be used in place of :attr:`grad_input` in subsequent
     |      computations.
     |      
     |      Returns:
     |          :class:`torch.utils.hooks.RemovableHandle`:
     |              a handle that can be used to remove the added hook by calling
     |              ``handle.remove()``
     |      
     |      .. warning ::
     |      
     |          The current implementation will not have the presented behavior
     |          for complex :class:`Module` that perform many operations.
     |          In some failure cases, :attr:`grad_input` and :attr:`grad_output` will only
     |          contain the gradients for a subset of the inputs and outputs.
     |          For such :class:`Module`, you should use :func:`torch.Tensor.register_hook`
     |          directly on a specific input or output to get the required gradients.
     |  
     |  register_buffer(self, name, tensor)
     |      Adds a persistent buffer to the module.
     |      
     |      This is typically used to register a buffer that should not to be
     |      considered a model parameter. For example, BatchNorm's ``running_mean``
     |      is not a parameter, but is part of the persistent state.
     |      
     |      Buffers can be accessed as attributes using given names.
     |      
     |      Args:
     |          name (string): name of the buffer. The buffer can be accessed
     |              from this module using the given name
     |          tensor (Tensor): buffer to be registered.
     |      
     |      Example::
     |      
     |          >>> self.register_buffer('running_mean', torch.zeros(num_features))
     |  
     |  register_forward_hook(self, hook)
     |      Registers a forward hook on the module.
     |      
     |      The hook will be called every time after :func:`forward` has computed an output.
     |      It should have the following signature::
     |      
     |          hook(module, input, output) -> None or modified output
     |      
     |      The hook can modify the output. It can modify the input inplace but
     |      it will not have effect on forward since this is called after
     |      :func:`forward` is called.
     |      
     |      Returns:
     |          :class:`torch.utils.hooks.RemovableHandle`:
     |              a handle that can be used to remove the added hook by calling
     |              ``handle.remove()``
     |  
     |  register_forward_pre_hook(self, hook)
     |      Registers a forward pre-hook on the module.
     |      
     |      The hook will be called every time before :func:`forward` is invoked.
     |      It should have the following signature::
     |      
     |          hook(module, input) -> None or modified input
     |      
     |      The hook can modify the input. User can either return a tuple or a
     |      single modified value in the hook. We will wrap the value into a tuple
     |      if a single value is returned(unless that value is already a tuple).
     |      
     |      Returns:
     |          :class:`torch.utils.hooks.RemovableHandle`:
     |              a handle that can be used to remove the added hook by calling
     |              ``handle.remove()``
     |  
     |  register_parameter(self, name, param)
     |      Adds a parameter to the module.
     |      
     |      The parameter can be accessed as an attribute using given name.
     |      
     |      Args:
     |          name (string): name of the parameter. The parameter can be accessed
     |              from this module using the given name
     |          param (Parameter): parameter to be added to the module.
     |  
     |  requires_grad_(self, requires_grad=True)
     |      Change if autograd should record operations on parameters in this
     |      module.
     |      
     |      This method sets the parameters' :attr:`requires_grad` attributes
     |      in-place.
     |      
     |      This method is helpful for freezing part of the module for finetuning
     |      or training parts of a model individually (e.g., GAN training).
     |      
     |      Args:
     |          requires_grad (bool): whether autograd should record operations on
     |                                parameters in this module. Default: ``True``.
     |      
     |      Returns:
     |          Module: self
     |  
     |  share_memory(self)
     |  
     |  state_dict(self, destination=None, prefix='', keep_vars=False)
     |      Returns a dictionary containing a whole state of the module.
     |      
     |      Both parameters and persistent buffers (e.g. running averages) are
     |      included. Keys are corresponding parameter and buffer names.
     |      
     |      Returns:
     |          dict:
     |              a dictionary containing a whole state of the module
     |      
     |      Example::
     |      
     |          >>> module.state_dict().keys()
     |          ['bias', 'weight']
     |  
     |  to(self, *args, **kwargs)
     |      Moves and/or casts the parameters and buffers.
     |      
     |      This can be called as
     |      
     |      .. function:: to(device=None, dtype=None, non_blocking=False)
     |      
     |      .. function:: to(dtype, non_blocking=False)
     |      
     |      .. function:: to(tensor, non_blocking=False)
     |      
     |      Its signature is similar to :meth:`torch.Tensor.to`, but only accepts
     |      floating point desired :attr:`dtype` s. In addition, this method will
     |      only cast the floating point parameters and buffers to :attr:`dtype`
     |      (if given). The integral parameters and buffers will be moved
     |      :attr:`device`, if that is given, but with dtypes unchanged. When
     |      :attr:`non_blocking` is set, it tries to convert/move asynchronously
     |      with respect to the host if possible, e.g., moving CPU Tensors with
     |      pinned memory to CUDA devices.
     |      
     |      See below for examples.
     |      
     |      .. note::
     |          This method modifies the module in-place.
     |      
     |      Args:
     |          device (:class:`torch.device`): the desired device of the parameters
     |              and buffers in this module
     |          dtype (:class:`torch.dtype`): the desired floating point type of
     |              the floating point parameters and buffers in this module
     |          tensor (torch.Tensor): Tensor whose dtype and device are the desired
     |              dtype and device for all parameters and buffers in this module
     |      
     |      Returns:
     |          Module: self
     |      
     |      Example::
     |      
     |          >>> linear = nn.Linear(2, 2)
     |          >>> linear.weight
     |          Parameter containing:
     |          tensor([[ 0.1913, -0.3420],
     |                  [-0.5113, -0.2325]])
     |          >>> linear.to(torch.double)
     |          Linear(in_features=2, out_features=2, bias=True)
     |          >>> linear.weight
     |          Parameter containing:
     |          tensor([[ 0.1913, -0.3420],
     |                  [-0.5113, -0.2325]], dtype=torch.float64)
     |          >>> gpu1 = torch.device("cuda:1")
     |          >>> linear.to(gpu1, dtype=torch.half, non_blocking=True)
     |          Linear(in_features=2, out_features=2, bias=True)
     |          >>> linear.weight
     |          Parameter containing:
     |          tensor([[ 0.1914, -0.3420],
     |                  [-0.5112, -0.2324]], dtype=torch.float16, device='cuda:1')
     |          >>> cpu = torch.device("cpu")
     |          >>> linear.to(cpu)
     |          Linear(in_features=2, out_features=2, bias=True)
     |          >>> linear.weight
     |          Parameter containing:
     |          tensor([[ 0.1914, -0.3420],
     |                  [-0.5112, -0.2324]], dtype=torch.float16)
     |  
     |  train(self, mode=True)
     |      Sets the module in training mode.
     |      
     |      This has any effect only on certain modules. See documentations of
     |      particular modules for details of their behaviors in training/evaluation
     |      mode, if they are affected, e.g. :class:`Dropout`, :class:`BatchNorm`,
     |      etc.
     |      
     |      Args:
     |          mode (bool): whether to set training mode (``True``) or evaluation
     |                       mode (``False``). Default: ``True``.
     |      
     |      Returns:
     |          Module: self
     |  
     |  type(self, dst_type)
     |      Casts all parameters and buffers to :attr:`dst_type`.
     |      
     |      Arguments:
     |          dst_type (type or string): the desired type
     |      
     |      Returns:
     |          Module: self
     |  
     |  zero_grad(self)
     |      Sets gradients of all model parameters to zero.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from torch.nn.modules.module.Module:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from torch.nn.modules.module.Module:
     |  
     |  dump_patches = False
    
    class BDHW_LSTM(torch.nn.modules.module.Module)
     |  BDHW_LSTM(ninput=None, noutput=None, nhidden=None, num_layers=1, bidirectional=True)
     |  
     |  A 2D LSTM module.
     |  
     |  Input order as for 2D convolutions.
     |  
     |  Method resolution order:
     |      BDHW_LSTM
     |      torch.nn.modules.module.Module
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, ninput=None, noutput=None, nhidden=None, num_layers=1, bidirectional=True)
     |      Initializes internal Module state, shared by both nn.Module and ScriptModule.
     |  
     |  forward(self, img)
     |      Defines the computation performed at every call.
     |      
     |      Should be overridden by all subclasses.
     |      
     |      .. note::
     |          Although the recipe for forward pass needs to be defined within
     |          this function, one should call the :class:`Module` instance afterwards
     |          instead of this since the former takes care of running the
     |          registered hooks while the latter silently ignores them.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from torch.nn.modules.module.Module:
     |  
     |  __call__(self, *input, **kwargs)
     |      Call self as a function.
     |  
     |  __delattr__(self, name)
     |      Implement delattr(self, name).
     |  
     |  __dir__(self)
     |      Default dir() implementation.
     |  
     |  __getattr__(self, name)
     |  
     |  __repr__(self)
     |      Return repr(self).
     |  
     |  __setattr__(self, name, value)
     |      Implement setattr(self, name, value).
     |  
     |  __setstate__(self, state)
     |  
     |  add_module(self, name, module)
     |      Adds a child module to the current module.
     |      
     |      The module can be accessed as an attribute using the given name.
     |      
     |      Args:
     |          name (string): name of the child module. The child module can be
     |              accessed from this module using the given name
     |          module (Module): child module to be added to the module.
     |  
     |  apply(self, fn)
     |      Applies ``fn`` recursively to every submodule (as returned by ``.children()``)
     |      as well as self. Typical use includes initializing the parameters of a model
     |      (see also :ref:`nn-init-doc`).
     |      
     |      Args:
     |          fn (:class:`Module` -> None): function to be applied to each submodule
     |      
     |      Returns:
     |          Module: self
     |      
     |      Example::
     |      
     |          >>> def init_weights(m):
     |          >>>     print(m)
     |          >>>     if type(m) == nn.Linear:
     |          >>>         m.weight.data.fill_(1.0)
     |          >>>         print(m.weight)
     |          >>> net = nn.Sequential(nn.Linear(2, 2), nn.Linear(2, 2))
     |          >>> net.apply(init_weights)
     |          Linear(in_features=2, out_features=2, bias=True)
     |          Parameter containing:
     |          tensor([[ 1.,  1.],
     |                  [ 1.,  1.]])
     |          Linear(in_features=2, out_features=2, bias=True)
     |          Parameter containing:
     |          tensor([[ 1.,  1.],
     |                  [ 1.,  1.]])
     |          Sequential(
     |            (0): Linear(in_features=2, out_features=2, bias=True)
     |            (1): Linear(in_features=2, out_features=2, bias=True)
     |          )
     |          Sequential(
     |            (0): Linear(in_features=2, out_features=2, bias=True)
     |            (1): Linear(in_features=2, out_features=2, bias=True)
     |          )
     |  
     |  buffers(self, recurse=True)
     |      Returns an iterator over module buffers.
     |      
     |      Args:
     |          recurse (bool): if True, then yields buffers of this module
     |              and all submodules. Otherwise, yields only buffers that
     |              are direct members of this module.
     |      
     |      Yields:
     |          torch.Tensor: module buffer
     |      
     |      Example::
     |      
     |          >>> for buf in model.buffers():
     |          >>>     print(type(buf.data), buf.size())
     |          <class 'torch.FloatTensor'> (20L,)
     |          <class 'torch.FloatTensor'> (20L, 1L, 5L, 5L)
     |  
     |  children(self)
     |      Returns an iterator over immediate children modules.
     |      
     |      Yields:
     |          Module: a child module
     |  
     |  cpu(self)
     |      Moves all model parameters and buffers to the CPU.
     |      
     |      Returns:
     |          Module: self
     |  
     |  cuda(self, device=None)
     |      Moves all model parameters and buffers to the GPU.
     |      
     |      This also makes associated parameters and buffers different objects. So
     |      it should be called before constructing optimizer if the module will
     |      live on GPU while being optimized.
     |      
     |      Arguments:
     |          device (int, optional): if specified, all parameters will be
     |              copied to that device
     |      
     |      Returns:
     |          Module: self
     |  
     |  double(self)
     |      Casts all floating point parameters and buffers to ``double`` datatype.
     |      
     |      Returns:
     |          Module: self
     |  
     |  eval(self)
     |      Sets the module in evaluation mode.
     |      
     |      This has any effect only on certain modules. See documentations of
     |      particular modules for details of their behaviors in training/evaluation
     |      mode, if they are affected, e.g. :class:`Dropout`, :class:`BatchNorm`,
     |      etc.
     |      
     |      This is equivalent with :meth:`self.train(False) <torch.nn.Module.train>`.
     |      
     |      Returns:
     |          Module: self
     |  
     |  extra_repr(self)
     |      Set the extra representation of the module
     |      
     |      To print customized extra information, you should reimplement
     |      this method in your own modules. Both single-line and multi-line
     |      strings are acceptable.
     |  
     |  float(self)
     |      Casts all floating point parameters and buffers to float datatype.
     |      
     |      Returns:
     |          Module: self
     |  
     |  half(self)
     |      Casts all floating point parameters and buffers to ``half`` datatype.
     |      
     |      Returns:
     |          Module: self
     |  
     |  load_state_dict(self, state_dict, strict=True)
     |      Copies parameters and buffers from :attr:`state_dict` into
     |      this module and its descendants. If :attr:`strict` is ``True``, then
     |      the keys of :attr:`state_dict` must exactly match the keys returned
     |      by this module's :meth:`~torch.nn.Module.state_dict` function.
     |      
     |      Arguments:
     |          state_dict (dict): a dict containing parameters and
     |              persistent buffers.
     |          strict (bool, optional): whether to strictly enforce that the keys
     |              in :attr:`state_dict` match the keys returned by this module's
     |              :meth:`~torch.nn.Module.state_dict` function. Default: ``True``
     |      
     |      Returns:
     |          ``NamedTuple`` with ``missing_keys`` and ``unexpected_keys`` fields:
     |              * **missing_keys** is a list of str containing the missing keys
     |              * **unexpected_keys** is a list of str containing the unexpected keys
     |  
     |  modules(self)
     |      Returns an iterator over all modules in the network.
     |      
     |      Yields:
     |          Module: a module in the network
     |      
     |      Note:
     |          Duplicate modules are returned only once. In the following
     |          example, ``l`` will be returned only once.
     |      
     |      Example::
     |      
     |          >>> l = nn.Linear(2, 2)
     |          >>> net = nn.Sequential(l, l)
     |          >>> for idx, m in enumerate(net.modules()):
     |                  print(idx, '->', m)
     |      
     |          0 -> Sequential(
     |            (0): Linear(in_features=2, out_features=2, bias=True)
     |            (1): Linear(in_features=2, out_features=2, bias=True)
     |          )
     |          1 -> Linear(in_features=2, out_features=2, bias=True)
     |  
     |  named_buffers(self, prefix='', recurse=True)
     |      Returns an iterator over module buffers, yielding both the
     |      name of the buffer as well as the buffer itself.
     |      
     |      Args:
     |          prefix (str): prefix to prepend to all buffer names.
     |          recurse (bool): if True, then yields buffers of this module
     |              and all submodules. Otherwise, yields only buffers that
     |              are direct members of this module.
     |      
     |      Yields:
     |          (string, torch.Tensor): Tuple containing the name and buffer
     |      
     |      Example::
     |      
     |          >>> for name, buf in self.named_buffers():
     |          >>>    if name in ['running_var']:
     |          >>>        print(buf.size())
     |  
     |  named_children(self)
     |      Returns an iterator over immediate children modules, yielding both
     |      the name of the module as well as the module itself.
     |      
     |      Yields:
     |          (string, Module): Tuple containing a name and child module
     |      
     |      Example::
     |      
     |          >>> for name, module in model.named_children():
     |          >>>     if name in ['conv4', 'conv5']:
     |          >>>         print(module)
     |  
     |  named_modules(self, memo=None, prefix='')
     |      Returns an iterator over all modules in the network, yielding
     |      both the name of the module as well as the module itself.
     |      
     |      Yields:
     |          (string, Module): Tuple of name and module
     |      
     |      Note:
     |          Duplicate modules are returned only once. In the following
     |          example, ``l`` will be returned only once.
     |      
     |      Example::
     |      
     |          >>> l = nn.Linear(2, 2)
     |          >>> net = nn.Sequential(l, l)
     |          >>> for idx, m in enumerate(net.named_modules()):
     |                  print(idx, '->', m)
     |      
     |          0 -> ('', Sequential(
     |            (0): Linear(in_features=2, out_features=2, bias=True)
     |            (1): Linear(in_features=2, out_features=2, bias=True)
     |          ))
     |          1 -> ('0', Linear(in_features=2, out_features=2, bias=True))
     |  
     |  named_parameters(self, prefix='', recurse=True)
     |      Returns an iterator over module parameters, yielding both the
     |      name of the parameter as well as the parameter itself.
     |      
     |      Args:
     |          prefix (str): prefix to prepend to all parameter names.
     |          recurse (bool): if True, then yields parameters of this module
     |              and all submodules. Otherwise, yields only parameters that
     |              are direct members of this module.
     |      
     |      Yields:
     |          (string, Parameter): Tuple containing the name and parameter
     |      
     |      Example::
     |      
     |          >>> for name, param in self.named_parameters():
     |          >>>    if name in ['bias']:
     |          >>>        print(param.size())
     |  
     |  parameters(self, recurse=True)
     |      Returns an iterator over module parameters.
     |      
     |      This is typically passed to an optimizer.
     |      
     |      Args:
     |          recurse (bool): if True, then yields parameters of this module
     |              and all submodules. Otherwise, yields only parameters that
     |              are direct members of this module.
     |      
     |      Yields:
     |          Parameter: module parameter
     |      
     |      Example::
     |      
     |          >>> for param in model.parameters():
     |          >>>     print(type(param.data), param.size())
     |          <class 'torch.FloatTensor'> (20L,)
     |          <class 'torch.FloatTensor'> (20L, 1L, 5L, 5L)
     |  
     |  register_backward_hook(self, hook)
     |      Registers a backward hook on the module.
     |      
     |      The hook will be called every time the gradients with respect to module
     |      inputs are computed. The hook should have the following signature::
     |      
     |          hook(module, grad_input, grad_output) -> Tensor or None
     |      
     |      The :attr:`grad_input` and :attr:`grad_output` may be tuples if the
     |      module has multiple inputs or outputs. The hook should not modify its
     |      arguments, but it can optionally return a new gradient with respect to
     |      input that will be used in place of :attr:`grad_input` in subsequent
     |      computations.
     |      
     |      Returns:
     |          :class:`torch.utils.hooks.RemovableHandle`:
     |              a handle that can be used to remove the added hook by calling
     |              ``handle.remove()``
     |      
     |      .. warning ::
     |      
     |          The current implementation will not have the presented behavior
     |          for complex :class:`Module` that perform many operations.
     |          In some failure cases, :attr:`grad_input` and :attr:`grad_output` will only
     |          contain the gradients for a subset of the inputs and outputs.
     |          For such :class:`Module`, you should use :func:`torch.Tensor.register_hook`
     |          directly on a specific input or output to get the required gradients.
     |  
     |  register_buffer(self, name, tensor)
     |      Adds a persistent buffer to the module.
     |      
     |      This is typically used to register a buffer that should not to be
     |      considered a model parameter. For example, BatchNorm's ``running_mean``
     |      is not a parameter, but is part of the persistent state.
     |      
     |      Buffers can be accessed as attributes using given names.
     |      
     |      Args:
     |          name (string): name of the buffer. The buffer can be accessed
     |              from this module using the given name
     |          tensor (Tensor): buffer to be registered.
     |      
     |      Example::
     |      
     |          >>> self.register_buffer('running_mean', torch.zeros(num_features))
     |  
     |  register_forward_hook(self, hook)
     |      Registers a forward hook on the module.
     |      
     |      The hook will be called every time after :func:`forward` has computed an output.
     |      It should have the following signature::
     |      
     |          hook(module, input, output) -> None or modified output
     |      
     |      The hook can modify the output. It can modify the input inplace but
     |      it will not have effect on forward since this is called after
     |      :func:`forward` is called.
     |      
     |      Returns:
     |          :class:`torch.utils.hooks.RemovableHandle`:
     |              a handle that can be used to remove the added hook by calling
     |              ``handle.remove()``
     |  
     |  register_forward_pre_hook(self, hook)
     |      Registers a forward pre-hook on the module.
     |      
     |      The hook will be called every time before :func:`forward` is invoked.
     |      It should have the following signature::
     |      
     |          hook(module, input) -> None or modified input
     |      
     |      The hook can modify the input. User can either return a tuple or a
     |      single modified value in the hook. We will wrap the value into a tuple
     |      if a single value is returned(unless that value is already a tuple).
     |      
     |      Returns:
     |          :class:`torch.utils.hooks.RemovableHandle`:
     |              a handle that can be used to remove the added hook by calling
     |              ``handle.remove()``
     |  
     |  register_parameter(self, name, param)
     |      Adds a parameter to the module.
     |      
     |      The parameter can be accessed as an attribute using given name.
     |      
     |      Args:
     |          name (string): name of the parameter. The parameter can be accessed
     |              from this module using the given name
     |          param (Parameter): parameter to be added to the module.
     |  
     |  requires_grad_(self, requires_grad=True)
     |      Change if autograd should record operations on parameters in this
     |      module.
     |      
     |      This method sets the parameters' :attr:`requires_grad` attributes
     |      in-place.
     |      
     |      This method is helpful for freezing part of the module for finetuning
     |      or training parts of a model individually (e.g., GAN training).
     |      
     |      Args:
     |          requires_grad (bool): whether autograd should record operations on
     |                                parameters in this module. Default: ``True``.
     |      
     |      Returns:
     |          Module: self
     |  
     |  share_memory(self)
     |  
     |  state_dict(self, destination=None, prefix='', keep_vars=False)
     |      Returns a dictionary containing a whole state of the module.
     |      
     |      Both parameters and persistent buffers (e.g. running averages) are
     |      included. Keys are corresponding parameter and buffer names.
     |      
     |      Returns:
     |          dict:
     |              a dictionary containing a whole state of the module
     |      
     |      Example::
     |      
     |          >>> module.state_dict().keys()
     |          ['bias', 'weight']
     |  
     |  to(self, *args, **kwargs)
     |      Moves and/or casts the parameters and buffers.
     |      
     |      This can be called as
     |      
     |      .. function:: to(device=None, dtype=None, non_blocking=False)
     |      
     |      .. function:: to(dtype, non_blocking=False)
     |      
     |      .. function:: to(tensor, non_blocking=False)
     |      
     |      Its signature is similar to :meth:`torch.Tensor.to`, but only accepts
     |      floating point desired :attr:`dtype` s. In addition, this method will
     |      only cast the floating point parameters and buffers to :attr:`dtype`
     |      (if given). The integral parameters and buffers will be moved
     |      :attr:`device`, if that is given, but with dtypes unchanged. When
     |      :attr:`non_blocking` is set, it tries to convert/move asynchronously
     |      with respect to the host if possible, e.g., moving CPU Tensors with
     |      pinned memory to CUDA devices.
     |      
     |      See below for examples.
     |      
     |      .. note::
     |          This method modifies the module in-place.
     |      
     |      Args:
     |          device (:class:`torch.device`): the desired device of the parameters
     |              and buffers in this module
     |          dtype (:class:`torch.dtype`): the desired floating point type of
     |              the floating point parameters and buffers in this module
     |          tensor (torch.Tensor): Tensor whose dtype and device are the desired
     |              dtype and device for all parameters and buffers in this module
     |      
     |      Returns:
     |          Module: self
     |      
     |      Example::
     |      
     |          >>> linear = nn.Linear(2, 2)
     |          >>> linear.weight
     |          Parameter containing:
     |          tensor([[ 0.1913, -0.3420],
     |                  [-0.5113, -0.2325]])
     |          >>> linear.to(torch.double)
     |          Linear(in_features=2, out_features=2, bias=True)
     |          >>> linear.weight
     |          Parameter containing:
     |          tensor([[ 0.1913, -0.3420],
     |                  [-0.5113, -0.2325]], dtype=torch.float64)
     |          >>> gpu1 = torch.device("cuda:1")
     |          >>> linear.to(gpu1, dtype=torch.half, non_blocking=True)
     |          Linear(in_features=2, out_features=2, bias=True)
     |          >>> linear.weight
     |          Parameter containing:
     |          tensor([[ 0.1914, -0.3420],
     |                  [-0.5112, -0.2324]], dtype=torch.float16, device='cuda:1')
     |          >>> cpu = torch.device("cpu")
     |          >>> linear.to(cpu)
     |          Linear(in_features=2, out_features=2, bias=True)
     |          >>> linear.weight
     |          Parameter containing:
     |          tensor([[ 0.1914, -0.3420],
     |                  [-0.5112, -0.2324]], dtype=torch.float16)
     |  
     |  train(self, mode=True)
     |      Sets the module in training mode.
     |      
     |      This has any effect only on certain modules. See documentations of
     |      particular modules for details of their behaviors in training/evaluation
     |      mode, if they are affected, e.g. :class:`Dropout`, :class:`BatchNorm`,
     |      etc.
     |      
     |      Args:
     |          mode (bool): whether to set training mode (``True``) or evaluation
     |                       mode (``False``). Default: ``True``.
     |      
     |      Returns:
     |          Module: self
     |  
     |  type(self, dst_type)
     |      Casts all parameters and buffers to :attr:`dst_type`.
     |      
     |      Arguments:
     |          dst_type (type or string): the desired type
     |      
     |      Returns:
     |          Module: self
     |  
     |  zero_grad(self)
     |      Sets gradients of all model parameters to zero.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from torch.nn.modules.module.Module:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from torch.nn.modules.module.Module:
     |  
     |  dump_patches = False
    
    class BDHW_LSTM_to_BDH(torch.nn.modules.module.Module)
     |  BDHW_LSTM_to_BDH(ninput=None, noutput=None)
     |  
     |  An LSTM that summarizes 2D down to 1D along the last dim.
     |  
     |  Method resolution order:
     |      BDHW_LSTM_to_BDH
     |      torch.nn.modules.module.Module
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, ninput=None, noutput=None)
     |      Initializes internal Module state, shared by both nn.Module and ScriptModule.
     |  
     |  forward(self, img, volatile=False)
     |      Defines the computation performed at every call.
     |      
     |      Should be overridden by all subclasses.
     |      
     |      .. note::
     |          Although the recipe for forward pass needs to be defined within
     |          this function, one should call the :class:`Module` instance afterwards
     |          instead of this since the former takes care of running the
     |          registered hooks while the latter silently ignores them.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from torch.nn.modules.module.Module:
     |  
     |  __call__(self, *input, **kwargs)
     |      Call self as a function.
     |  
     |  __delattr__(self, name)
     |      Implement delattr(self, name).
     |  
     |  __dir__(self)
     |      Default dir() implementation.
     |  
     |  __getattr__(self, name)
     |  
     |  __repr__(self)
     |      Return repr(self).
     |  
     |  __setattr__(self, name, value)
     |      Implement setattr(self, name, value).
     |  
     |  __setstate__(self, state)
     |  
     |  add_module(self, name, module)
     |      Adds a child module to the current module.
     |      
     |      The module can be accessed as an attribute using the given name.
     |      
     |      Args:
     |          name (string): name of the child module. The child module can be
     |              accessed from this module using the given name
     |          module (Module): child module to be added to the module.
     |  
     |  apply(self, fn)
     |      Applies ``fn`` recursively to every submodule (as returned by ``.children()``)
     |      as well as self. Typical use includes initializing the parameters of a model
     |      (see also :ref:`nn-init-doc`).
     |      
     |      Args:
     |          fn (:class:`Module` -> None): function to be applied to each submodule
     |      
     |      Returns:
     |          Module: self
     |      
     |      Example::
     |      
     |          >>> def init_weights(m):
     |          >>>     print(m)
     |          >>>     if type(m) == nn.Linear:
     |          >>>         m.weight.data.fill_(1.0)
     |          >>>         print(m.weight)
     |          >>> net = nn.Sequential(nn.Linear(2, 2), nn.Linear(2, 2))
     |          >>> net.apply(init_weights)
     |          Linear(in_features=2, out_features=2, bias=True)
     |          Parameter containing:
     |          tensor([[ 1.,  1.],
     |                  [ 1.,  1.]])
     |          Linear(in_features=2, out_features=2, bias=True)
     |          Parameter containing:
     |          tensor([[ 1.,  1.],
     |                  [ 1.,  1.]])
     |          Sequential(
     |            (0): Linear(in_features=2, out_features=2, bias=True)
     |            (1): Linear(in_features=2, out_features=2, bias=True)
     |          )
     |          Sequential(
     |            (0): Linear(in_features=2, out_features=2, bias=True)
     |            (1): Linear(in_features=2, out_features=2, bias=True)
     |          )
     |  
     |  buffers(self, recurse=True)
     |      Returns an iterator over module buffers.
     |      
     |      Args:
     |          recurse (bool): if True, then yields buffers of this module
     |              and all submodules. Otherwise, yields only buffers that
     |              are direct members of this module.
     |      
     |      Yields:
     |          torch.Tensor: module buffer
     |      
     |      Example::
     |      
     |          >>> for buf in model.buffers():
     |          >>>     print(type(buf.data), buf.size())
     |          <class 'torch.FloatTensor'> (20L,)
     |          <class 'torch.FloatTensor'> (20L, 1L, 5L, 5L)
     |  
     |  children(self)
     |      Returns an iterator over immediate children modules.
     |      
     |      Yields:
     |          Module: a child module
     |  
     |  cpu(self)
     |      Moves all model parameters and buffers to the CPU.
     |      
     |      Returns:
     |          Module: self
     |  
     |  cuda(self, device=None)
     |      Moves all model parameters and buffers to the GPU.
     |      
     |      This also makes associated parameters and buffers different objects. So
     |      it should be called before constructing optimizer if the module will
     |      live on GPU while being optimized.
     |      
     |      Arguments:
     |          device (int, optional): if specified, all parameters will be
     |              copied to that device
     |      
     |      Returns:
     |          Module: self
     |  
     |  double(self)
     |      Casts all floating point parameters and buffers to ``double`` datatype.
     |      
     |      Returns:
     |          Module: self
     |  
     |  eval(self)
     |      Sets the module in evaluation mode.
     |      
     |      This has any effect only on certain modules. See documentations of
     |      particular modules for details of their behaviors in training/evaluation
     |      mode, if they are affected, e.g. :class:`Dropout`, :class:`BatchNorm`,
     |      etc.
     |      
     |      This is equivalent with :meth:`self.train(False) <torch.nn.Module.train>`.
     |      
     |      Returns:
     |          Module: self
     |  
     |  extra_repr(self)
     |      Set the extra representation of the module
     |      
     |      To print customized extra information, you should reimplement
     |      this method in your own modules. Both single-line and multi-line
     |      strings are acceptable.
     |  
     |  float(self)
     |      Casts all floating point parameters and buffers to float datatype.
     |      
     |      Returns:
     |          Module: self
     |  
     |  half(self)
     |      Casts all floating point parameters and buffers to ``half`` datatype.
     |      
     |      Returns:
     |          Module: self
     |  
     |  load_state_dict(self, state_dict, strict=True)
     |      Copies parameters and buffers from :attr:`state_dict` into
     |      this module and its descendants. If :attr:`strict` is ``True``, then
     |      the keys of :attr:`state_dict` must exactly match the keys returned
     |      by this module's :meth:`~torch.nn.Module.state_dict` function.
     |      
     |      Arguments:
     |          state_dict (dict): a dict containing parameters and
     |              persistent buffers.
     |          strict (bool, optional): whether to strictly enforce that the keys
     |              in :attr:`state_dict` match the keys returned by this module's
     |              :meth:`~torch.nn.Module.state_dict` function. Default: ``True``
     |      
     |      Returns:
     |          ``NamedTuple`` with ``missing_keys`` and ``unexpected_keys`` fields:
     |              * **missing_keys** is a list of str containing the missing keys
     |              * **unexpected_keys** is a list of str containing the unexpected keys
     |  
     |  modules(self)
     |      Returns an iterator over all modules in the network.
     |      
     |      Yields:
     |          Module: a module in the network
     |      
     |      Note:
     |          Duplicate modules are returned only once. In the following
     |          example, ``l`` will be returned only once.
     |      
     |      Example::
     |      
     |          >>> l = nn.Linear(2, 2)
     |          >>> net = nn.Sequential(l, l)
     |          >>> for idx, m in enumerate(net.modules()):
     |                  print(idx, '->', m)
     |      
     |          0 -> Sequential(
     |            (0): Linear(in_features=2, out_features=2, bias=True)
     |            (1): Linear(in_features=2, out_features=2, bias=True)
     |          )
     |          1 -> Linear(in_features=2, out_features=2, bias=True)
     |  
     |  named_buffers(self, prefix='', recurse=True)
     |      Returns an iterator over module buffers, yielding both the
     |      name of the buffer as well as the buffer itself.
     |      
     |      Args:
     |          prefix (str): prefix to prepend to all buffer names.
     |          recurse (bool): if True, then yields buffers of this module
     |              and all submodules. Otherwise, yields only buffers that
     |              are direct members of this module.
     |      
     |      Yields:
     |          (string, torch.Tensor): Tuple containing the name and buffer
     |      
     |      Example::
     |      
     |          >>> for name, buf in self.named_buffers():
     |          >>>    if name in ['running_var']:
     |          >>>        print(buf.size())
     |  
     |  named_children(self)
     |      Returns an iterator over immediate children modules, yielding both
     |      the name of the module as well as the module itself.
     |      
     |      Yields:
     |          (string, Module): Tuple containing a name and child module
     |      
     |      Example::
     |      
     |          >>> for name, module in model.named_children():
     |          >>>     if name in ['conv4', 'conv5']:
     |          >>>         print(module)
     |  
     |  named_modules(self, memo=None, prefix='')
     |      Returns an iterator over all modules in the network, yielding
     |      both the name of the module as well as the module itself.
     |      
     |      Yields:
     |          (string, Module): Tuple of name and module
     |      
     |      Note:
     |          Duplicate modules are returned only once. In the following
     |          example, ``l`` will be returned only once.
     |      
     |      Example::
     |      
     |          >>> l = nn.Linear(2, 2)
     |          >>> net = nn.Sequential(l, l)
     |          >>> for idx, m in enumerate(net.named_modules()):
     |                  print(idx, '->', m)
     |      
     |          0 -> ('', Sequential(
     |            (0): Linear(in_features=2, out_features=2, bias=True)
     |            (1): Linear(in_features=2, out_features=2, bias=True)
     |          ))
     |          1 -> ('0', Linear(in_features=2, out_features=2, bias=True))
     |  
     |  named_parameters(self, prefix='', recurse=True)
     |      Returns an iterator over module parameters, yielding both the
     |      name of the parameter as well as the parameter itself.
     |      
     |      Args:
     |          prefix (str): prefix to prepend to all parameter names.
     |          recurse (bool): if True, then yields parameters of this module
     |              and all submodules. Otherwise, yields only parameters that
     |              are direct members of this module.
     |      
     |      Yields:
     |          (string, Parameter): Tuple containing the name and parameter
     |      
     |      Example::
     |      
     |          >>> for name, param in self.named_parameters():
     |          >>>    if name in ['bias']:
     |          >>>        print(param.size())
     |  
     |  parameters(self, recurse=True)
     |      Returns an iterator over module parameters.
     |      
     |      This is typically passed to an optimizer.
     |      
     |      Args:
     |          recurse (bool): if True, then yields parameters of this module
     |              and all submodules. Otherwise, yields only parameters that
     |              are direct members of this module.
     |      
     |      Yields:
     |          Parameter: module parameter
     |      
     |      Example::
     |      
     |          >>> for param in model.parameters():
     |          >>>     print(type(param.data), param.size())
     |          <class 'torch.FloatTensor'> (20L,)
     |          <class 'torch.FloatTensor'> (20L, 1L, 5L, 5L)
     |  
     |  register_backward_hook(self, hook)
     |      Registers a backward hook on the module.
     |      
     |      The hook will be called every time the gradients with respect to module
     |      inputs are computed. The hook should have the following signature::
     |      
     |          hook(module, grad_input, grad_output) -> Tensor or None
     |      
     |      The :attr:`grad_input` and :attr:`grad_output` may be tuples if the
     |      module has multiple inputs or outputs. The hook should not modify its
     |      arguments, but it can optionally return a new gradient with respect to
     |      input that will be used in place of :attr:`grad_input` in subsequent
     |      computations.
     |      
     |      Returns:
     |          :class:`torch.utils.hooks.RemovableHandle`:
     |              a handle that can be used to remove the added hook by calling
     |              ``handle.remove()``
     |      
     |      .. warning ::
     |      
     |          The current implementation will not have the presented behavior
     |          for complex :class:`Module` that perform many operations.
     |          In some failure cases, :attr:`grad_input` and :attr:`grad_output` will only
     |          contain the gradients for a subset of the inputs and outputs.
     |          For such :class:`Module`, you should use :func:`torch.Tensor.register_hook`
     |          directly on a specific input or output to get the required gradients.
     |  
     |  register_buffer(self, name, tensor)
     |      Adds a persistent buffer to the module.
     |      
     |      This is typically used to register a buffer that should not to be
     |      considered a model parameter. For example, BatchNorm's ``running_mean``
     |      is not a parameter, but is part of the persistent state.
     |      
     |      Buffers can be accessed as attributes using given names.
     |      
     |      Args:
     |          name (string): name of the buffer. The buffer can be accessed
     |              from this module using the given name
     |          tensor (Tensor): buffer to be registered.
     |      
     |      Example::
     |      
     |          >>> self.register_buffer('running_mean', torch.zeros(num_features))
     |  
     |  register_forward_hook(self, hook)
     |      Registers a forward hook on the module.
     |      
     |      The hook will be called every time after :func:`forward` has computed an output.
     |      It should have the following signature::
     |      
     |          hook(module, input, output) -> None or modified output
     |      
     |      The hook can modify the output. It can modify the input inplace but
     |      it will not have effect on forward since this is called after
     |      :func:`forward` is called.
     |      
     |      Returns:
     |          :class:`torch.utils.hooks.RemovableHandle`:
     |              a handle that can be used to remove the added hook by calling
     |              ``handle.remove()``
     |  
     |  register_forward_pre_hook(self, hook)
     |      Registers a forward pre-hook on the module.
     |      
     |      The hook will be called every time before :func:`forward` is invoked.
     |      It should have the following signature::
     |      
     |          hook(module, input) -> None or modified input
     |      
     |      The hook can modify the input. User can either return a tuple or a
     |      single modified value in the hook. We will wrap the value into a tuple
     |      if a single value is returned(unless that value is already a tuple).
     |      
     |      Returns:
     |          :class:`torch.utils.hooks.RemovableHandle`:
     |              a handle that can be used to remove the added hook by calling
     |              ``handle.remove()``
     |  
     |  register_parameter(self, name, param)
     |      Adds a parameter to the module.
     |      
     |      The parameter can be accessed as an attribute using given name.
     |      
     |      Args:
     |          name (string): name of the parameter. The parameter can be accessed
     |              from this module using the given name
     |          param (Parameter): parameter to be added to the module.
     |  
     |  requires_grad_(self, requires_grad=True)
     |      Change if autograd should record operations on parameters in this
     |      module.
     |      
     |      This method sets the parameters' :attr:`requires_grad` attributes
     |      in-place.
     |      
     |      This method is helpful for freezing part of the module for finetuning
     |      or training parts of a model individually (e.g., GAN training).
     |      
     |      Args:
     |          requires_grad (bool): whether autograd should record operations on
     |                                parameters in this module. Default: ``True``.
     |      
     |      Returns:
     |          Module: self
     |  
     |  share_memory(self)
     |  
     |  state_dict(self, destination=None, prefix='', keep_vars=False)
     |      Returns a dictionary containing a whole state of the module.
     |      
     |      Both parameters and persistent buffers (e.g. running averages) are
     |      included. Keys are corresponding parameter and buffer names.
     |      
     |      Returns:
     |          dict:
     |              a dictionary containing a whole state of the module
     |      
     |      Example::
     |      
     |          >>> module.state_dict().keys()
     |          ['bias', 'weight']
     |  
     |  to(self, *args, **kwargs)
     |      Moves and/or casts the parameters and buffers.
     |      
     |      This can be called as
     |      
     |      .. function:: to(device=None, dtype=None, non_blocking=False)
     |      
     |      .. function:: to(dtype, non_blocking=False)
     |      
     |      .. function:: to(tensor, non_blocking=False)
     |      
     |      Its signature is similar to :meth:`torch.Tensor.to`, but only accepts
     |      floating point desired :attr:`dtype` s. In addition, this method will
     |      only cast the floating point parameters and buffers to :attr:`dtype`
     |      (if given). The integral parameters and buffers will be moved
     |      :attr:`device`, if that is given, but with dtypes unchanged. When
     |      :attr:`non_blocking` is set, it tries to convert/move asynchronously
     |      with respect to the host if possible, e.g., moving CPU Tensors with
     |      pinned memory to CUDA devices.
     |      
     |      See below for examples.
     |      
     |      .. note::
     |          This method modifies the module in-place.
     |      
     |      Args:
     |          device (:class:`torch.device`): the desired device of the parameters
     |              and buffers in this module
     |          dtype (:class:`torch.dtype`): the desired floating point type of
     |              the floating point parameters and buffers in this module
     |          tensor (torch.Tensor): Tensor whose dtype and device are the desired
     |              dtype and device for all parameters and buffers in this module
     |      
     |      Returns:
     |          Module: self
     |      
     |      Example::
     |      
     |          >>> linear = nn.Linear(2, 2)
     |          >>> linear.weight
     |          Parameter containing:
     |          tensor([[ 0.1913, -0.3420],
     |                  [-0.5113, -0.2325]])
     |          >>> linear.to(torch.double)
     |          Linear(in_features=2, out_features=2, bias=True)
     |          >>> linear.weight
     |          Parameter containing:
     |          tensor([[ 0.1913, -0.3420],
     |                  [-0.5113, -0.2325]], dtype=torch.float64)
     |          >>> gpu1 = torch.device("cuda:1")
     |          >>> linear.to(gpu1, dtype=torch.half, non_blocking=True)
     |          Linear(in_features=2, out_features=2, bias=True)
     |          >>> linear.weight
     |          Parameter containing:
     |          tensor([[ 0.1914, -0.3420],
     |                  [-0.5112, -0.2324]], dtype=torch.float16, device='cuda:1')
     |          >>> cpu = torch.device("cpu")
     |          >>> linear.to(cpu)
     |          Linear(in_features=2, out_features=2, bias=True)
     |          >>> linear.weight
     |          Parameter containing:
     |          tensor([[ 0.1914, -0.3420],
     |                  [-0.5112, -0.2324]], dtype=torch.float16)
     |  
     |  train(self, mode=True)
     |      Sets the module in training mode.
     |      
     |      This has any effect only on certain modules. See documentations of
     |      particular modules for details of their behaviors in training/evaluation
     |      mode, if they are affected, e.g. :class:`Dropout`, :class:`BatchNorm`,
     |      etc.
     |      
     |      Args:
     |          mode (bool): whether to set training mode (``True``) or evaluation
     |                       mode (``False``). Default: ``True``.
     |      
     |      Returns:
     |          Module: self
     |  
     |  type(self, dst_type)
     |      Casts all parameters and buffers to :attr:`dst_type`.
     |      
     |      Arguments:
     |          dst_type (type or string): the desired type
     |      
     |      Returns:
     |          Module: self
     |  
     |  zero_grad(self)
     |      Sets gradients of all model parameters to zero.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from torch.nn.modules.module.Module:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from torch.nn.modules.module.Module:
     |  
     |  dump_patches = False
    
    class BDL_LSTM(torch.nn.modules.module.Module)
     |  BDL_LSTM(ninput=None, noutput=None, num_layers=1, bidirectional=False, batch_first=True)
     |  
     |  A simple bidirectional LSTM.
     |  
     |  All the sequence processing layers use BDL order by default to
     |  be consistent with 1D convolutions.
     |  
     |  Method resolution order:
     |      BDL_LSTM
     |      torch.nn.modules.module.Module
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, ninput=None, noutput=None, num_layers=1, bidirectional=False, batch_first=True)
     |      Initializes internal Module state, shared by both nn.Module and ScriptModule.
     |  
     |  forward(self, seq, volatile=False, verbose=False)
     |      Defines the computation performed at every call.
     |      
     |      Should be overridden by all subclasses.
     |      
     |      .. note::
     |          Although the recipe for forward pass needs to be defined within
     |          this function, one should call the :class:`Module` instance afterwards
     |          instead of this since the former takes care of running the
     |          registered hooks while the latter silently ignores them.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from torch.nn.modules.module.Module:
     |  
     |  __call__(self, *input, **kwargs)
     |      Call self as a function.
     |  
     |  __delattr__(self, name)
     |      Implement delattr(self, name).
     |  
     |  __dir__(self)
     |      Default dir() implementation.
     |  
     |  __getattr__(self, name)
     |  
     |  __repr__(self)
     |      Return repr(self).
     |  
     |  __setattr__(self, name, value)
     |      Implement setattr(self, name, value).
     |  
     |  __setstate__(self, state)
     |  
     |  add_module(self, name, module)
     |      Adds a child module to the current module.
     |      
     |      The module can be accessed as an attribute using the given name.
     |      
     |      Args:
     |          name (string): name of the child module. The child module can be
     |              accessed from this module using the given name
     |          module (Module): child module to be added to the module.
     |  
     |  apply(self, fn)
     |      Applies ``fn`` recursively to every submodule (as returned by ``.children()``)
     |      as well as self. Typical use includes initializing the parameters of a model
     |      (see also :ref:`nn-init-doc`).
     |      
     |      Args:
     |          fn (:class:`Module` -> None): function to be applied to each submodule
     |      
     |      Returns:
     |          Module: self
     |      
     |      Example::
     |      
     |          >>> def init_weights(m):
     |          >>>     print(m)
     |          >>>     if type(m) == nn.Linear:
     |          >>>         m.weight.data.fill_(1.0)
     |          >>>         print(m.weight)
     |          >>> net = nn.Sequential(nn.Linear(2, 2), nn.Linear(2, 2))
     |          >>> net.apply(init_weights)
     |          Linear(in_features=2, out_features=2, bias=True)
     |          Parameter containing:
     |          tensor([[ 1.,  1.],
     |                  [ 1.,  1.]])
     |          Linear(in_features=2, out_features=2, bias=True)
     |          Parameter containing:
     |          tensor([[ 1.,  1.],
     |                  [ 1.,  1.]])
     |          Sequential(
     |            (0): Linear(in_features=2, out_features=2, bias=True)
     |            (1): Linear(in_features=2, out_features=2, bias=True)
     |          )
     |          Sequential(
     |            (0): Linear(in_features=2, out_features=2, bias=True)
     |            (1): Linear(in_features=2, out_features=2, bias=True)
     |          )
     |  
     |  buffers(self, recurse=True)
     |      Returns an iterator over module buffers.
     |      
     |      Args:
     |          recurse (bool): if True, then yields buffers of this module
     |              and all submodules. Otherwise, yields only buffers that
     |              are direct members of this module.
     |      
     |      Yields:
     |          torch.Tensor: module buffer
     |      
     |      Example::
     |      
     |          >>> for buf in model.buffers():
     |          >>>     print(type(buf.data), buf.size())
     |          <class 'torch.FloatTensor'> (20L,)
     |          <class 'torch.FloatTensor'> (20L, 1L, 5L, 5L)
     |  
     |  children(self)
     |      Returns an iterator over immediate children modules.
     |      
     |      Yields:
     |          Module: a child module
     |  
     |  cpu(self)
     |      Moves all model parameters and buffers to the CPU.
     |      
     |      Returns:
     |          Module: self
     |  
     |  cuda(self, device=None)
     |      Moves all model parameters and buffers to the GPU.
     |      
     |      This also makes associated parameters and buffers different objects. So
     |      it should be called before constructing optimizer if the module will
     |      live on GPU while being optimized.
     |      
     |      Arguments:
     |          device (int, optional): if specified, all parameters will be
     |              copied to that device
     |      
     |      Returns:
     |          Module: self
     |  
     |  double(self)
     |      Casts all floating point parameters and buffers to ``double`` datatype.
     |      
     |      Returns:
     |          Module: self
     |  
     |  eval(self)
     |      Sets the module in evaluation mode.
     |      
     |      This has any effect only on certain modules. See documentations of
     |      particular modules for details of their behaviors in training/evaluation
     |      mode, if they are affected, e.g. :class:`Dropout`, :class:`BatchNorm`,
     |      etc.
     |      
     |      This is equivalent with :meth:`self.train(False) <torch.nn.Module.train>`.
     |      
     |      Returns:
     |          Module: self
     |  
     |  extra_repr(self)
     |      Set the extra representation of the module
     |      
     |      To print customized extra information, you should reimplement
     |      this method in your own modules. Both single-line and multi-line
     |      strings are acceptable.
     |  
     |  float(self)
     |      Casts all floating point parameters and buffers to float datatype.
     |      
     |      Returns:
     |          Module: self
     |  
     |  half(self)
     |      Casts all floating point parameters and buffers to ``half`` datatype.
     |      
     |      Returns:
     |          Module: self
     |  
     |  load_state_dict(self, state_dict, strict=True)
     |      Copies parameters and buffers from :attr:`state_dict` into
     |      this module and its descendants. If :attr:`strict` is ``True``, then
     |      the keys of :attr:`state_dict` must exactly match the keys returned
     |      by this module's :meth:`~torch.nn.Module.state_dict` function.
     |      
     |      Arguments:
     |          state_dict (dict): a dict containing parameters and
     |              persistent buffers.
     |          strict (bool, optional): whether to strictly enforce that the keys
     |              in :attr:`state_dict` match the keys returned by this module's
     |              :meth:`~torch.nn.Module.state_dict` function. Default: ``True``
     |      
     |      Returns:
     |          ``NamedTuple`` with ``missing_keys`` and ``unexpected_keys`` fields:
     |              * **missing_keys** is a list of str containing the missing keys
     |              * **unexpected_keys** is a list of str containing the unexpected keys
     |  
     |  modules(self)
     |      Returns an iterator over all modules in the network.
     |      
     |      Yields:
     |          Module: a module in the network
     |      
     |      Note:
     |          Duplicate modules are returned only once. In the following
     |          example, ``l`` will be returned only once.
     |      
     |      Example::
     |      
     |          >>> l = nn.Linear(2, 2)
     |          >>> net = nn.Sequential(l, l)
     |          >>> for idx, m in enumerate(net.modules()):
     |                  print(idx, '->', m)
     |      
     |          0 -> Sequential(
     |            (0): Linear(in_features=2, out_features=2, bias=True)
     |            (1): Linear(in_features=2, out_features=2, bias=True)
     |          )
     |          1 -> Linear(in_features=2, out_features=2, bias=True)
     |  
     |  named_buffers(self, prefix='', recurse=True)
     |      Returns an iterator over module buffers, yielding both the
     |      name of the buffer as well as the buffer itself.
     |      
     |      Args:
     |          prefix (str): prefix to prepend to all buffer names.
     |          recurse (bool): if True, then yields buffers of this module
     |              and all submodules. Otherwise, yields only buffers that
     |              are direct members of this module.
     |      
     |      Yields:
     |          (string, torch.Tensor): Tuple containing the name and buffer
     |      
     |      Example::
     |      
     |          >>> for name, buf in self.named_buffers():
     |          >>>    if name in ['running_var']:
     |          >>>        print(buf.size())
     |  
     |  named_children(self)
     |      Returns an iterator over immediate children modules, yielding both
     |      the name of the module as well as the module itself.
     |      
     |      Yields:
     |          (string, Module): Tuple containing a name and child module
     |      
     |      Example::
     |      
     |          >>> for name, module in model.named_children():
     |          >>>     if name in ['conv4', 'conv5']:
     |          >>>         print(module)
     |  
     |  named_modules(self, memo=None, prefix='')
     |      Returns an iterator over all modules in the network, yielding
     |      both the name of the module as well as the module itself.
     |      
     |      Yields:
     |          (string, Module): Tuple of name and module
     |      
     |      Note:
     |          Duplicate modules are returned only once. In the following
     |          example, ``l`` will be returned only once.
     |      
     |      Example::
     |      
     |          >>> l = nn.Linear(2, 2)
     |          >>> net = nn.Sequential(l, l)
     |          >>> for idx, m in enumerate(net.named_modules()):
     |                  print(idx, '->', m)
     |      
     |          0 -> ('', Sequential(
     |            (0): Linear(in_features=2, out_features=2, bias=True)
     |            (1): Linear(in_features=2, out_features=2, bias=True)
     |          ))
     |          1 -> ('0', Linear(in_features=2, out_features=2, bias=True))
     |  
     |  named_parameters(self, prefix='', recurse=True)
     |      Returns an iterator over module parameters, yielding both the
     |      name of the parameter as well as the parameter itself.
     |      
     |      Args:
     |          prefix (str): prefix to prepend to all parameter names.
     |          recurse (bool): if True, then yields parameters of this module
     |              and all submodules. Otherwise, yields only parameters that
     |              are direct members of this module.
     |      
     |      Yields:
     |          (string, Parameter): Tuple containing the name and parameter
     |      
     |      Example::
     |      
     |          >>> for name, param in self.named_parameters():
     |          >>>    if name in ['bias']:
     |          >>>        print(param.size())
     |  
     |  parameters(self, recurse=True)
     |      Returns an iterator over module parameters.
     |      
     |      This is typically passed to an optimizer.
     |      
     |      Args:
     |          recurse (bool): if True, then yields parameters of this module
     |              and all submodules. Otherwise, yields only parameters that
     |              are direct members of this module.
     |      
     |      Yields:
     |          Parameter: module parameter
     |      
     |      Example::
     |      
     |          >>> for param in model.parameters():
     |          >>>     print(type(param.data), param.size())
     |          <class 'torch.FloatTensor'> (20L,)
     |          <class 'torch.FloatTensor'> (20L, 1L, 5L, 5L)
     |  
     |  register_backward_hook(self, hook)
     |      Registers a backward hook on the module.
     |      
     |      The hook will be called every time the gradients with respect to module
     |      inputs are computed. The hook should have the following signature::
     |      
     |          hook(module, grad_input, grad_output) -> Tensor or None
     |      
     |      The :attr:`grad_input` and :attr:`grad_output` may be tuples if the
     |      module has multiple inputs or outputs. The hook should not modify its
     |      arguments, but it can optionally return a new gradient with respect to
     |      input that will be used in place of :attr:`grad_input` in subsequent
     |      computations.
     |      
     |      Returns:
     |          :class:`torch.utils.hooks.RemovableHandle`:
     |              a handle that can be used to remove the added hook by calling
     |              ``handle.remove()``
     |      
     |      .. warning ::
     |      
     |          The current implementation will not have the presented behavior
     |          for complex :class:`Module` that perform many operations.
     |          In some failure cases, :attr:`grad_input` and :attr:`grad_output` will only
     |          contain the gradients for a subset of the inputs and outputs.
     |          For such :class:`Module`, you should use :func:`torch.Tensor.register_hook`
     |          directly on a specific input or output to get the required gradients.
     |  
     |  register_buffer(self, name, tensor)
     |      Adds a persistent buffer to the module.
     |      
     |      This is typically used to register a buffer that should not to be
     |      considered a model parameter. For example, BatchNorm's ``running_mean``
     |      is not a parameter, but is part of the persistent state.
     |      
     |      Buffers can be accessed as attributes using given names.
     |      
     |      Args:
     |          name (string): name of the buffer. The buffer can be accessed
     |              from this module using the given name
     |          tensor (Tensor): buffer to be registered.
     |      
     |      Example::
     |      
     |          >>> self.register_buffer('running_mean', torch.zeros(num_features))
     |  
     |  register_forward_hook(self, hook)
     |      Registers a forward hook on the module.
     |      
     |      The hook will be called every time after :func:`forward` has computed an output.
     |      It should have the following signature::
     |      
     |          hook(module, input, output) -> None or modified output
     |      
     |      The hook can modify the output. It can modify the input inplace but
     |      it will not have effect on forward since this is called after
     |      :func:`forward` is called.
     |      
     |      Returns:
     |          :class:`torch.utils.hooks.RemovableHandle`:
     |              a handle that can be used to remove the added hook by calling
     |              ``handle.remove()``
     |  
     |  register_forward_pre_hook(self, hook)
     |      Registers a forward pre-hook on the module.
     |      
     |      The hook will be called every time before :func:`forward` is invoked.
     |      It should have the following signature::
     |      
     |          hook(module, input) -> None or modified input
     |      
     |      The hook can modify the input. User can either return a tuple or a
     |      single modified value in the hook. We will wrap the value into a tuple
     |      if a single value is returned(unless that value is already a tuple).
     |      
     |      Returns:
     |          :class:`torch.utils.hooks.RemovableHandle`:
     |              a handle that can be used to remove the added hook by calling
     |              ``handle.remove()``
     |  
     |  register_parameter(self, name, param)
     |      Adds a parameter to the module.
     |      
     |      The parameter can be accessed as an attribute using given name.
     |      
     |      Args:
     |          name (string): name of the parameter. The parameter can be accessed
     |              from this module using the given name
     |          param (Parameter): parameter to be added to the module.
     |  
     |  requires_grad_(self, requires_grad=True)
     |      Change if autograd should record operations on parameters in this
     |      module.
     |      
     |      This method sets the parameters' :attr:`requires_grad` attributes
     |      in-place.
     |      
     |      This method is helpful for freezing part of the module for finetuning
     |      or training parts of a model individually (e.g., GAN training).
     |      
     |      Args:
     |          requires_grad (bool): whether autograd should record operations on
     |                                parameters in this module. Default: ``True``.
     |      
     |      Returns:
     |          Module: self
     |  
     |  share_memory(self)
     |  
     |  state_dict(self, destination=None, prefix='', keep_vars=False)
     |      Returns a dictionary containing a whole state of the module.
     |      
     |      Both parameters and persistent buffers (e.g. running averages) are
     |      included. Keys are corresponding parameter and buffer names.
     |      
     |      Returns:
     |          dict:
     |              a dictionary containing a whole state of the module
     |      
     |      Example::
     |      
     |          >>> module.state_dict().keys()
     |          ['bias', 'weight']
     |  
     |  to(self, *args, **kwargs)
     |      Moves and/or casts the parameters and buffers.
     |      
     |      This can be called as
     |      
     |      .. function:: to(device=None, dtype=None, non_blocking=False)
     |      
     |      .. function:: to(dtype, non_blocking=False)
     |      
     |      .. function:: to(tensor, non_blocking=False)
     |      
     |      Its signature is similar to :meth:`torch.Tensor.to`, but only accepts
     |      floating point desired :attr:`dtype` s. In addition, this method will
     |      only cast the floating point parameters and buffers to :attr:`dtype`
     |      (if given). The integral parameters and buffers will be moved
     |      :attr:`device`, if that is given, but with dtypes unchanged. When
     |      :attr:`non_blocking` is set, it tries to convert/move asynchronously
     |      with respect to the host if possible, e.g., moving CPU Tensors with
     |      pinned memory to CUDA devices.
     |      
     |      See below for examples.
     |      
     |      .. note::
     |          This method modifies the module in-place.
     |      
     |      Args:
     |          device (:class:`torch.device`): the desired device of the parameters
     |              and buffers in this module
     |          dtype (:class:`torch.dtype`): the desired floating point type of
     |              the floating point parameters and buffers in this module
     |          tensor (torch.Tensor): Tensor whose dtype and device are the desired
     |              dtype and device for all parameters and buffers in this module
     |      
     |      Returns:
     |          Module: self
     |      
     |      Example::
     |      
     |          >>> linear = nn.Linear(2, 2)
     |          >>> linear.weight
     |          Parameter containing:
     |          tensor([[ 0.1913, -0.3420],
     |                  [-0.5113, -0.2325]])
     |          >>> linear.to(torch.double)
     |          Linear(in_features=2, out_features=2, bias=True)
     |          >>> linear.weight
     |          Parameter containing:
     |          tensor([[ 0.1913, -0.3420],
     |                  [-0.5113, -0.2325]], dtype=torch.float64)
     |          >>> gpu1 = torch.device("cuda:1")
     |          >>> linear.to(gpu1, dtype=torch.half, non_blocking=True)
     |          Linear(in_features=2, out_features=2, bias=True)
     |          >>> linear.weight
     |          Parameter containing:
     |          tensor([[ 0.1914, -0.3420],
     |                  [-0.5112, -0.2324]], dtype=torch.float16, device='cuda:1')
     |          >>> cpu = torch.device("cpu")
     |          >>> linear.to(cpu)
     |          Linear(in_features=2, out_features=2, bias=True)
     |          >>> linear.weight
     |          Parameter containing:
     |          tensor([[ 0.1914, -0.3420],
     |                  [-0.5112, -0.2324]], dtype=torch.float16)
     |  
     |  train(self, mode=True)
     |      Sets the module in training mode.
     |      
     |      This has any effect only on certain modules. See documentations of
     |      particular modules for details of their behaviors in training/evaluation
     |      mode, if they are affected, e.g. :class:`Dropout`, :class:`BatchNorm`,
     |      etc.
     |      
     |      Args:
     |          mode (bool): whether to set training mode (``True``) or evaluation
     |                       mode (``False``). Default: ``True``.
     |      
     |      Returns:
     |          Module: self
     |  
     |  type(self, dst_type)
     |      Casts all parameters and buffers to :attr:`dst_type`.
     |      
     |      Arguments:
     |          dst_type (type or string): the desired type
     |      
     |      Returns:
     |          Module: self
     |  
     |  zero_grad(self)
     |      Sets gradients of all model parameters to zero.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from torch.nn.modules.module.Module:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from torch.nn.modules.module.Module:
     |  
     |  dump_patches = False
    
    class CheckOrder(torch.nn.modules.module.Module)
     |  CheckOrder(order=None)
     |  
     |  Base class for all neural network modules.
     |  
     |  Your models should also subclass this class.
     |  
     |  Modules can also contain other Modules, allowing to nest them in
     |  a tree structure. You can assign the submodules as regular attributes::
     |  
     |      import torch.nn as nn
     |      import torch.nn.functional as F
     |  
     |      class Model(nn.Module):
     |          def __init__(self):
     |              super(Model, self).__init__()
     |              self.conv1 = nn.Conv2d(1, 20, 5)
     |              self.conv2 = nn.Conv2d(20, 20, 5)
     |  
     |          def forward(self, x):
     |              x = F.relu(self.conv1(x))
     |              return F.relu(self.conv2(x))
     |  
     |  Submodules assigned in this way will be registered, and will have their
     |  parameters converted too when you call :meth:`to`, etc.
     |  
     |  Method resolution order:
     |      CheckOrder
     |      torch.nn.modules.module.Module
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, order=None)
     |      Initializes internal Module state, shared by both nn.Module and ScriptModule.
     |  
     |  forward(self, x)
     |      Defines the computation performed at every call.
     |      
     |      Should be overridden by all subclasses.
     |      
     |      .. note::
     |          Although the recipe for forward pass needs to be defined within
     |          this function, one should call the :class:`Module` instance afterwards
     |          instead of this since the former takes care of running the
     |          registered hooks while the latter silently ignores them.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from torch.nn.modules.module.Module:
     |  
     |  __call__(self, *input, **kwargs)
     |      Call self as a function.
     |  
     |  __delattr__(self, name)
     |      Implement delattr(self, name).
     |  
     |  __dir__(self)
     |      Default dir() implementation.
     |  
     |  __getattr__(self, name)
     |  
     |  __repr__(self)
     |      Return repr(self).
     |  
     |  __setattr__(self, name, value)
     |      Implement setattr(self, name, value).
     |  
     |  __setstate__(self, state)
     |  
     |  add_module(self, name, module)
     |      Adds a child module to the current module.
     |      
     |      The module can be accessed as an attribute using the given name.
     |      
     |      Args:
     |          name (string): name of the child module. The child module can be
     |              accessed from this module using the given name
     |          module (Module): child module to be added to the module.
     |  
     |  apply(self, fn)
     |      Applies ``fn`` recursively to every submodule (as returned by ``.children()``)
     |      as well as self. Typical use includes initializing the parameters of a model
     |      (see also :ref:`nn-init-doc`).
     |      
     |      Args:
     |          fn (:class:`Module` -> None): function to be applied to each submodule
     |      
     |      Returns:
     |          Module: self
     |      
     |      Example::
     |      
     |          >>> def init_weights(m):
     |          >>>     print(m)
     |          >>>     if type(m) == nn.Linear:
     |          >>>         m.weight.data.fill_(1.0)
     |          >>>         print(m.weight)
     |          >>> net = nn.Sequential(nn.Linear(2, 2), nn.Linear(2, 2))
     |          >>> net.apply(init_weights)
     |          Linear(in_features=2, out_features=2, bias=True)
     |          Parameter containing:
     |          tensor([[ 1.,  1.],
     |                  [ 1.,  1.]])
     |          Linear(in_features=2, out_features=2, bias=True)
     |          Parameter containing:
     |          tensor([[ 1.,  1.],
     |                  [ 1.,  1.]])
     |          Sequential(
     |            (0): Linear(in_features=2, out_features=2, bias=True)
     |            (1): Linear(in_features=2, out_features=2, bias=True)
     |          )
     |          Sequential(
     |            (0): Linear(in_features=2, out_features=2, bias=True)
     |            (1): Linear(in_features=2, out_features=2, bias=True)
     |          )
     |  
     |  buffers(self, recurse=True)
     |      Returns an iterator over module buffers.
     |      
     |      Args:
     |          recurse (bool): if True, then yields buffers of this module
     |              and all submodules. Otherwise, yields only buffers that
     |              are direct members of this module.
     |      
     |      Yields:
     |          torch.Tensor: module buffer
     |      
     |      Example::
     |      
     |          >>> for buf in model.buffers():
     |          >>>     print(type(buf.data), buf.size())
     |          <class 'torch.FloatTensor'> (20L,)
     |          <class 'torch.FloatTensor'> (20L, 1L, 5L, 5L)
     |  
     |  children(self)
     |      Returns an iterator over immediate children modules.
     |      
     |      Yields:
     |          Module: a child module
     |  
     |  cpu(self)
     |      Moves all model parameters and buffers to the CPU.
     |      
     |      Returns:
     |          Module: self
     |  
     |  cuda(self, device=None)
     |      Moves all model parameters and buffers to the GPU.
     |      
     |      This also makes associated parameters and buffers different objects. So
     |      it should be called before constructing optimizer if the module will
     |      live on GPU while being optimized.
     |      
     |      Arguments:
     |          device (int, optional): if specified, all parameters will be
     |              copied to that device
     |      
     |      Returns:
     |          Module: self
     |  
     |  double(self)
     |      Casts all floating point parameters and buffers to ``double`` datatype.
     |      
     |      Returns:
     |          Module: self
     |  
     |  eval(self)
     |      Sets the module in evaluation mode.
     |      
     |      This has any effect only on certain modules. See documentations of
     |      particular modules for details of their behaviors in training/evaluation
     |      mode, if they are affected, e.g. :class:`Dropout`, :class:`BatchNorm`,
     |      etc.
     |      
     |      This is equivalent with :meth:`self.train(False) <torch.nn.Module.train>`.
     |      
     |      Returns:
     |          Module: self
     |  
     |  extra_repr(self)
     |      Set the extra representation of the module
     |      
     |      To print customized extra information, you should reimplement
     |      this method in your own modules. Both single-line and multi-line
     |      strings are acceptable.
     |  
     |  float(self)
     |      Casts all floating point parameters and buffers to float datatype.
     |      
     |      Returns:
     |          Module: self
     |  
     |  half(self)
     |      Casts all floating point parameters and buffers to ``half`` datatype.
     |      
     |      Returns:
     |          Module: self
     |  
     |  load_state_dict(self, state_dict, strict=True)
     |      Copies parameters and buffers from :attr:`state_dict` into
     |      this module and its descendants. If :attr:`strict` is ``True``, then
     |      the keys of :attr:`state_dict` must exactly match the keys returned
     |      by this module's :meth:`~torch.nn.Module.state_dict` function.
     |      
     |      Arguments:
     |          state_dict (dict): a dict containing parameters and
     |              persistent buffers.
     |          strict (bool, optional): whether to strictly enforce that the keys
     |              in :attr:`state_dict` match the keys returned by this module's
     |              :meth:`~torch.nn.Module.state_dict` function. Default: ``True``
     |      
     |      Returns:
     |          ``NamedTuple`` with ``missing_keys`` and ``unexpected_keys`` fields:
     |              * **missing_keys** is a list of str containing the missing keys
     |              * **unexpected_keys** is a list of str containing the unexpected keys
     |  
     |  modules(self)
     |      Returns an iterator over all modules in the network.
     |      
     |      Yields:
     |          Module: a module in the network
     |      
     |      Note:
     |          Duplicate modules are returned only once. In the following
     |          example, ``l`` will be returned only once.
     |      
     |      Example::
     |      
     |          >>> l = nn.Linear(2, 2)
     |          >>> net = nn.Sequential(l, l)
     |          >>> for idx, m in enumerate(net.modules()):
     |                  print(idx, '->', m)
     |      
     |          0 -> Sequential(
     |            (0): Linear(in_features=2, out_features=2, bias=True)
     |            (1): Linear(in_features=2, out_features=2, bias=True)
     |          )
     |          1 -> Linear(in_features=2, out_features=2, bias=True)
     |  
     |  named_buffers(self, prefix='', recurse=True)
     |      Returns an iterator over module buffers, yielding both the
     |      name of the buffer as well as the buffer itself.
     |      
     |      Args:
     |          prefix (str): prefix to prepend to all buffer names.
     |          recurse (bool): if True, then yields buffers of this module
     |              and all submodules. Otherwise, yields only buffers that
     |              are direct members of this module.
     |      
     |      Yields:
     |          (string, torch.Tensor): Tuple containing the name and buffer
     |      
     |      Example::
     |      
     |          >>> for name, buf in self.named_buffers():
     |          >>>    if name in ['running_var']:
     |          >>>        print(buf.size())
     |  
     |  named_children(self)
     |      Returns an iterator over immediate children modules, yielding both
     |      the name of the module as well as the module itself.
     |      
     |      Yields:
     |          (string, Module): Tuple containing a name and child module
     |      
     |      Example::
     |      
     |          >>> for name, module in model.named_children():
     |          >>>     if name in ['conv4', 'conv5']:
     |          >>>         print(module)
     |  
     |  named_modules(self, memo=None, prefix='')
     |      Returns an iterator over all modules in the network, yielding
     |      both the name of the module as well as the module itself.
     |      
     |      Yields:
     |          (string, Module): Tuple of name and module
     |      
     |      Note:
     |          Duplicate modules are returned only once. In the following
     |          example, ``l`` will be returned only once.
     |      
     |      Example::
     |      
     |          >>> l = nn.Linear(2, 2)
     |          >>> net = nn.Sequential(l, l)
     |          >>> for idx, m in enumerate(net.named_modules()):
     |                  print(idx, '->', m)
     |      
     |          0 -> ('', Sequential(
     |            (0): Linear(in_features=2, out_features=2, bias=True)
     |            (1): Linear(in_features=2, out_features=2, bias=True)
     |          ))
     |          1 -> ('0', Linear(in_features=2, out_features=2, bias=True))
     |  
     |  named_parameters(self, prefix='', recurse=True)
     |      Returns an iterator over module parameters, yielding both the
     |      name of the parameter as well as the parameter itself.
     |      
     |      Args:
     |          prefix (str): prefix to prepend to all parameter names.
     |          recurse (bool): if True, then yields parameters of this module
     |              and all submodules. Otherwise, yields only parameters that
     |              are direct members of this module.
     |      
     |      Yields:
     |          (string, Parameter): Tuple containing the name and parameter
     |      
     |      Example::
     |      
     |          >>> for name, param in self.named_parameters():
     |          >>>    if name in ['bias']:
     |          >>>        print(param.size())
     |  
     |  parameters(self, recurse=True)
     |      Returns an iterator over module parameters.
     |      
     |      This is typically passed to an optimizer.
     |      
     |      Args:
     |          recurse (bool): if True, then yields parameters of this module
     |              and all submodules. Otherwise, yields only parameters that
     |              are direct members of this module.
     |      
     |      Yields:
     |          Parameter: module parameter
     |      
     |      Example::
     |      
     |          >>> for param in model.parameters():
     |          >>>     print(type(param.data), param.size())
     |          <class 'torch.FloatTensor'> (20L,)
     |          <class 'torch.FloatTensor'> (20L, 1L, 5L, 5L)
     |  
     |  register_backward_hook(self, hook)
     |      Registers a backward hook on the module.
     |      
     |      The hook will be called every time the gradients with respect to module
     |      inputs are computed. The hook should have the following signature::
     |      
     |          hook(module, grad_input, grad_output) -> Tensor or None
     |      
     |      The :attr:`grad_input` and :attr:`grad_output` may be tuples if the
     |      module has multiple inputs or outputs. The hook should not modify its
     |      arguments, but it can optionally return a new gradient with respect to
     |      input that will be used in place of :attr:`grad_input` in subsequent
     |      computations.
     |      
     |      Returns:
     |          :class:`torch.utils.hooks.RemovableHandle`:
     |              a handle that can be used to remove the added hook by calling
     |              ``handle.remove()``
     |      
     |      .. warning ::
     |      
     |          The current implementation will not have the presented behavior
     |          for complex :class:`Module` that perform many operations.
     |          In some failure cases, :attr:`grad_input` and :attr:`grad_output` will only
     |          contain the gradients for a subset of the inputs and outputs.
     |          For such :class:`Module`, you should use :func:`torch.Tensor.register_hook`
     |          directly on a specific input or output to get the required gradients.
     |  
     |  register_buffer(self, name, tensor)
     |      Adds a persistent buffer to the module.
     |      
     |      This is typically used to register a buffer that should not to be
     |      considered a model parameter. For example, BatchNorm's ``running_mean``
     |      is not a parameter, but is part of the persistent state.
     |      
     |      Buffers can be accessed as attributes using given names.
     |      
     |      Args:
     |          name (string): name of the buffer. The buffer can be accessed
     |              from this module using the given name
     |          tensor (Tensor): buffer to be registered.
     |      
     |      Example::
     |      
     |          >>> self.register_buffer('running_mean', torch.zeros(num_features))
     |  
     |  register_forward_hook(self, hook)
     |      Registers a forward hook on the module.
     |      
     |      The hook will be called every time after :func:`forward` has computed an output.
     |      It should have the following signature::
     |      
     |          hook(module, input, output) -> None or modified output
     |      
     |      The hook can modify the output. It can modify the input inplace but
     |      it will not have effect on forward since this is called after
     |      :func:`forward` is called.
     |      
     |      Returns:
     |          :class:`torch.utils.hooks.RemovableHandle`:
     |              a handle that can be used to remove the added hook by calling
     |              ``handle.remove()``
     |  
     |  register_forward_pre_hook(self, hook)
     |      Registers a forward pre-hook on the module.
     |      
     |      The hook will be called every time before :func:`forward` is invoked.
     |      It should have the following signature::
     |      
     |          hook(module, input) -> None or modified input
     |      
     |      The hook can modify the input. User can either return a tuple or a
     |      single modified value in the hook. We will wrap the value into a tuple
     |      if a single value is returned(unless that value is already a tuple).
     |      
     |      Returns:
     |          :class:`torch.utils.hooks.RemovableHandle`:
     |              a handle that can be used to remove the added hook by calling
     |              ``handle.remove()``
     |  
     |  register_parameter(self, name, param)
     |      Adds a parameter to the module.
     |      
     |      The parameter can be accessed as an attribute using given name.
     |      
     |      Args:
     |          name (string): name of the parameter. The parameter can be accessed
     |              from this module using the given name
     |          param (Parameter): parameter to be added to the module.
     |  
     |  requires_grad_(self, requires_grad=True)
     |      Change if autograd should record operations on parameters in this
     |      module.
     |      
     |      This method sets the parameters' :attr:`requires_grad` attributes
     |      in-place.
     |      
     |      This method is helpful for freezing part of the module for finetuning
     |      or training parts of a model individually (e.g., GAN training).
     |      
     |      Args:
     |          requires_grad (bool): whether autograd should record operations on
     |                                parameters in this module. Default: ``True``.
     |      
     |      Returns:
     |          Module: self
     |  
     |  share_memory(self)
     |  
     |  state_dict(self, destination=None, prefix='', keep_vars=False)
     |      Returns a dictionary containing a whole state of the module.
     |      
     |      Both parameters and persistent buffers (e.g. running averages) are
     |      included. Keys are corresponding parameter and buffer names.
     |      
     |      Returns:
     |          dict:
     |              a dictionary containing a whole state of the module
     |      
     |      Example::
     |      
     |          >>> module.state_dict().keys()
     |          ['bias', 'weight']
     |  
     |  to(self, *args, **kwargs)
     |      Moves and/or casts the parameters and buffers.
     |      
     |      This can be called as
     |      
     |      .. function:: to(device=None, dtype=None, non_blocking=False)
     |      
     |      .. function:: to(dtype, non_blocking=False)
     |      
     |      .. function:: to(tensor, non_blocking=False)
     |      
     |      Its signature is similar to :meth:`torch.Tensor.to`, but only accepts
     |      floating point desired :attr:`dtype` s. In addition, this method will
     |      only cast the floating point parameters and buffers to :attr:`dtype`
     |      (if given). The integral parameters and buffers will be moved
     |      :attr:`device`, if that is given, but with dtypes unchanged. When
     |      :attr:`non_blocking` is set, it tries to convert/move asynchronously
     |      with respect to the host if possible, e.g., moving CPU Tensors with
     |      pinned memory to CUDA devices.
     |      
     |      See below for examples.
     |      
     |      .. note::
     |          This method modifies the module in-place.
     |      
     |      Args:
     |          device (:class:`torch.device`): the desired device of the parameters
     |              and buffers in this module
     |          dtype (:class:`torch.dtype`): the desired floating point type of
     |              the floating point parameters and buffers in this module
     |          tensor (torch.Tensor): Tensor whose dtype and device are the desired
     |              dtype and device for all parameters and buffers in this module
     |      
     |      Returns:
     |          Module: self
     |      
     |      Example::
     |      
     |          >>> linear = nn.Linear(2, 2)
     |          >>> linear.weight
     |          Parameter containing:
     |          tensor([[ 0.1913, -0.3420],
     |                  [-0.5113, -0.2325]])
     |          >>> linear.to(torch.double)
     |          Linear(in_features=2, out_features=2, bias=True)
     |          >>> linear.weight
     |          Parameter containing:
     |          tensor([[ 0.1913, -0.3420],
     |                  [-0.5113, -0.2325]], dtype=torch.float64)
     |          >>> gpu1 = torch.device("cuda:1")
     |          >>> linear.to(gpu1, dtype=torch.half, non_blocking=True)
     |          Linear(in_features=2, out_features=2, bias=True)
     |          >>> linear.weight
     |          Parameter containing:
     |          tensor([[ 0.1914, -0.3420],
     |                  [-0.5112, -0.2324]], dtype=torch.float16, device='cuda:1')
     |          >>> cpu = torch.device("cpu")
     |          >>> linear.to(cpu)
     |          Linear(in_features=2, out_features=2, bias=True)
     |          >>> linear.weight
     |          Parameter containing:
     |          tensor([[ 0.1914, -0.3420],
     |                  [-0.5112, -0.2324]], dtype=torch.float16)
     |  
     |  train(self, mode=True)
     |      Sets the module in training mode.
     |      
     |      This has any effect only on certain modules. See documentations of
     |      particular modules for details of their behaviors in training/evaluation
     |      mode, if they are affected, e.g. :class:`Dropout`, :class:`BatchNorm`,
     |      etc.
     |      
     |      Args:
     |          mode (bool): whether to set training mode (``True``) or evaluation
     |                       mode (``False``). Default: ``True``.
     |      
     |      Returns:
     |          Module: self
     |  
     |  type(self, dst_type)
     |      Casts all parameters and buffers to :attr:`dst_type`.
     |      
     |      Arguments:
     |          dst_type (type or string): the desired type
     |      
     |      Returns:
     |          Module: self
     |  
     |  zero_grad(self)
     |      Sets gradients of all model parameters to zero.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from torch.nn.modules.module.Module:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from torch.nn.modules.module.Module:
     |  
     |  dump_patches = False
    
    class CheckRange(torch.nn.modules.module.Module)
     |  CheckRange(lo=-100000.0, hi=100000.0, name='')
     |  
     |  Check that values are within the given range.
     |  
     |  Method resolution order:
     |      CheckRange
     |      torch.nn.modules.module.Module
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, lo=-100000.0, hi=100000.0, name='')
     |      Initializes internal Module state, shared by both nn.Module and ScriptModule.
     |  
     |  __repr__(self)
     |      Return repr(self).
     |  
     |  forward(self, x)
     |      Defines the computation performed at every call.
     |      
     |      Should be overridden by all subclasses.
     |      
     |      .. note::
     |          Although the recipe for forward pass needs to be defined within
     |          this function, one should call the :class:`Module` instance afterwards
     |          instead of this since the former takes care of running the
     |          registered hooks while the latter silently ignores them.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from torch.nn.modules.module.Module:
     |  
     |  __call__(self, *input, **kwargs)
     |      Call self as a function.
     |  
     |  __delattr__(self, name)
     |      Implement delattr(self, name).
     |  
     |  __dir__(self)
     |      Default dir() implementation.
     |  
     |  __getattr__(self, name)
     |  
     |  __setattr__(self, name, value)
     |      Implement setattr(self, name, value).
     |  
     |  __setstate__(self, state)
     |  
     |  add_module(self, name, module)
     |      Adds a child module to the current module.
     |      
     |      The module can be accessed as an attribute using the given name.
     |      
     |      Args:
     |          name (string): name of the child module. The child module can be
     |              accessed from this module using the given name
     |          module (Module): child module to be added to the module.
     |  
     |  apply(self, fn)
     |      Applies ``fn`` recursively to every submodule (as returned by ``.children()``)
     |      as well as self. Typical use includes initializing the parameters of a model
     |      (see also :ref:`nn-init-doc`).
     |      
     |      Args:
     |          fn (:class:`Module` -> None): function to be applied to each submodule
     |      
     |      Returns:
     |          Module: self
     |      
     |      Example::
     |      
     |          >>> def init_weights(m):
     |          >>>     print(m)
     |          >>>     if type(m) == nn.Linear:
     |          >>>         m.weight.data.fill_(1.0)
     |          >>>         print(m.weight)
     |          >>> net = nn.Sequential(nn.Linear(2, 2), nn.Linear(2, 2))
     |          >>> net.apply(init_weights)
     |          Linear(in_features=2, out_features=2, bias=True)
     |          Parameter containing:
     |          tensor([[ 1.,  1.],
     |                  [ 1.,  1.]])
     |          Linear(in_features=2, out_features=2, bias=True)
     |          Parameter containing:
     |          tensor([[ 1.,  1.],
     |                  [ 1.,  1.]])
     |          Sequential(
     |            (0): Linear(in_features=2, out_features=2, bias=True)
     |            (1): Linear(in_features=2, out_features=2, bias=True)
     |          )
     |          Sequential(
     |            (0): Linear(in_features=2, out_features=2, bias=True)
     |            (1): Linear(in_features=2, out_features=2, bias=True)
     |          )
     |  
     |  buffers(self, recurse=True)
     |      Returns an iterator over module buffers.
     |      
     |      Args:
     |          recurse (bool): if True, then yields buffers of this module
     |              and all submodules. Otherwise, yields only buffers that
     |              are direct members of this module.
     |      
     |      Yields:
     |          torch.Tensor: module buffer
     |      
     |      Example::
     |      
     |          >>> for buf in model.buffers():
     |          >>>     print(type(buf.data), buf.size())
     |          <class 'torch.FloatTensor'> (20L,)
     |          <class 'torch.FloatTensor'> (20L, 1L, 5L, 5L)
     |  
     |  children(self)
     |      Returns an iterator over immediate children modules.
     |      
     |      Yields:
     |          Module: a child module
     |  
     |  cpu(self)
     |      Moves all model parameters and buffers to the CPU.
     |      
     |      Returns:
     |          Module: self
     |  
     |  cuda(self, device=None)
     |      Moves all model parameters and buffers to the GPU.
     |      
     |      This also makes associated parameters and buffers different objects. So
     |      it should be called before constructing optimizer if the module will
     |      live on GPU while being optimized.
     |      
     |      Arguments:
     |          device (int, optional): if specified, all parameters will be
     |              copied to that device
     |      
     |      Returns:
     |          Module: self
     |  
     |  double(self)
     |      Casts all floating point parameters and buffers to ``double`` datatype.
     |      
     |      Returns:
     |          Module: self
     |  
     |  eval(self)
     |      Sets the module in evaluation mode.
     |      
     |      This has any effect only on certain modules. See documentations of
     |      particular modules for details of their behaviors in training/evaluation
     |      mode, if they are affected, e.g. :class:`Dropout`, :class:`BatchNorm`,
     |      etc.
     |      
     |      This is equivalent with :meth:`self.train(False) <torch.nn.Module.train>`.
     |      
     |      Returns:
     |          Module: self
     |  
     |  extra_repr(self)
     |      Set the extra representation of the module
     |      
     |      To print customized extra information, you should reimplement
     |      this method in your own modules. Both single-line and multi-line
     |      strings are acceptable.
     |  
     |  float(self)
     |      Casts all floating point parameters and buffers to float datatype.
     |      
     |      Returns:
     |          Module: self
     |  
     |  half(self)
     |      Casts all floating point parameters and buffers to ``half`` datatype.
     |      
     |      Returns:
     |          Module: self
     |  
     |  load_state_dict(self, state_dict, strict=True)
     |      Copies parameters and buffers from :attr:`state_dict` into
     |      this module and its descendants. If :attr:`strict` is ``True``, then
     |      the keys of :attr:`state_dict` must exactly match the keys returned
     |      by this module's :meth:`~torch.nn.Module.state_dict` function.
     |      
     |      Arguments:
     |          state_dict (dict): a dict containing parameters and
     |              persistent buffers.
     |          strict (bool, optional): whether to strictly enforce that the keys
     |              in :attr:`state_dict` match the keys returned by this module's
     |              :meth:`~torch.nn.Module.state_dict` function. Default: ``True``
     |      
     |      Returns:
     |          ``NamedTuple`` with ``missing_keys`` and ``unexpected_keys`` fields:
     |              * **missing_keys** is a list of str containing the missing keys
     |              * **unexpected_keys** is a list of str containing the unexpected keys
     |  
     |  modules(self)
     |      Returns an iterator over all modules in the network.
     |      
     |      Yields:
     |          Module: a module in the network
     |      
     |      Note:
     |          Duplicate modules are returned only once. In the following
     |          example, ``l`` will be returned only once.
     |      
     |      Example::
     |      
     |          >>> l = nn.Linear(2, 2)
     |          >>> net = nn.Sequential(l, l)
     |          >>> for idx, m in enumerate(net.modules()):
     |                  print(idx, '->', m)
     |      
     |          0 -> Sequential(
     |            (0): Linear(in_features=2, out_features=2, bias=True)
     |            (1): Linear(in_features=2, out_features=2, bias=True)
     |          )
     |          1 -> Linear(in_features=2, out_features=2, bias=True)
     |  
     |  named_buffers(self, prefix='', recurse=True)
     |      Returns an iterator over module buffers, yielding both the
     |      name of the buffer as well as the buffer itself.
     |      
     |      Args:
     |          prefix (str): prefix to prepend to all buffer names.
     |          recurse (bool): if True, then yields buffers of this module
     |              and all submodules. Otherwise, yields only buffers that
     |              are direct members of this module.
     |      
     |      Yields:
     |          (string, torch.Tensor): Tuple containing the name and buffer
     |      
     |      Example::
     |      
     |          >>> for name, buf in self.named_buffers():
     |          >>>    if name in ['running_var']:
     |          >>>        print(buf.size())
     |  
     |  named_children(self)
     |      Returns an iterator over immediate children modules, yielding both
     |      the name of the module as well as the module itself.
     |      
     |      Yields:
     |          (string, Module): Tuple containing a name and child module
     |      
     |      Example::
     |      
     |          >>> for name, module in model.named_children():
     |          >>>     if name in ['conv4', 'conv5']:
     |          >>>         print(module)
     |  
     |  named_modules(self, memo=None, prefix='')
     |      Returns an iterator over all modules in the network, yielding
     |      both the name of the module as well as the module itself.
     |      
     |      Yields:
     |          (string, Module): Tuple of name and module
     |      
     |      Note:
     |          Duplicate modules are returned only once. In the following
     |          example, ``l`` will be returned only once.
     |      
     |      Example::
     |      
     |          >>> l = nn.Linear(2, 2)
     |          >>> net = nn.Sequential(l, l)
     |          >>> for idx, m in enumerate(net.named_modules()):
     |                  print(idx, '->', m)
     |      
     |          0 -> ('', Sequential(
     |            (0): Linear(in_features=2, out_features=2, bias=True)
     |            (1): Linear(in_features=2, out_features=2, bias=True)
     |          ))
     |          1 -> ('0', Linear(in_features=2, out_features=2, bias=True))
     |  
     |  named_parameters(self, prefix='', recurse=True)
     |      Returns an iterator over module parameters, yielding both the
     |      name of the parameter as well as the parameter itself.
     |      
     |      Args:
     |          prefix (str): prefix to prepend to all parameter names.
     |          recurse (bool): if True, then yields parameters of this module
     |              and all submodules. Otherwise, yields only parameters that
     |              are direct members of this module.
     |      
     |      Yields:
     |          (string, Parameter): Tuple containing the name and parameter
     |      
     |      Example::
     |      
     |          >>> for name, param in self.named_parameters():
     |          >>>    if name in ['bias']:
     |          >>>        print(param.size())
     |  
     |  parameters(self, recurse=True)
     |      Returns an iterator over module parameters.
     |      
     |      This is typically passed to an optimizer.
     |      
     |      Args:
     |          recurse (bool): if True, then yields parameters of this module
     |              and all submodules. Otherwise, yields only parameters that
     |              are direct members of this module.
     |      
     |      Yields:
     |          Parameter: module parameter
     |      
     |      Example::
     |      
     |          >>> for param in model.parameters():
     |          >>>     print(type(param.data), param.size())
     |          <class 'torch.FloatTensor'> (20L,)
     |          <class 'torch.FloatTensor'> (20L, 1L, 5L, 5L)
     |  
     |  register_backward_hook(self, hook)
     |      Registers a backward hook on the module.
     |      
     |      The hook will be called every time the gradients with respect to module
     |      inputs are computed. The hook should have the following signature::
     |      
     |          hook(module, grad_input, grad_output) -> Tensor or None
     |      
     |      The :attr:`grad_input` and :attr:`grad_output` may be tuples if the
     |      module has multiple inputs or outputs. The hook should not modify its
     |      arguments, but it can optionally return a new gradient with respect to
     |      input that will be used in place of :attr:`grad_input` in subsequent
     |      computations.
     |      
     |      Returns:
     |          :class:`torch.utils.hooks.RemovableHandle`:
     |              a handle that can be used to remove the added hook by calling
     |              ``handle.remove()``
     |      
     |      .. warning ::
     |      
     |          The current implementation will not have the presented behavior
     |          for complex :class:`Module` that perform many operations.
     |          In some failure cases, :attr:`grad_input` and :attr:`grad_output` will only
     |          contain the gradients for a subset of the inputs and outputs.
     |          For such :class:`Module`, you should use :func:`torch.Tensor.register_hook`
     |          directly on a specific input or output to get the required gradients.
     |  
     |  register_buffer(self, name, tensor)
     |      Adds a persistent buffer to the module.
     |      
     |      This is typically used to register a buffer that should not to be
     |      considered a model parameter. For example, BatchNorm's ``running_mean``
     |      is not a parameter, but is part of the persistent state.
     |      
     |      Buffers can be accessed as attributes using given names.
     |      
     |      Args:
     |          name (string): name of the buffer. The buffer can be accessed
     |              from this module using the given name
     |          tensor (Tensor): buffer to be registered.
     |      
     |      Example::
     |      
     |          >>> self.register_buffer('running_mean', torch.zeros(num_features))
     |  
     |  register_forward_hook(self, hook)
     |      Registers a forward hook on the module.
     |      
     |      The hook will be called every time after :func:`forward` has computed an output.
     |      It should have the following signature::
     |      
     |          hook(module, input, output) -> None or modified output
     |      
     |      The hook can modify the output. It can modify the input inplace but
     |      it will not have effect on forward since this is called after
     |      :func:`forward` is called.
     |      
     |      Returns:
     |          :class:`torch.utils.hooks.RemovableHandle`:
     |              a handle that can be used to remove the added hook by calling
     |              ``handle.remove()``
     |  
     |  register_forward_pre_hook(self, hook)
     |      Registers a forward pre-hook on the module.
     |      
     |      The hook will be called every time before :func:`forward` is invoked.
     |      It should have the following signature::
     |      
     |          hook(module, input) -> None or modified input
     |      
     |      The hook can modify the input. User can either return a tuple or a
     |      single modified value in the hook. We will wrap the value into a tuple
     |      if a single value is returned(unless that value is already a tuple).
     |      
     |      Returns:
     |          :class:`torch.utils.hooks.RemovableHandle`:
     |              a handle that can be used to remove the added hook by calling
     |              ``handle.remove()``
     |  
     |  register_parameter(self, name, param)
     |      Adds a parameter to the module.
     |      
     |      The parameter can be accessed as an attribute using given name.
     |      
     |      Args:
     |          name (string): name of the parameter. The parameter can be accessed
     |              from this module using the given name
     |          param (Parameter): parameter to be added to the module.
     |  
     |  requires_grad_(self, requires_grad=True)
     |      Change if autograd should record operations on parameters in this
     |      module.
     |      
     |      This method sets the parameters' :attr:`requires_grad` attributes
     |      in-place.
     |      
     |      This method is helpful for freezing part of the module for finetuning
     |      or training parts of a model individually (e.g., GAN training).
     |      
     |      Args:
     |          requires_grad (bool): whether autograd should record operations on
     |                                parameters in this module. Default: ``True``.
     |      
     |      Returns:
     |          Module: self
     |  
     |  share_memory(self)
     |  
     |  state_dict(self, destination=None, prefix='', keep_vars=False)
     |      Returns a dictionary containing a whole state of the module.
     |      
     |      Both parameters and persistent buffers (e.g. running averages) are
     |      included. Keys are corresponding parameter and buffer names.
     |      
     |      Returns:
     |          dict:
     |              a dictionary containing a whole state of the module
     |      
     |      Example::
     |      
     |          >>> module.state_dict().keys()
     |          ['bias', 'weight']
     |  
     |  to(self, *args, **kwargs)
     |      Moves and/or casts the parameters and buffers.
     |      
     |      This can be called as
     |      
     |      .. function:: to(device=None, dtype=None, non_blocking=False)
     |      
     |      .. function:: to(dtype, non_blocking=False)
     |      
     |      .. function:: to(tensor, non_blocking=False)
     |      
     |      Its signature is similar to :meth:`torch.Tensor.to`, but only accepts
     |      floating point desired :attr:`dtype` s. In addition, this method will
     |      only cast the floating point parameters and buffers to :attr:`dtype`
     |      (if given). The integral parameters and buffers will be moved
     |      :attr:`device`, if that is given, but with dtypes unchanged. When
     |      :attr:`non_blocking` is set, it tries to convert/move asynchronously
     |      with respect to the host if possible, e.g., moving CPU Tensors with
     |      pinned memory to CUDA devices.
     |      
     |      See below for examples.
     |      
     |      .. note::
     |          This method modifies the module in-place.
     |      
     |      Args:
     |          device (:class:`torch.device`): the desired device of the parameters
     |              and buffers in this module
     |          dtype (:class:`torch.dtype`): the desired floating point type of
     |              the floating point parameters and buffers in this module
     |          tensor (torch.Tensor): Tensor whose dtype and device are the desired
     |              dtype and device for all parameters and buffers in this module
     |      
     |      Returns:
     |          Module: self
     |      
     |      Example::
     |      
     |          >>> linear = nn.Linear(2, 2)
     |          >>> linear.weight
     |          Parameter containing:
     |          tensor([[ 0.1913, -0.3420],
     |                  [-0.5113, -0.2325]])
     |          >>> linear.to(torch.double)
     |          Linear(in_features=2, out_features=2, bias=True)
     |          >>> linear.weight
     |          Parameter containing:
     |          tensor([[ 0.1913, -0.3420],
     |                  [-0.5113, -0.2325]], dtype=torch.float64)
     |          >>> gpu1 = torch.device("cuda:1")
     |          >>> linear.to(gpu1, dtype=torch.half, non_blocking=True)
     |          Linear(in_features=2, out_features=2, bias=True)
     |          >>> linear.weight
     |          Parameter containing:
     |          tensor([[ 0.1914, -0.3420],
     |                  [-0.5112, -0.2324]], dtype=torch.float16, device='cuda:1')
     |          >>> cpu = torch.device("cpu")
     |          >>> linear.to(cpu)
     |          Linear(in_features=2, out_features=2, bias=True)
     |          >>> linear.weight
     |          Parameter containing:
     |          tensor([[ 0.1914, -0.3420],
     |                  [-0.5112, -0.2324]], dtype=torch.float16)
     |  
     |  train(self, mode=True)
     |      Sets the module in training mode.
     |      
     |      This has any effect only on certain modules. See documentations of
     |      particular modules for details of their behaviors in training/evaluation
     |      mode, if they are affected, e.g. :class:`Dropout`, :class:`BatchNorm`,
     |      etc.
     |      
     |      Args:
     |          mode (bool): whether to set training mode (``True``) or evaluation
     |                       mode (``False``). Default: ``True``.
     |      
     |      Returns:
     |          Module: self
     |  
     |  type(self, dst_type)
     |      Casts all parameters and buffers to :attr:`dst_type`.
     |      
     |      Arguments:
     |          dst_type (type or string): the desired type
     |      
     |      Returns:
     |          Module: self
     |  
     |  zero_grad(self)
     |      Sets gradients of all model parameters to zero.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from torch.nn.modules.module.Module:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from torch.nn.modules.module.Module:
     |  
     |  dump_patches = False
    
    class CheckSizes(torch.nn.modules.module.Module)
     |  CheckSizes(*args, **kw)
     |  
     |  Check tensor sizes against the given sizes.
     |  
     |  Specify ranges as integers (exact), tuples (low, high), or -1 (no check).
     |  
     |  Method resolution order:
     |      CheckSizes
     |      torch.nn.modules.module.Module
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, *args, **kw)
     |      Initializes internal Module state, shared by both nn.Module and ScriptModule.
     |  
     |  __repr__(self)
     |      Return repr(self).
     |  
     |  forward(self, x)
     |      Defines the computation performed at every call.
     |      
     |      Should be overridden by all subclasses.
     |      
     |      .. note::
     |          Although the recipe for forward pass needs to be defined within
     |          this function, one should call the :class:`Module` instance afterwards
     |          instead of this since the former takes care of running the
     |          registered hooks while the latter silently ignores them.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from torch.nn.modules.module.Module:
     |  
     |  __call__(self, *input, **kwargs)
     |      Call self as a function.
     |  
     |  __delattr__(self, name)
     |      Implement delattr(self, name).
     |  
     |  __dir__(self)
     |      Default dir() implementation.
     |  
     |  __getattr__(self, name)
     |  
     |  __setattr__(self, name, value)
     |      Implement setattr(self, name, value).
     |  
     |  __setstate__(self, state)
     |  
     |  add_module(self, name, module)
     |      Adds a child module to the current module.
     |      
     |      The module can be accessed as an attribute using the given name.
     |      
     |      Args:
     |          name (string): name of the child module. The child module can be
     |              accessed from this module using the given name
     |          module (Module): child module to be added to the module.
     |  
     |  apply(self, fn)
     |      Applies ``fn`` recursively to every submodule (as returned by ``.children()``)
     |      as well as self. Typical use includes initializing the parameters of a model
     |      (see also :ref:`nn-init-doc`).
     |      
     |      Args:
     |          fn (:class:`Module` -> None): function to be applied to each submodule
     |      
     |      Returns:
     |          Module: self
     |      
     |      Example::
     |      
     |          >>> def init_weights(m):
     |          >>>     print(m)
     |          >>>     if type(m) == nn.Linear:
     |          >>>         m.weight.data.fill_(1.0)
     |          >>>         print(m.weight)
     |          >>> net = nn.Sequential(nn.Linear(2, 2), nn.Linear(2, 2))
     |          >>> net.apply(init_weights)
     |          Linear(in_features=2, out_features=2, bias=True)
     |          Parameter containing:
     |          tensor([[ 1.,  1.],
     |                  [ 1.,  1.]])
     |          Linear(in_features=2, out_features=2, bias=True)
     |          Parameter containing:
     |          tensor([[ 1.,  1.],
     |                  [ 1.,  1.]])
     |          Sequential(
     |            (0): Linear(in_features=2, out_features=2, bias=True)
     |            (1): Linear(in_features=2, out_features=2, bias=True)
     |          )
     |          Sequential(
     |            (0): Linear(in_features=2, out_features=2, bias=True)
     |            (1): Linear(in_features=2, out_features=2, bias=True)
     |          )
     |  
     |  buffers(self, recurse=True)
     |      Returns an iterator over module buffers.
     |      
     |      Args:
     |          recurse (bool): if True, then yields buffers of this module
     |              and all submodules. Otherwise, yields only buffers that
     |              are direct members of this module.
     |      
     |      Yields:
     |          torch.Tensor: module buffer
     |      
     |      Example::
     |      
     |          >>> for buf in model.buffers():
     |          >>>     print(type(buf.data), buf.size())
     |          <class 'torch.FloatTensor'> (20L,)
     |          <class 'torch.FloatTensor'> (20L, 1L, 5L, 5L)
     |  
     |  children(self)
     |      Returns an iterator over immediate children modules.
     |      
     |      Yields:
     |          Module: a child module
     |  
     |  cpu(self)
     |      Moves all model parameters and buffers to the CPU.
     |      
     |      Returns:
     |          Module: self
     |  
     |  cuda(self, device=None)
     |      Moves all model parameters and buffers to the GPU.
     |      
     |      This also makes associated parameters and buffers different objects. So
     |      it should be called before constructing optimizer if the module will
     |      live on GPU while being optimized.
     |      
     |      Arguments:
     |          device (int, optional): if specified, all parameters will be
     |              copied to that device
     |      
     |      Returns:
     |          Module: self
     |  
     |  double(self)
     |      Casts all floating point parameters and buffers to ``double`` datatype.
     |      
     |      Returns:
     |          Module: self
     |  
     |  eval(self)
     |      Sets the module in evaluation mode.
     |      
     |      This has any effect only on certain modules. See documentations of
     |      particular modules for details of their behaviors in training/evaluation
     |      mode, if they are affected, e.g. :class:`Dropout`, :class:`BatchNorm`,
     |      etc.
     |      
     |      This is equivalent with :meth:`self.train(False) <torch.nn.Module.train>`.
     |      
     |      Returns:
     |          Module: self
     |  
     |  extra_repr(self)
     |      Set the extra representation of the module
     |      
     |      To print customized extra information, you should reimplement
     |      this method in your own modules. Both single-line and multi-line
     |      strings are acceptable.
     |  
     |  float(self)
     |      Casts all floating point parameters and buffers to float datatype.
     |      
     |      Returns:
     |          Module: self
     |  
     |  half(self)
     |      Casts all floating point parameters and buffers to ``half`` datatype.
     |      
     |      Returns:
     |          Module: self
     |  
     |  load_state_dict(self, state_dict, strict=True)
     |      Copies parameters and buffers from :attr:`state_dict` into
     |      this module and its descendants. If :attr:`strict` is ``True``, then
     |      the keys of :attr:`state_dict` must exactly match the keys returned
     |      by this module's :meth:`~torch.nn.Module.state_dict` function.
     |      
     |      Arguments:
     |          state_dict (dict): a dict containing parameters and
     |              persistent buffers.
     |          strict (bool, optional): whether to strictly enforce that the keys
     |              in :attr:`state_dict` match the keys returned by this module's
     |              :meth:`~torch.nn.Module.state_dict` function. Default: ``True``
     |      
     |      Returns:
     |          ``NamedTuple`` with ``missing_keys`` and ``unexpected_keys`` fields:
     |              * **missing_keys** is a list of str containing the missing keys
     |              * **unexpected_keys** is a list of str containing the unexpected keys
     |  
     |  modules(self)
     |      Returns an iterator over all modules in the network.
     |      
     |      Yields:
     |          Module: a module in the network
     |      
     |      Note:
     |          Duplicate modules are returned only once. In the following
     |          example, ``l`` will be returned only once.
     |      
     |      Example::
     |      
     |          >>> l = nn.Linear(2, 2)
     |          >>> net = nn.Sequential(l, l)
     |          >>> for idx, m in enumerate(net.modules()):
     |                  print(idx, '->', m)
     |      
     |          0 -> Sequential(
     |            (0): Linear(in_features=2, out_features=2, bias=True)
     |            (1): Linear(in_features=2, out_features=2, bias=True)
     |          )
     |          1 -> Linear(in_features=2, out_features=2, bias=True)
     |  
     |  named_buffers(self, prefix='', recurse=True)
     |      Returns an iterator over module buffers, yielding both the
     |      name of the buffer as well as the buffer itself.
     |      
     |      Args:
     |          prefix (str): prefix to prepend to all buffer names.
     |          recurse (bool): if True, then yields buffers of this module
     |              and all submodules. Otherwise, yields only buffers that
     |              are direct members of this module.
     |      
     |      Yields:
     |          (string, torch.Tensor): Tuple containing the name and buffer
     |      
     |      Example::
     |      
     |          >>> for name, buf in self.named_buffers():
     |          >>>    if name in ['running_var']:
     |          >>>        print(buf.size())
     |  
     |  named_children(self)
     |      Returns an iterator over immediate children modules, yielding both
     |      the name of the module as well as the module itself.
     |      
     |      Yields:
     |          (string, Module): Tuple containing a name and child module
     |      
     |      Example::
     |      
     |          >>> for name, module in model.named_children():
     |          >>>     if name in ['conv4', 'conv5']:
     |          >>>         print(module)
     |  
     |  named_modules(self, memo=None, prefix='')
     |      Returns an iterator over all modules in the network, yielding
     |      both the name of the module as well as the module itself.
     |      
     |      Yields:
     |          (string, Module): Tuple of name and module
     |      
     |      Note:
     |          Duplicate modules are returned only once. In the following
     |          example, ``l`` will be returned only once.
     |      
     |      Example::
     |      
     |          >>> l = nn.Linear(2, 2)
     |          >>> net = nn.Sequential(l, l)
     |          >>> for idx, m in enumerate(net.named_modules()):
     |                  print(idx, '->', m)
     |      
     |          0 -> ('', Sequential(
     |            (0): Linear(in_features=2, out_features=2, bias=True)
     |            (1): Linear(in_features=2, out_features=2, bias=True)
     |          ))
     |          1 -> ('0', Linear(in_features=2, out_features=2, bias=True))
     |  
     |  named_parameters(self, prefix='', recurse=True)
     |      Returns an iterator over module parameters, yielding both the
     |      name of the parameter as well as the parameter itself.
     |      
     |      Args:
     |          prefix (str): prefix to prepend to all parameter names.
     |          recurse (bool): if True, then yields parameters of this module
     |              and all submodules. Otherwise, yields only parameters that
     |              are direct members of this module.
     |      
     |      Yields:
     |          (string, Parameter): Tuple containing the name and parameter
     |      
     |      Example::
     |      
     |          >>> for name, param in self.named_parameters():
     |          >>>    if name in ['bias']:
     |          >>>        print(param.size())
     |  
     |  parameters(self, recurse=True)
     |      Returns an iterator over module parameters.
     |      
     |      This is typically passed to an optimizer.
     |      
     |      Args:
     |          recurse (bool): if True, then yields parameters of this module
     |              and all submodules. Otherwise, yields only parameters that
     |              are direct members of this module.
     |      
     |      Yields:
     |          Parameter: module parameter
     |      
     |      Example::
     |      
     |          >>> for param in model.parameters():
     |          >>>     print(type(param.data), param.size())
     |          <class 'torch.FloatTensor'> (20L,)
     |          <class 'torch.FloatTensor'> (20L, 1L, 5L, 5L)
     |  
     |  register_backward_hook(self, hook)
     |      Registers a backward hook on the module.
     |      
     |      The hook will be called every time the gradients with respect to module
     |      inputs are computed. The hook should have the following signature::
     |      
     |          hook(module, grad_input, grad_output) -> Tensor or None
     |      
     |      The :attr:`grad_input` and :attr:`grad_output` may be tuples if the
     |      module has multiple inputs or outputs. The hook should not modify its
     |      arguments, but it can optionally return a new gradient with respect to
     |      input that will be used in place of :attr:`grad_input` in subsequent
     |      computations.
     |      
     |      Returns:
     |          :class:`torch.utils.hooks.RemovableHandle`:
     |              a handle that can be used to remove the added hook by calling
     |              ``handle.remove()``
     |      
     |      .. warning ::
     |      
     |          The current implementation will not have the presented behavior
     |          for complex :class:`Module` that perform many operations.
     |          In some failure cases, :attr:`grad_input` and :attr:`grad_output` will only
     |          contain the gradients for a subset of the inputs and outputs.
     |          For such :class:`Module`, you should use :func:`torch.Tensor.register_hook`
     |          directly on a specific input or output to get the required gradients.
     |  
     |  register_buffer(self, name, tensor)
     |      Adds a persistent buffer to the module.
     |      
     |      This is typically used to register a buffer that should not to be
     |      considered a model parameter. For example, BatchNorm's ``running_mean``
     |      is not a parameter, but is part of the persistent state.
     |      
     |      Buffers can be accessed as attributes using given names.
     |      
     |      Args:
     |          name (string): name of the buffer. The buffer can be accessed
     |              from this module using the given name
     |          tensor (Tensor): buffer to be registered.
     |      
     |      Example::
     |      
     |          >>> self.register_buffer('running_mean', torch.zeros(num_features))
     |  
     |  register_forward_hook(self, hook)
     |      Registers a forward hook on the module.
     |      
     |      The hook will be called every time after :func:`forward` has computed an output.
     |      It should have the following signature::
     |      
     |          hook(module, input, output) -> None or modified output
     |      
     |      The hook can modify the output. It can modify the input inplace but
     |      it will not have effect on forward since this is called after
     |      :func:`forward` is called.
     |      
     |      Returns:
     |          :class:`torch.utils.hooks.RemovableHandle`:
     |              a handle that can be used to remove the added hook by calling
     |              ``handle.remove()``
     |  
     |  register_forward_pre_hook(self, hook)
     |      Registers a forward pre-hook on the module.
     |      
     |      The hook will be called every time before :func:`forward` is invoked.
     |      It should have the following signature::
     |      
     |          hook(module, input) -> None or modified input
     |      
     |      The hook can modify the input. User can either return a tuple or a
     |      single modified value in the hook. We will wrap the value into a tuple
     |      if a single value is returned(unless that value is already a tuple).
     |      
     |      Returns:
     |          :class:`torch.utils.hooks.RemovableHandle`:
     |              a handle that can be used to remove the added hook by calling
     |              ``handle.remove()``
     |  
     |  register_parameter(self, name, param)
     |      Adds a parameter to the module.
     |      
     |      The parameter can be accessed as an attribute using given name.
     |      
     |      Args:
     |          name (string): name of the parameter. The parameter can be accessed
     |              from this module using the given name
     |          param (Parameter): parameter to be added to the module.
     |  
     |  requires_grad_(self, requires_grad=True)
     |      Change if autograd should record operations on parameters in this
     |      module.
     |      
     |      This method sets the parameters' :attr:`requires_grad` attributes
     |      in-place.
     |      
     |      This method is helpful for freezing part of the module for finetuning
     |      or training parts of a model individually (e.g., GAN training).
     |      
     |      Args:
     |          requires_grad (bool): whether autograd should record operations on
     |                                parameters in this module. Default: ``True``.
     |      
     |      Returns:
     |          Module: self
     |  
     |  share_memory(self)
     |  
     |  state_dict(self, destination=None, prefix='', keep_vars=False)
     |      Returns a dictionary containing a whole state of the module.
     |      
     |      Both parameters and persistent buffers (e.g. running averages) are
     |      included. Keys are corresponding parameter and buffer names.
     |      
     |      Returns:
     |          dict:
     |              a dictionary containing a whole state of the module
     |      
     |      Example::
     |      
     |          >>> module.state_dict().keys()
     |          ['bias', 'weight']
     |  
     |  to(self, *args, **kwargs)
     |      Moves and/or casts the parameters and buffers.
     |      
     |      This can be called as
     |      
     |      .. function:: to(device=None, dtype=None, non_blocking=False)
     |      
     |      .. function:: to(dtype, non_blocking=False)
     |      
     |      .. function:: to(tensor, non_blocking=False)
     |      
     |      Its signature is similar to :meth:`torch.Tensor.to`, but only accepts
     |      floating point desired :attr:`dtype` s. In addition, this method will
     |      only cast the floating point parameters and buffers to :attr:`dtype`
     |      (if given). The integral parameters and buffers will be moved
     |      :attr:`device`, if that is given, but with dtypes unchanged. When
     |      :attr:`non_blocking` is set, it tries to convert/move asynchronously
     |      with respect to the host if possible, e.g., moving CPU Tensors with
     |      pinned memory to CUDA devices.
     |      
     |      See below for examples.
     |      
     |      .. note::
     |          This method modifies the module in-place.
     |      
     |      Args:
     |          device (:class:`torch.device`): the desired device of the parameters
     |              and buffers in this module
     |          dtype (:class:`torch.dtype`): the desired floating point type of
     |              the floating point parameters and buffers in this module
     |          tensor (torch.Tensor): Tensor whose dtype and device are the desired
     |              dtype and device for all parameters and buffers in this module
     |      
     |      Returns:
     |          Module: self
     |      
     |      Example::
     |      
     |          >>> linear = nn.Linear(2, 2)
     |          >>> linear.weight
     |          Parameter containing:
     |          tensor([[ 0.1913, -0.3420],
     |                  [-0.5113, -0.2325]])
     |          >>> linear.to(torch.double)
     |          Linear(in_features=2, out_features=2, bias=True)
     |          >>> linear.weight
     |          Parameter containing:
     |          tensor([[ 0.1913, -0.3420],
     |                  [-0.5113, -0.2325]], dtype=torch.float64)
     |          >>> gpu1 = torch.device("cuda:1")
     |          >>> linear.to(gpu1, dtype=torch.half, non_blocking=True)
     |          Linear(in_features=2, out_features=2, bias=True)
     |          >>> linear.weight
     |          Parameter containing:
     |          tensor([[ 0.1914, -0.3420],
     |                  [-0.5112, -0.2324]], dtype=torch.float16, device='cuda:1')
     |          >>> cpu = torch.device("cpu")
     |          >>> linear.to(cpu)
     |          Linear(in_features=2, out_features=2, bias=True)
     |          >>> linear.weight
     |          Parameter containing:
     |          tensor([[ 0.1914, -0.3420],
     |                  [-0.5112, -0.2324]], dtype=torch.float16)
     |  
     |  train(self, mode=True)
     |      Sets the module in training mode.
     |      
     |      This has any effect only on certain modules. See documentations of
     |      particular modules for details of their behaviors in training/evaluation
     |      mode, if they are affected, e.g. :class:`Dropout`, :class:`BatchNorm`,
     |      etc.
     |      
     |      Args:
     |          mode (bool): whether to set training mode (``True``) or evaluation
     |                       mode (``False``). Default: ``True``.
     |      
     |      Returns:
     |          Module: self
     |  
     |  type(self, dst_type)
     |      Casts all parameters and buffers to :attr:`dst_type`.
     |      
     |      Arguments:
     |          dst_type (type or string): the desired type
     |      
     |      Returns:
     |          Module: self
     |  
     |  zero_grad(self)
     |      Sets gradients of all model parameters to zero.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from torch.nn.modules.module.Module:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from torch.nn.modules.module.Module:
     |  
     |  dump_patches = False
    
    class Device(torch.nn.modules.module.Module)
     |  Device(device='cuda')
     |  
     |  Always transfer tensor to device.
     |  
     |  Method resolution order:
     |      Device
     |      torch.nn.modules.module.Module
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, device='cuda')
     |      Initializes internal Module state, shared by both nn.Module and ScriptModule.
     |  
     |  __repr__(self)
     |      Return repr(self).
     |  
     |  forward(self, x)
     |      Defines the computation performed at every call.
     |      
     |      Should be overridden by all subclasses.
     |      
     |      .. note::
     |          Although the recipe for forward pass needs to be defined within
     |          this function, one should call the :class:`Module` instance afterwards
     |          instead of this since the former takes care of running the
     |          registered hooks while the latter silently ignores them.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from torch.nn.modules.module.Module:
     |  
     |  __call__(self, *input, **kwargs)
     |      Call self as a function.
     |  
     |  __delattr__(self, name)
     |      Implement delattr(self, name).
     |  
     |  __dir__(self)
     |      Default dir() implementation.
     |  
     |  __getattr__(self, name)
     |  
     |  __setattr__(self, name, value)
     |      Implement setattr(self, name, value).
     |  
     |  __setstate__(self, state)
     |  
     |  add_module(self, name, module)
     |      Adds a child module to the current module.
     |      
     |      The module can be accessed as an attribute using the given name.
     |      
     |      Args:
     |          name (string): name of the child module. The child module can be
     |              accessed from this module using the given name
     |          module (Module): child module to be added to the module.
     |  
     |  apply(self, fn)
     |      Applies ``fn`` recursively to every submodule (as returned by ``.children()``)
     |      as well as self. Typical use includes initializing the parameters of a model
     |      (see also :ref:`nn-init-doc`).
     |      
     |      Args:
     |          fn (:class:`Module` -> None): function to be applied to each submodule
     |      
     |      Returns:
     |          Module: self
     |      
     |      Example::
     |      
     |          >>> def init_weights(m):
     |          >>>     print(m)
     |          >>>     if type(m) == nn.Linear:
     |          >>>         m.weight.data.fill_(1.0)
     |          >>>         print(m.weight)
     |          >>> net = nn.Sequential(nn.Linear(2, 2), nn.Linear(2, 2))
     |          >>> net.apply(init_weights)
     |          Linear(in_features=2, out_features=2, bias=True)
     |          Parameter containing:
     |          tensor([[ 1.,  1.],
     |                  [ 1.,  1.]])
     |          Linear(in_features=2, out_features=2, bias=True)
     |          Parameter containing:
     |          tensor([[ 1.,  1.],
     |                  [ 1.,  1.]])
     |          Sequential(
     |            (0): Linear(in_features=2, out_features=2, bias=True)
     |            (1): Linear(in_features=2, out_features=2, bias=True)
     |          )
     |          Sequential(
     |            (0): Linear(in_features=2, out_features=2, bias=True)
     |            (1): Linear(in_features=2, out_features=2, bias=True)
     |          )
     |  
     |  buffers(self, recurse=True)
     |      Returns an iterator over module buffers.
     |      
     |      Args:
     |          recurse (bool): if True, then yields buffers of this module
     |              and all submodules. Otherwise, yields only buffers that
     |              are direct members of this module.
     |      
     |      Yields:
     |          torch.Tensor: module buffer
     |      
     |      Example::
     |      
     |          >>> for buf in model.buffers():
     |          >>>     print(type(buf.data), buf.size())
     |          <class 'torch.FloatTensor'> (20L,)
     |          <class 'torch.FloatTensor'> (20L, 1L, 5L, 5L)
     |  
     |  children(self)
     |      Returns an iterator over immediate children modules.
     |      
     |      Yields:
     |          Module: a child module
     |  
     |  cpu(self)
     |      Moves all model parameters and buffers to the CPU.
     |      
     |      Returns:
     |          Module: self
     |  
     |  cuda(self, device=None)
     |      Moves all model parameters and buffers to the GPU.
     |      
     |      This also makes associated parameters and buffers different objects. So
     |      it should be called before constructing optimizer if the module will
     |      live on GPU while being optimized.
     |      
     |      Arguments:
     |          device (int, optional): if specified, all parameters will be
     |              copied to that device
     |      
     |      Returns:
     |          Module: self
     |  
     |  double(self)
     |      Casts all floating point parameters and buffers to ``double`` datatype.
     |      
     |      Returns:
     |          Module: self
     |  
     |  eval(self)
     |      Sets the module in evaluation mode.
     |      
     |      This has any effect only on certain modules. See documentations of
     |      particular modules for details of their behaviors in training/evaluation
     |      mode, if they are affected, e.g. :class:`Dropout`, :class:`BatchNorm`,
     |      etc.
     |      
     |      This is equivalent with :meth:`self.train(False) <torch.nn.Module.train>`.
     |      
     |      Returns:
     |          Module: self
     |  
     |  extra_repr(self)
     |      Set the extra representation of the module
     |      
     |      To print customized extra information, you should reimplement
     |      this method in your own modules. Both single-line and multi-line
     |      strings are acceptable.
     |  
     |  float(self)
     |      Casts all floating point parameters and buffers to float datatype.
     |      
     |      Returns:
     |          Module: self
     |  
     |  half(self)
     |      Casts all floating point parameters and buffers to ``half`` datatype.
     |      
     |      Returns:
     |          Module: self
     |  
     |  load_state_dict(self, state_dict, strict=True)
     |      Copies parameters and buffers from :attr:`state_dict` into
     |      this module and its descendants. If :attr:`strict` is ``True``, then
     |      the keys of :attr:`state_dict` must exactly match the keys returned
     |      by this module's :meth:`~torch.nn.Module.state_dict` function.
     |      
     |      Arguments:
     |          state_dict (dict): a dict containing parameters and
     |              persistent buffers.
     |          strict (bool, optional): whether to strictly enforce that the keys
     |              in :attr:`state_dict` match the keys returned by this module's
     |              :meth:`~torch.nn.Module.state_dict` function. Default: ``True``
     |      
     |      Returns:
     |          ``NamedTuple`` with ``missing_keys`` and ``unexpected_keys`` fields:
     |              * **missing_keys** is a list of str containing the missing keys
     |              * **unexpected_keys** is a list of str containing the unexpected keys
     |  
     |  modules(self)
     |      Returns an iterator over all modules in the network.
     |      
     |      Yields:
     |          Module: a module in the network
     |      
     |      Note:
     |          Duplicate modules are returned only once. In the following
     |          example, ``l`` will be returned only once.
     |      
     |      Example::
     |      
     |          >>> l = nn.Linear(2, 2)
     |          >>> net = nn.Sequential(l, l)
     |          >>> for idx, m in enumerate(net.modules()):
     |                  print(idx, '->', m)
     |      
     |          0 -> Sequential(
     |            (0): Linear(in_features=2, out_features=2, bias=True)
     |            (1): Linear(in_features=2, out_features=2, bias=True)
     |          )
     |          1 -> Linear(in_features=2, out_features=2, bias=True)
     |  
     |  named_buffers(self, prefix='', recurse=True)
     |      Returns an iterator over module buffers, yielding both the
     |      name of the buffer as well as the buffer itself.
     |      
     |      Args:
     |          prefix (str): prefix to prepend to all buffer names.
     |          recurse (bool): if True, then yields buffers of this module
     |              and all submodules. Otherwise, yields only buffers that
     |              are direct members of this module.
     |      
     |      Yields:
     |          (string, torch.Tensor): Tuple containing the name and buffer
     |      
     |      Example::
     |      
     |          >>> for name, buf in self.named_buffers():
     |          >>>    if name in ['running_var']:
     |          >>>        print(buf.size())
     |  
     |  named_children(self)
     |      Returns an iterator over immediate children modules, yielding both
     |      the name of the module as well as the module itself.
     |      
     |      Yields:
     |          (string, Module): Tuple containing a name and child module
     |      
     |      Example::
     |      
     |          >>> for name, module in model.named_children():
     |          >>>     if name in ['conv4', 'conv5']:
     |          >>>         print(module)
     |  
     |  named_modules(self, memo=None, prefix='')
     |      Returns an iterator over all modules in the network, yielding
     |      both the name of the module as well as the module itself.
     |      
     |      Yields:
     |          (string, Module): Tuple of name and module
     |      
     |      Note:
     |          Duplicate modules are returned only once. In the following
     |          example, ``l`` will be returned only once.
     |      
     |      Example::
     |      
     |          >>> l = nn.Linear(2, 2)
     |          >>> net = nn.Sequential(l, l)
     |          >>> for idx, m in enumerate(net.named_modules()):
     |                  print(idx, '->', m)
     |      
     |          0 -> ('', Sequential(
     |            (0): Linear(in_features=2, out_features=2, bias=True)
     |            (1): Linear(in_features=2, out_features=2, bias=True)
     |          ))
     |          1 -> ('0', Linear(in_features=2, out_features=2, bias=True))
     |  
     |  named_parameters(self, prefix='', recurse=True)
     |      Returns an iterator over module parameters, yielding both the
     |      name of the parameter as well as the parameter itself.
     |      
     |      Args:
     |          prefix (str): prefix to prepend to all parameter names.
     |          recurse (bool): if True, then yields parameters of this module
     |              and all submodules. Otherwise, yields only parameters that
     |              are direct members of this module.
     |      
     |      Yields:
     |          (string, Parameter): Tuple containing the name and parameter
     |      
     |      Example::
     |      
     |          >>> for name, param in self.named_parameters():
     |          >>>    if name in ['bias']:
     |          >>>        print(param.size())
     |  
     |  parameters(self, recurse=True)
     |      Returns an iterator over module parameters.
     |      
     |      This is typically passed to an optimizer.
     |      
     |      Args:
     |          recurse (bool): if True, then yields parameters of this module
     |              and all submodules. Otherwise, yields only parameters that
     |              are direct members of this module.
     |      
     |      Yields:
     |          Parameter: module parameter
     |      
     |      Example::
     |      
     |          >>> for param in model.parameters():
     |          >>>     print(type(param.data), param.size())
     |          <class 'torch.FloatTensor'> (20L,)
     |          <class 'torch.FloatTensor'> (20L, 1L, 5L, 5L)
     |  
     |  register_backward_hook(self, hook)
     |      Registers a backward hook on the module.
     |      
     |      The hook will be called every time the gradients with respect to module
     |      inputs are computed. The hook should have the following signature::
     |      
     |          hook(module, grad_input, grad_output) -> Tensor or None
     |      
     |      The :attr:`grad_input` and :attr:`grad_output` may be tuples if the
     |      module has multiple inputs or outputs. The hook should not modify its
     |      arguments, but it can optionally return a new gradient with respect to
     |      input that will be used in place of :attr:`grad_input` in subsequent
     |      computations.
     |      
     |      Returns:
     |          :class:`torch.utils.hooks.RemovableHandle`:
     |              a handle that can be used to remove the added hook by calling
     |              ``handle.remove()``
     |      
     |      .. warning ::
     |      
     |          The current implementation will not have the presented behavior
     |          for complex :class:`Module` that perform many operations.
     |          In some failure cases, :attr:`grad_input` and :attr:`grad_output` will only
     |          contain the gradients for a subset of the inputs and outputs.
     |          For such :class:`Module`, you should use :func:`torch.Tensor.register_hook`
     |          directly on a specific input or output to get the required gradients.
     |  
     |  register_buffer(self, name, tensor)
     |      Adds a persistent buffer to the module.
     |      
     |      This is typically used to register a buffer that should not to be
     |      considered a model parameter. For example, BatchNorm's ``running_mean``
     |      is not a parameter, but is part of the persistent state.
     |      
     |      Buffers can be accessed as attributes using given names.
     |      
     |      Args:
     |          name (string): name of the buffer. The buffer can be accessed
     |              from this module using the given name
     |          tensor (Tensor): buffer to be registered.
     |      
     |      Example::
     |      
     |          >>> self.register_buffer('running_mean', torch.zeros(num_features))
     |  
     |  register_forward_hook(self, hook)
     |      Registers a forward hook on the module.
     |      
     |      The hook will be called every time after :func:`forward` has computed an output.
     |      It should have the following signature::
     |      
     |          hook(module, input, output) -> None or modified output
     |      
     |      The hook can modify the output. It can modify the input inplace but
     |      it will not have effect on forward since this is called after
     |      :func:`forward` is called.
     |      
     |      Returns:
     |          :class:`torch.utils.hooks.RemovableHandle`:
     |              a handle that can be used to remove the added hook by calling
     |              ``handle.remove()``
     |  
     |  register_forward_pre_hook(self, hook)
     |      Registers a forward pre-hook on the module.
     |      
     |      The hook will be called every time before :func:`forward` is invoked.
     |      It should have the following signature::
     |      
     |          hook(module, input) -> None or modified input
     |      
     |      The hook can modify the input. User can either return a tuple or a
     |      single modified value in the hook. We will wrap the value into a tuple
     |      if a single value is returned(unless that value is already a tuple).
     |      
     |      Returns:
     |          :class:`torch.utils.hooks.RemovableHandle`:
     |              a handle that can be used to remove the added hook by calling
     |              ``handle.remove()``
     |  
     |  register_parameter(self, name, param)
     |      Adds a parameter to the module.
     |      
     |      The parameter can be accessed as an attribute using given name.
     |      
     |      Args:
     |          name (string): name of the parameter. The parameter can be accessed
     |              from this module using the given name
     |          param (Parameter): parameter to be added to the module.
     |  
     |  requires_grad_(self, requires_grad=True)
     |      Change if autograd should record operations on parameters in this
     |      module.
     |      
     |      This method sets the parameters' :attr:`requires_grad` attributes
     |      in-place.
     |      
     |      This method is helpful for freezing part of the module for finetuning
     |      or training parts of a model individually (e.g., GAN training).
     |      
     |      Args:
     |          requires_grad (bool): whether autograd should record operations on
     |                                parameters in this module. Default: ``True``.
     |      
     |      Returns:
     |          Module: self
     |  
     |  share_memory(self)
     |  
     |  state_dict(self, destination=None, prefix='', keep_vars=False)
     |      Returns a dictionary containing a whole state of the module.
     |      
     |      Both parameters and persistent buffers (e.g. running averages) are
     |      included. Keys are corresponding parameter and buffer names.
     |      
     |      Returns:
     |          dict:
     |              a dictionary containing a whole state of the module
     |      
     |      Example::
     |      
     |          >>> module.state_dict().keys()
     |          ['bias', 'weight']
     |  
     |  to(self, *args, **kwargs)
     |      Moves and/or casts the parameters and buffers.
     |      
     |      This can be called as
     |      
     |      .. function:: to(device=None, dtype=None, non_blocking=False)
     |      
     |      .. function:: to(dtype, non_blocking=False)
     |      
     |      .. function:: to(tensor, non_blocking=False)
     |      
     |      Its signature is similar to :meth:`torch.Tensor.to`, but only accepts
     |      floating point desired :attr:`dtype` s. In addition, this method will
     |      only cast the floating point parameters and buffers to :attr:`dtype`
     |      (if given). The integral parameters and buffers will be moved
     |      :attr:`device`, if that is given, but with dtypes unchanged. When
     |      :attr:`non_blocking` is set, it tries to convert/move asynchronously
     |      with respect to the host if possible, e.g., moving CPU Tensors with
     |      pinned memory to CUDA devices.
     |      
     |      See below for examples.
     |      
     |      .. note::
     |          This method modifies the module in-place.
     |      
     |      Args:
     |          device (:class:`torch.device`): the desired device of the parameters
     |              and buffers in this module
     |          dtype (:class:`torch.dtype`): the desired floating point type of
     |              the floating point parameters and buffers in this module
     |          tensor (torch.Tensor): Tensor whose dtype and device are the desired
     |              dtype and device for all parameters and buffers in this module
     |      
     |      Returns:
     |          Module: self
     |      
     |      Example::
     |      
     |          >>> linear = nn.Linear(2, 2)
     |          >>> linear.weight
     |          Parameter containing:
     |          tensor([[ 0.1913, -0.3420],
     |                  [-0.5113, -0.2325]])
     |          >>> linear.to(torch.double)
     |          Linear(in_features=2, out_features=2, bias=True)
     |          >>> linear.weight
     |          Parameter containing:
     |          tensor([[ 0.1913, -0.3420],
     |                  [-0.5113, -0.2325]], dtype=torch.float64)
     |          >>> gpu1 = torch.device("cuda:1")
     |          >>> linear.to(gpu1, dtype=torch.half, non_blocking=True)
     |          Linear(in_features=2, out_features=2, bias=True)
     |          >>> linear.weight
     |          Parameter containing:
     |          tensor([[ 0.1914, -0.3420],
     |                  [-0.5112, -0.2324]], dtype=torch.float16, device='cuda:1')
     |          >>> cpu = torch.device("cpu")
     |          >>> linear.to(cpu)
     |          Linear(in_features=2, out_features=2, bias=True)
     |          >>> linear.weight
     |          Parameter containing:
     |          tensor([[ 0.1914, -0.3420],
     |                  [-0.5112, -0.2324]], dtype=torch.float16)
     |  
     |  train(self, mode=True)
     |      Sets the module in training mode.
     |      
     |      This has any effect only on certain modules. See documentations of
     |      particular modules for details of their behaviors in training/evaluation
     |      mode, if they are affected, e.g. :class:`Dropout`, :class:`BatchNorm`,
     |      etc.
     |      
     |      Args:
     |          mode (bool): whether to set training mode (``True``) or evaluation
     |                       mode (``False``). Default: ``True``.
     |      
     |      Returns:
     |          Module: self
     |  
     |  type(self, dst_type)
     |      Casts all parameters and buffers to :attr:`dst_type`.
     |      
     |      Arguments:
     |          dst_type (type or string): the desired type
     |      
     |      Returns:
     |          Module: self
     |  
     |  zero_grad(self)
     |      Sets gradients of all model parameters to zero.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from torch.nn.modules.module.Module:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from torch.nn.modules.module.Module:
     |  
     |  dump_patches = False
    
    class Fun(torch.nn.modules.module.Module)
     |  Fun(f, info=None)
     |  
     |  Turn an arbitrary function into a layer.
     |  
     |  Method resolution order:
     |      Fun
     |      torch.nn.modules.module.Module
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __getnewargs__(self)
     |  
     |  __init__(self, f, info=None)
     |      Initializes internal Module state, shared by both nn.Module and ScriptModule.
     |  
     |  __repr__(self)
     |      Return repr(self).
     |  
     |  forward(self, x)
     |      Defines the computation performed at every call.
     |      
     |      Should be overridden by all subclasses.
     |      
     |      .. note::
     |          Although the recipe for forward pass needs to be defined within
     |          this function, one should call the :class:`Module` instance afterwards
     |          instead of this since the former takes care of running the
     |          registered hooks while the latter silently ignores them.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from torch.nn.modules.module.Module:
     |  
     |  __call__(self, *input, **kwargs)
     |      Call self as a function.
     |  
     |  __delattr__(self, name)
     |      Implement delattr(self, name).
     |  
     |  __dir__(self)
     |      Default dir() implementation.
     |  
     |  __getattr__(self, name)
     |  
     |  __setattr__(self, name, value)
     |      Implement setattr(self, name, value).
     |  
     |  __setstate__(self, state)
     |  
     |  add_module(self, name, module)
     |      Adds a child module to the current module.
     |      
     |      The module can be accessed as an attribute using the given name.
     |      
     |      Args:
     |          name (string): name of the child module. The child module can be
     |              accessed from this module using the given name
     |          module (Module): child module to be added to the module.
     |  
     |  apply(self, fn)
     |      Applies ``fn`` recursively to every submodule (as returned by ``.children()``)
     |      as well as self. Typical use includes initializing the parameters of a model
     |      (see also :ref:`nn-init-doc`).
     |      
     |      Args:
     |          fn (:class:`Module` -> None): function to be applied to each submodule
     |      
     |      Returns:
     |          Module: self
     |      
     |      Example::
     |      
     |          >>> def init_weights(m):
     |          >>>     print(m)
     |          >>>     if type(m) == nn.Linear:
     |          >>>         m.weight.data.fill_(1.0)
     |          >>>         print(m.weight)
     |          >>> net = nn.Sequential(nn.Linear(2, 2), nn.Linear(2, 2))
     |          >>> net.apply(init_weights)
     |          Linear(in_features=2, out_features=2, bias=True)
     |          Parameter containing:
     |          tensor([[ 1.,  1.],
     |                  [ 1.,  1.]])
     |          Linear(in_features=2, out_features=2, bias=True)
     |          Parameter containing:
     |          tensor([[ 1.,  1.],
     |                  [ 1.,  1.]])
     |          Sequential(
     |            (0): Linear(in_features=2, out_features=2, bias=True)
     |            (1): Linear(in_features=2, out_features=2, bias=True)
     |          )
     |          Sequential(
     |            (0): Linear(in_features=2, out_features=2, bias=True)
     |            (1): Linear(in_features=2, out_features=2, bias=True)
     |          )
     |  
     |  buffers(self, recurse=True)
     |      Returns an iterator over module buffers.
     |      
     |      Args:
     |          recurse (bool): if True, then yields buffers of this module
     |              and all submodules. Otherwise, yields only buffers that
     |              are direct members of this module.
     |      
     |      Yields:
     |          torch.Tensor: module buffer
     |      
     |      Example::
     |      
     |          >>> for buf in model.buffers():
     |          >>>     print(type(buf.data), buf.size())
     |          <class 'torch.FloatTensor'> (20L,)
     |          <class 'torch.FloatTensor'> (20L, 1L, 5L, 5L)
     |  
     |  children(self)
     |      Returns an iterator over immediate children modules.
     |      
     |      Yields:
     |          Module: a child module
     |  
     |  cpu(self)
     |      Moves all model parameters and buffers to the CPU.
     |      
     |      Returns:
     |          Module: self
     |  
     |  cuda(self, device=None)
     |      Moves all model parameters and buffers to the GPU.
     |      
     |      This also makes associated parameters and buffers different objects. So
     |      it should be called before constructing optimizer if the module will
     |      live on GPU while being optimized.
     |      
     |      Arguments:
     |          device (int, optional): if specified, all parameters will be
     |              copied to that device
     |      
     |      Returns:
     |          Module: self
     |  
     |  double(self)
     |      Casts all floating point parameters and buffers to ``double`` datatype.
     |      
     |      Returns:
     |          Module: self
     |  
     |  eval(self)
     |      Sets the module in evaluation mode.
     |      
     |      This has any effect only on certain modules. See documentations of
     |      particular modules for details of their behaviors in training/evaluation
     |      mode, if they are affected, e.g. :class:`Dropout`, :class:`BatchNorm`,
     |      etc.
     |      
     |      This is equivalent with :meth:`self.train(False) <torch.nn.Module.train>`.
     |      
     |      Returns:
     |          Module: self
     |  
     |  extra_repr(self)
     |      Set the extra representation of the module
     |      
     |      To print customized extra information, you should reimplement
     |      this method in your own modules. Both single-line and multi-line
     |      strings are acceptable.
     |  
     |  float(self)
     |      Casts all floating point parameters and buffers to float datatype.
     |      
     |      Returns:
     |          Module: self
     |  
     |  half(self)
     |      Casts all floating point parameters and buffers to ``half`` datatype.
     |      
     |      Returns:
     |          Module: self
     |  
     |  load_state_dict(self, state_dict, strict=True)
     |      Copies parameters and buffers from :attr:`state_dict` into
     |      this module and its descendants. If :attr:`strict` is ``True``, then
     |      the keys of :attr:`state_dict` must exactly match the keys returned
     |      by this module's :meth:`~torch.nn.Module.state_dict` function.
     |      
     |      Arguments:
     |          state_dict (dict): a dict containing parameters and
     |              persistent buffers.
     |          strict (bool, optional): whether to strictly enforce that the keys
     |              in :attr:`state_dict` match the keys returned by this module's
     |              :meth:`~torch.nn.Module.state_dict` function. Default: ``True``
     |      
     |      Returns:
     |          ``NamedTuple`` with ``missing_keys`` and ``unexpected_keys`` fields:
     |              * **missing_keys** is a list of str containing the missing keys
     |              * **unexpected_keys** is a list of str containing the unexpected keys
     |  
     |  modules(self)
     |      Returns an iterator over all modules in the network.
     |      
     |      Yields:
     |          Module: a module in the network
     |      
     |      Note:
     |          Duplicate modules are returned only once. In the following
     |          example, ``l`` will be returned only once.
     |      
     |      Example::
     |      
     |          >>> l = nn.Linear(2, 2)
     |          >>> net = nn.Sequential(l, l)
     |          >>> for idx, m in enumerate(net.modules()):
     |                  print(idx, '->', m)
     |      
     |          0 -> Sequential(
     |            (0): Linear(in_features=2, out_features=2, bias=True)
     |            (1): Linear(in_features=2, out_features=2, bias=True)
     |          )
     |          1 -> Linear(in_features=2, out_features=2, bias=True)
     |  
     |  named_buffers(self, prefix='', recurse=True)
     |      Returns an iterator over module buffers, yielding both the
     |      name of the buffer as well as the buffer itself.
     |      
     |      Args:
     |          prefix (str): prefix to prepend to all buffer names.
     |          recurse (bool): if True, then yields buffers of this module
     |              and all submodules. Otherwise, yields only buffers that
     |              are direct members of this module.
     |      
     |      Yields:
     |          (string, torch.Tensor): Tuple containing the name and buffer
     |      
     |      Example::
     |      
     |          >>> for name, buf in self.named_buffers():
     |          >>>    if name in ['running_var']:
     |          >>>        print(buf.size())
     |  
     |  named_children(self)
     |      Returns an iterator over immediate children modules, yielding both
     |      the name of the module as well as the module itself.
     |      
     |      Yields:
     |          (string, Module): Tuple containing a name and child module
     |      
     |      Example::
     |      
     |          >>> for name, module in model.named_children():
     |          >>>     if name in ['conv4', 'conv5']:
     |          >>>         print(module)
     |  
     |  named_modules(self, memo=None, prefix='')
     |      Returns an iterator over all modules in the network, yielding
     |      both the name of the module as well as the module itself.
     |      
     |      Yields:
     |          (string, Module): Tuple of name and module
     |      
     |      Note:
     |          Duplicate modules are returned only once. In the following
     |          example, ``l`` will be returned only once.
     |      
     |      Example::
     |      
     |          >>> l = nn.Linear(2, 2)
     |          >>> net = nn.Sequential(l, l)
     |          >>> for idx, m in enumerate(net.named_modules()):
     |                  print(idx, '->', m)
     |      
     |          0 -> ('', Sequential(
     |            (0): Linear(in_features=2, out_features=2, bias=True)
     |            (1): Linear(in_features=2, out_features=2, bias=True)
     |          ))
     |          1 -> ('0', Linear(in_features=2, out_features=2, bias=True))
     |  
     |  named_parameters(self, prefix='', recurse=True)
     |      Returns an iterator over module parameters, yielding both the
     |      name of the parameter as well as the parameter itself.
     |      
     |      Args:
     |          prefix (str): prefix to prepend to all parameter names.
     |          recurse (bool): if True, then yields parameters of this module
     |              and all submodules. Otherwise, yields only parameters that
     |              are direct members of this module.
     |      
     |      Yields:
     |          (string, Parameter): Tuple containing the name and parameter
     |      
     |      Example::
     |      
     |          >>> for name, param in self.named_parameters():
     |          >>>    if name in ['bias']:
     |          >>>        print(param.size())
     |  
     |  parameters(self, recurse=True)
     |      Returns an iterator over module parameters.
     |      
     |      This is typically passed to an optimizer.
     |      
     |      Args:
     |          recurse (bool): if True, then yields parameters of this module
     |              and all submodules. Otherwise, yields only parameters that
     |              are direct members of this module.
     |      
     |      Yields:
     |          Parameter: module parameter
     |      
     |      Example::
     |      
     |          >>> for param in model.parameters():
     |          >>>     print(type(param.data), param.size())
     |          <class 'torch.FloatTensor'> (20L,)
     |          <class 'torch.FloatTensor'> (20L, 1L, 5L, 5L)
     |  
     |  register_backward_hook(self, hook)
     |      Registers a backward hook on the module.
     |      
     |      The hook will be called every time the gradients with respect to module
     |      inputs are computed. The hook should have the following signature::
     |      
     |          hook(module, grad_input, grad_output) -> Tensor or None
     |      
     |      The :attr:`grad_input` and :attr:`grad_output` may be tuples if the
     |      module has multiple inputs or outputs. The hook should not modify its
     |      arguments, but it can optionally return a new gradient with respect to
     |      input that will be used in place of :attr:`grad_input` in subsequent
     |      computations.
     |      
     |      Returns:
     |          :class:`torch.utils.hooks.RemovableHandle`:
     |              a handle that can be used to remove the added hook by calling
     |              ``handle.remove()``
     |      
     |      .. warning ::
     |      
     |          The current implementation will not have the presented behavior
     |          for complex :class:`Module` that perform many operations.
     |          In some failure cases, :attr:`grad_input` and :attr:`grad_output` will only
     |          contain the gradients for a subset of the inputs and outputs.
     |          For such :class:`Module`, you should use :func:`torch.Tensor.register_hook`
     |          directly on a specific input or output to get the required gradients.
     |  
     |  register_buffer(self, name, tensor)
     |      Adds a persistent buffer to the module.
     |      
     |      This is typically used to register a buffer that should not to be
     |      considered a model parameter. For example, BatchNorm's ``running_mean``
     |      is not a parameter, but is part of the persistent state.
     |      
     |      Buffers can be accessed as attributes using given names.
     |      
     |      Args:
     |          name (string): name of the buffer. The buffer can be accessed
     |              from this module using the given name
     |          tensor (Tensor): buffer to be registered.
     |      
     |      Example::
     |      
     |          >>> self.register_buffer('running_mean', torch.zeros(num_features))
     |  
     |  register_forward_hook(self, hook)
     |      Registers a forward hook on the module.
     |      
     |      The hook will be called every time after :func:`forward` has computed an output.
     |      It should have the following signature::
     |      
     |          hook(module, input, output) -> None or modified output
     |      
     |      The hook can modify the output. It can modify the input inplace but
     |      it will not have effect on forward since this is called after
     |      :func:`forward` is called.
     |      
     |      Returns:
     |          :class:`torch.utils.hooks.RemovableHandle`:
     |              a handle that can be used to remove the added hook by calling
     |              ``handle.remove()``
     |  
     |  register_forward_pre_hook(self, hook)
     |      Registers a forward pre-hook on the module.
     |      
     |      The hook will be called every time before :func:`forward` is invoked.
     |      It should have the following signature::
     |      
     |          hook(module, input) -> None or modified input
     |      
     |      The hook can modify the input. User can either return a tuple or a
     |      single modified value in the hook. We will wrap the value into a tuple
     |      if a single value is returned(unless that value is already a tuple).
     |      
     |      Returns:
     |          :class:`torch.utils.hooks.RemovableHandle`:
     |              a handle that can be used to remove the added hook by calling
     |              ``handle.remove()``
     |  
     |  register_parameter(self, name, param)
     |      Adds a parameter to the module.
     |      
     |      The parameter can be accessed as an attribute using given name.
     |      
     |      Args:
     |          name (string): name of the parameter. The parameter can be accessed
     |              from this module using the given name
     |          param (Parameter): parameter to be added to the module.
     |  
     |  requires_grad_(self, requires_grad=True)
     |      Change if autograd should record operations on parameters in this
     |      module.
     |      
     |      This method sets the parameters' :attr:`requires_grad` attributes
     |      in-place.
     |      
     |      This method is helpful for freezing part of the module for finetuning
     |      or training parts of a model individually (e.g., GAN training).
     |      
     |      Args:
     |          requires_grad (bool): whether autograd should record operations on
     |                                parameters in this module. Default: ``True``.
     |      
     |      Returns:
     |          Module: self
     |  
     |  share_memory(self)
     |  
     |  state_dict(self, destination=None, prefix='', keep_vars=False)
     |      Returns a dictionary containing a whole state of the module.
     |      
     |      Both parameters and persistent buffers (e.g. running averages) are
     |      included. Keys are corresponding parameter and buffer names.
     |      
     |      Returns:
     |          dict:
     |              a dictionary containing a whole state of the module
     |      
     |      Example::
     |      
     |          >>> module.state_dict().keys()
     |          ['bias', 'weight']
     |  
     |  to(self, *args, **kwargs)
     |      Moves and/or casts the parameters and buffers.
     |      
     |      This can be called as
     |      
     |      .. function:: to(device=None, dtype=None, non_blocking=False)
     |      
     |      .. function:: to(dtype, non_blocking=False)
     |      
     |      .. function:: to(tensor, non_blocking=False)
     |      
     |      Its signature is similar to :meth:`torch.Tensor.to`, but only accepts
     |      floating point desired :attr:`dtype` s. In addition, this method will
     |      only cast the floating point parameters and buffers to :attr:`dtype`
     |      (if given). The integral parameters and buffers will be moved
     |      :attr:`device`, if that is given, but with dtypes unchanged. When
     |      :attr:`non_blocking` is set, it tries to convert/move asynchronously
     |      with respect to the host if possible, e.g., moving CPU Tensors with
     |      pinned memory to CUDA devices.
     |      
     |      See below for examples.
     |      
     |      .. note::
     |          This method modifies the module in-place.
     |      
     |      Args:
     |          device (:class:`torch.device`): the desired device of the parameters
     |              and buffers in this module
     |          dtype (:class:`torch.dtype`): the desired floating point type of
     |              the floating point parameters and buffers in this module
     |          tensor (torch.Tensor): Tensor whose dtype and device are the desired
     |              dtype and device for all parameters and buffers in this module
     |      
     |      Returns:
     |          Module: self
     |      
     |      Example::
     |      
     |          >>> linear = nn.Linear(2, 2)
     |          >>> linear.weight
     |          Parameter containing:
     |          tensor([[ 0.1913, -0.3420],
     |                  [-0.5113, -0.2325]])
     |          >>> linear.to(torch.double)
     |          Linear(in_features=2, out_features=2, bias=True)
     |          >>> linear.weight
     |          Parameter containing:
     |          tensor([[ 0.1913, -0.3420],
     |                  [-0.5113, -0.2325]], dtype=torch.float64)
     |          >>> gpu1 = torch.device("cuda:1")
     |          >>> linear.to(gpu1, dtype=torch.half, non_blocking=True)
     |          Linear(in_features=2, out_features=2, bias=True)
     |          >>> linear.weight
     |          Parameter containing:
     |          tensor([[ 0.1914, -0.3420],
     |                  [-0.5112, -0.2324]], dtype=torch.float16, device='cuda:1')
     |          >>> cpu = torch.device("cpu")
     |          >>> linear.to(cpu)
     |          Linear(in_features=2, out_features=2, bias=True)
     |          >>> linear.weight
     |          Parameter containing:
     |          tensor([[ 0.1914, -0.3420],
     |                  [-0.5112, -0.2324]], dtype=torch.float16)
     |  
     |  train(self, mode=True)
     |      Sets the module in training mode.
     |      
     |      This has any effect only on certain modules. See documentations of
     |      particular modules for details of their behaviors in training/evaluation
     |      mode, if they are affected, e.g. :class:`Dropout`, :class:`BatchNorm`,
     |      etc.
     |      
     |      Args:
     |          mode (bool): whether to set training mode (``True``) or evaluation
     |                       mode (``False``). Default: ``True``.
     |      
     |      Returns:
     |          Module: self
     |  
     |  type(self, dst_type)
     |      Casts all parameters and buffers to :attr:`dst_type`.
     |      
     |      Arguments:
     |          dst_type (type or string): the desired type
     |      
     |      Returns:
     |          Module: self
     |  
     |  zero_grad(self)
     |      Sets gradients of all model parameters to zero.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from torch.nn.modules.module.Module:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from torch.nn.modules.module.Module:
     |  
     |  dump_patches = False
    
    class Fun_(torch.nn.modules.module.Module)
     |  Fun_(f, info=None)
     |  
     |  Turn an arbitrary function into a layer.
     |  
     |  Method resolution order:
     |      Fun_
     |      torch.nn.modules.module.Module
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, f, info=None)
     |      Initializes internal Module state, shared by both nn.Module and ScriptModule.
     |  
     |  __repr__(self)
     |      Return repr(self).
     |  
     |  forward(self, x)
     |      Defines the computation performed at every call.
     |      
     |      Should be overridden by all subclasses.
     |      
     |      .. note::
     |          Although the recipe for forward pass needs to be defined within
     |          this function, one should call the :class:`Module` instance afterwards
     |          instead of this since the former takes care of running the
     |          registered hooks while the latter silently ignores them.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from torch.nn.modules.module.Module:
     |  
     |  __call__(self, *input, **kwargs)
     |      Call self as a function.
     |  
     |  __delattr__(self, name)
     |      Implement delattr(self, name).
     |  
     |  __dir__(self)
     |      Default dir() implementation.
     |  
     |  __getattr__(self, name)
     |  
     |  __setattr__(self, name, value)
     |      Implement setattr(self, name, value).
     |  
     |  __setstate__(self, state)
     |  
     |  add_module(self, name, module)
     |      Adds a child module to the current module.
     |      
     |      The module can be accessed as an attribute using the given name.
     |      
     |      Args:
     |          name (string): name of the child module. The child module can be
     |              accessed from this module using the given name
     |          module (Module): child module to be added to the module.
     |  
     |  apply(self, fn)
     |      Applies ``fn`` recursively to every submodule (as returned by ``.children()``)
     |      as well as self. Typical use includes initializing the parameters of a model
     |      (see also :ref:`nn-init-doc`).
     |      
     |      Args:
     |          fn (:class:`Module` -> None): function to be applied to each submodule
     |      
     |      Returns:
     |          Module: self
     |      
     |      Example::
     |      
     |          >>> def init_weights(m):
     |          >>>     print(m)
     |          >>>     if type(m) == nn.Linear:
     |          >>>         m.weight.data.fill_(1.0)
     |          >>>         print(m.weight)
     |          >>> net = nn.Sequential(nn.Linear(2, 2), nn.Linear(2, 2))
     |          >>> net.apply(init_weights)
     |          Linear(in_features=2, out_features=2, bias=True)
     |          Parameter containing:
     |          tensor([[ 1.,  1.],
     |                  [ 1.,  1.]])
     |          Linear(in_features=2, out_features=2, bias=True)
     |          Parameter containing:
     |          tensor([[ 1.,  1.],
     |                  [ 1.,  1.]])
     |          Sequential(
     |            (0): Linear(in_features=2, out_features=2, bias=True)
     |            (1): Linear(in_features=2, out_features=2, bias=True)
     |          )
     |          Sequential(
     |            (0): Linear(in_features=2, out_features=2, bias=True)
     |            (1): Linear(in_features=2, out_features=2, bias=True)
     |          )
     |  
     |  buffers(self, recurse=True)
     |      Returns an iterator over module buffers.
     |      
     |      Args:
     |          recurse (bool): if True, then yields buffers of this module
     |              and all submodules. Otherwise, yields only buffers that
     |              are direct members of this module.
     |      
     |      Yields:
     |          torch.Tensor: module buffer
     |      
     |      Example::
     |      
     |          >>> for buf in model.buffers():
     |          >>>     print(type(buf.data), buf.size())
     |          <class 'torch.FloatTensor'> (20L,)
     |          <class 'torch.FloatTensor'> (20L, 1L, 5L, 5L)
     |  
     |  children(self)
     |      Returns an iterator over immediate children modules.
     |      
     |      Yields:
     |          Module: a child module
     |  
     |  cpu(self)
     |      Moves all model parameters and buffers to the CPU.
     |      
     |      Returns:
     |          Module: self
     |  
     |  cuda(self, device=None)
     |      Moves all model parameters and buffers to the GPU.
     |      
     |      This also makes associated parameters and buffers different objects. So
     |      it should be called before constructing optimizer if the module will
     |      live on GPU while being optimized.
     |      
     |      Arguments:
     |          device (int, optional): if specified, all parameters will be
     |              copied to that device
     |      
     |      Returns:
     |          Module: self
     |  
     |  double(self)
     |      Casts all floating point parameters and buffers to ``double`` datatype.
     |      
     |      Returns:
     |          Module: self
     |  
     |  eval(self)
     |      Sets the module in evaluation mode.
     |      
     |      This has any effect only on certain modules. See documentations of
     |      particular modules for details of their behaviors in training/evaluation
     |      mode, if they are affected, e.g. :class:`Dropout`, :class:`BatchNorm`,
     |      etc.
     |      
     |      This is equivalent with :meth:`self.train(False) <torch.nn.Module.train>`.
     |      
     |      Returns:
     |          Module: self
     |  
     |  extra_repr(self)
     |      Set the extra representation of the module
     |      
     |      To print customized extra information, you should reimplement
     |      this method in your own modules. Both single-line and multi-line
     |      strings are acceptable.
     |  
     |  float(self)
     |      Casts all floating point parameters and buffers to float datatype.
     |      
     |      Returns:
     |          Module: self
     |  
     |  half(self)
     |      Casts all floating point parameters and buffers to ``half`` datatype.
     |      
     |      Returns:
     |          Module: self
     |  
     |  load_state_dict(self, state_dict, strict=True)
     |      Copies parameters and buffers from :attr:`state_dict` into
     |      this module and its descendants. If :attr:`strict` is ``True``, then
     |      the keys of :attr:`state_dict` must exactly match the keys returned
     |      by this module's :meth:`~torch.nn.Module.state_dict` function.
     |      
     |      Arguments:
     |          state_dict (dict): a dict containing parameters and
     |              persistent buffers.
     |          strict (bool, optional): whether to strictly enforce that the keys
     |              in :attr:`state_dict` match the keys returned by this module's
     |              :meth:`~torch.nn.Module.state_dict` function. Default: ``True``
     |      
     |      Returns:
     |          ``NamedTuple`` with ``missing_keys`` and ``unexpected_keys`` fields:
     |              * **missing_keys** is a list of str containing the missing keys
     |              * **unexpected_keys** is a list of str containing the unexpected keys
     |  
     |  modules(self)
     |      Returns an iterator over all modules in the network.
     |      
     |      Yields:
     |          Module: a module in the network
     |      
     |      Note:
     |          Duplicate modules are returned only once. In the following
     |          example, ``l`` will be returned only once.
     |      
     |      Example::
     |      
     |          >>> l = nn.Linear(2, 2)
     |          >>> net = nn.Sequential(l, l)
     |          >>> for idx, m in enumerate(net.modules()):
     |                  print(idx, '->', m)
     |      
     |          0 -> Sequential(
     |            (0): Linear(in_features=2, out_features=2, bias=True)
     |            (1): Linear(in_features=2, out_features=2, bias=True)
     |          )
     |          1 -> Linear(in_features=2, out_features=2, bias=True)
     |  
     |  named_buffers(self, prefix='', recurse=True)
     |      Returns an iterator over module buffers, yielding both the
     |      name of the buffer as well as the buffer itself.
     |      
     |      Args:
     |          prefix (str): prefix to prepend to all buffer names.
     |          recurse (bool): if True, then yields buffers of this module
     |              and all submodules. Otherwise, yields only buffers that
     |              are direct members of this module.
     |      
     |      Yields:
     |          (string, torch.Tensor): Tuple containing the name and buffer
     |      
     |      Example::
     |      
     |          >>> for name, buf in self.named_buffers():
     |          >>>    if name in ['running_var']:
     |          >>>        print(buf.size())
     |  
     |  named_children(self)
     |      Returns an iterator over immediate children modules, yielding both
     |      the name of the module as well as the module itself.
     |      
     |      Yields:
     |          (string, Module): Tuple containing a name and child module
     |      
     |      Example::
     |      
     |          >>> for name, module in model.named_children():
     |          >>>     if name in ['conv4', 'conv5']:
     |          >>>         print(module)
     |  
     |  named_modules(self, memo=None, prefix='')
     |      Returns an iterator over all modules in the network, yielding
     |      both the name of the module as well as the module itself.
     |      
     |      Yields:
     |          (string, Module): Tuple of name and module
     |      
     |      Note:
     |          Duplicate modules are returned only once. In the following
     |          example, ``l`` will be returned only once.
     |      
     |      Example::
     |      
     |          >>> l = nn.Linear(2, 2)
     |          >>> net = nn.Sequential(l, l)
     |          >>> for idx, m in enumerate(net.named_modules()):
     |                  print(idx, '->', m)
     |      
     |          0 -> ('', Sequential(
     |            (0): Linear(in_features=2, out_features=2, bias=True)
     |            (1): Linear(in_features=2, out_features=2, bias=True)
     |          ))
     |          1 -> ('0', Linear(in_features=2, out_features=2, bias=True))
     |  
     |  named_parameters(self, prefix='', recurse=True)
     |      Returns an iterator over module parameters, yielding both the
     |      name of the parameter as well as the parameter itself.
     |      
     |      Args:
     |          prefix (str): prefix to prepend to all parameter names.
     |          recurse (bool): if True, then yields parameters of this module
     |              and all submodules. Otherwise, yields only parameters that
     |              are direct members of this module.
     |      
     |      Yields:
     |          (string, Parameter): Tuple containing the name and parameter
     |      
     |      Example::
     |      
     |          >>> for name, param in self.named_parameters():
     |          >>>    if name in ['bias']:
     |          >>>        print(param.size())
     |  
     |  parameters(self, recurse=True)
     |      Returns an iterator over module parameters.
     |      
     |      This is typically passed to an optimizer.
     |      
     |      Args:
     |          recurse (bool): if True, then yields parameters of this module
     |              and all submodules. Otherwise, yields only parameters that
     |              are direct members of this module.
     |      
     |      Yields:
     |          Parameter: module parameter
     |      
     |      Example::
     |      
     |          >>> for param in model.parameters():
     |          >>>     print(type(param.data), param.size())
     |          <class 'torch.FloatTensor'> (20L,)
     |          <class 'torch.FloatTensor'> (20L, 1L, 5L, 5L)
     |  
     |  register_backward_hook(self, hook)
     |      Registers a backward hook on the module.
     |      
     |      The hook will be called every time the gradients with respect to module
     |      inputs are computed. The hook should have the following signature::
     |      
     |          hook(module, grad_input, grad_output) -> Tensor or None
     |      
     |      The :attr:`grad_input` and :attr:`grad_output` may be tuples if the
     |      module has multiple inputs or outputs. The hook should not modify its
     |      arguments, but it can optionally return a new gradient with respect to
     |      input that will be used in place of :attr:`grad_input` in subsequent
     |      computations.
     |      
     |      Returns:
     |          :class:`torch.utils.hooks.RemovableHandle`:
     |              a handle that can be used to remove the added hook by calling
     |              ``handle.remove()``
     |      
     |      .. warning ::
     |      
     |          The current implementation will not have the presented behavior
     |          for complex :class:`Module` that perform many operations.
     |          In some failure cases, :attr:`grad_input` and :attr:`grad_output` will only
     |          contain the gradients for a subset of the inputs and outputs.
     |          For such :class:`Module`, you should use :func:`torch.Tensor.register_hook`
     |          directly on a specific input or output to get the required gradients.
     |  
     |  register_buffer(self, name, tensor)
     |      Adds a persistent buffer to the module.
     |      
     |      This is typically used to register a buffer that should not to be
     |      considered a model parameter. For example, BatchNorm's ``running_mean``
     |      is not a parameter, but is part of the persistent state.
     |      
     |      Buffers can be accessed as attributes using given names.
     |      
     |      Args:
     |          name (string): name of the buffer. The buffer can be accessed
     |              from this module using the given name
     |          tensor (Tensor): buffer to be registered.
     |      
     |      Example::
     |      
     |          >>> self.register_buffer('running_mean', torch.zeros(num_features))
     |  
     |  register_forward_hook(self, hook)
     |      Registers a forward hook on the module.
     |      
     |      The hook will be called every time after :func:`forward` has computed an output.
     |      It should have the following signature::
     |      
     |          hook(module, input, output) -> None or modified output
     |      
     |      The hook can modify the output. It can modify the input inplace but
     |      it will not have effect on forward since this is called after
     |      :func:`forward` is called.
     |      
     |      Returns:
     |          :class:`torch.utils.hooks.RemovableHandle`:
     |              a handle that can be used to remove the added hook by calling
     |              ``handle.remove()``
     |  
     |  register_forward_pre_hook(self, hook)
     |      Registers a forward pre-hook on the module.
     |      
     |      The hook will be called every time before :func:`forward` is invoked.
     |      It should have the following signature::
     |      
     |          hook(module, input) -> None or modified input
     |      
     |      The hook can modify the input. User can either return a tuple or a
     |      single modified value in the hook. We will wrap the value into a tuple
     |      if a single value is returned(unless that value is already a tuple).
     |      
     |      Returns:
     |          :class:`torch.utils.hooks.RemovableHandle`:
     |              a handle that can be used to remove the added hook by calling
     |              ``handle.remove()``
     |  
     |  register_parameter(self, name, param)
     |      Adds a parameter to the module.
     |      
     |      The parameter can be accessed as an attribute using given name.
     |      
     |      Args:
     |          name (string): name of the parameter. The parameter can be accessed
     |              from this module using the given name
     |          param (Parameter): parameter to be added to the module.
     |  
     |  requires_grad_(self, requires_grad=True)
     |      Change if autograd should record operations on parameters in this
     |      module.
     |      
     |      This method sets the parameters' :attr:`requires_grad` attributes
     |      in-place.
     |      
     |      This method is helpful for freezing part of the module for finetuning
     |      or training parts of a model individually (e.g., GAN training).
     |      
     |      Args:
     |          requires_grad (bool): whether autograd should record operations on
     |                                parameters in this module. Default: ``True``.
     |      
     |      Returns:
     |          Module: self
     |  
     |  share_memory(self)
     |  
     |  state_dict(self, destination=None, prefix='', keep_vars=False)
     |      Returns a dictionary containing a whole state of the module.
     |      
     |      Both parameters and persistent buffers (e.g. running averages) are
     |      included. Keys are corresponding parameter and buffer names.
     |      
     |      Returns:
     |          dict:
     |              a dictionary containing a whole state of the module
     |      
     |      Example::
     |      
     |          >>> module.state_dict().keys()
     |          ['bias', 'weight']
     |  
     |  to(self, *args, **kwargs)
     |      Moves and/or casts the parameters and buffers.
     |      
     |      This can be called as
     |      
     |      .. function:: to(device=None, dtype=None, non_blocking=False)
     |      
     |      .. function:: to(dtype, non_blocking=False)
     |      
     |      .. function:: to(tensor, non_blocking=False)
     |      
     |      Its signature is similar to :meth:`torch.Tensor.to`, but only accepts
     |      floating point desired :attr:`dtype` s. In addition, this method will
     |      only cast the floating point parameters and buffers to :attr:`dtype`
     |      (if given). The integral parameters and buffers will be moved
     |      :attr:`device`, if that is given, but with dtypes unchanged. When
     |      :attr:`non_blocking` is set, it tries to convert/move asynchronously
     |      with respect to the host if possible, e.g., moving CPU Tensors with
     |      pinned memory to CUDA devices.
     |      
     |      See below for examples.
     |      
     |      .. note::
     |          This method modifies the module in-place.
     |      
     |      Args:
     |          device (:class:`torch.device`): the desired device of the parameters
     |              and buffers in this module
     |          dtype (:class:`torch.dtype`): the desired floating point type of
     |              the floating point parameters and buffers in this module
     |          tensor (torch.Tensor): Tensor whose dtype and device are the desired
     |              dtype and device for all parameters and buffers in this module
     |      
     |      Returns:
     |          Module: self
     |      
     |      Example::
     |      
     |          >>> linear = nn.Linear(2, 2)
     |          >>> linear.weight
     |          Parameter containing:
     |          tensor([[ 0.1913, -0.3420],
     |                  [-0.5113, -0.2325]])
     |          >>> linear.to(torch.double)
     |          Linear(in_features=2, out_features=2, bias=True)
     |          >>> linear.weight
     |          Parameter containing:
     |          tensor([[ 0.1913, -0.3420],
     |                  [-0.5113, -0.2325]], dtype=torch.float64)
     |          >>> gpu1 = torch.device("cuda:1")
     |          >>> linear.to(gpu1, dtype=torch.half, non_blocking=True)
     |          Linear(in_features=2, out_features=2, bias=True)
     |          >>> linear.weight
     |          Parameter containing:
     |          tensor([[ 0.1914, -0.3420],
     |                  [-0.5112, -0.2324]], dtype=torch.float16, device='cuda:1')
     |          >>> cpu = torch.device("cpu")
     |          >>> linear.to(cpu)
     |          Linear(in_features=2, out_features=2, bias=True)
     |          >>> linear.weight
     |          Parameter containing:
     |          tensor([[ 0.1914, -0.3420],
     |                  [-0.5112, -0.2324]], dtype=torch.float16)
     |  
     |  train(self, mode=True)
     |      Sets the module in training mode.
     |      
     |      This has any effect only on certain modules. See documentations of
     |      particular modules for details of their behaviors in training/evaluation
     |      mode, if they are affected, e.g. :class:`Dropout`, :class:`BatchNorm`,
     |      etc.
     |      
     |      Args:
     |          mode (bool): whether to set training mode (``True``) or evaluation
     |                       mode (``False``). Default: ``True``.
     |      
     |      Returns:
     |          Module: self
     |  
     |  type(self, dst_type)
     |      Casts all parameters and buffers to :attr:`dst_type`.
     |      
     |      Arguments:
     |          dst_type (type or string): the desired type
     |      
     |      Returns:
     |          Module: self
     |  
     |  zero_grad(self)
     |      Sets gradients of all model parameters to zero.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from torch.nn.modules.module.Module:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from torch.nn.modules.module.Module:
     |  
     |  dump_patches = False
    
    class Info(torch.nn.modules.module.Module)
     |  Info(info='', every=1000000)
     |  
     |  Output information for the given input.
     |  
     |  Method resolution order:
     |      Info
     |      torch.nn.modules.module.Module
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, info='', every=1000000)
     |      Initializes internal Module state, shared by both nn.Module and ScriptModule.
     |  
     |  __repr__(self)
     |      Return repr(self).
     |  
     |  forward(self, x)
     |      Defines the computation performed at every call.
     |      
     |      Should be overridden by all subclasses.
     |      
     |      .. note::
     |          Although the recipe for forward pass needs to be defined within
     |          this function, one should call the :class:`Module` instance afterwards
     |          instead of this since the former takes care of running the
     |          registered hooks while the latter silently ignores them.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from torch.nn.modules.module.Module:
     |  
     |  __call__(self, *input, **kwargs)
     |      Call self as a function.
     |  
     |  __delattr__(self, name)
     |      Implement delattr(self, name).
     |  
     |  __dir__(self)
     |      Default dir() implementation.
     |  
     |  __getattr__(self, name)
     |  
     |  __setattr__(self, name, value)
     |      Implement setattr(self, name, value).
     |  
     |  __setstate__(self, state)
     |  
     |  add_module(self, name, module)
     |      Adds a child module to the current module.
     |      
     |      The module can be accessed as an attribute using the given name.
     |      
     |      Args:
     |          name (string): name of the child module. The child module can be
     |              accessed from this module using the given name
     |          module (Module): child module to be added to the module.
     |  
     |  apply(self, fn)
     |      Applies ``fn`` recursively to every submodule (as returned by ``.children()``)
     |      as well as self. Typical use includes initializing the parameters of a model
     |      (see also :ref:`nn-init-doc`).
     |      
     |      Args:
     |          fn (:class:`Module` -> None): function to be applied to each submodule
     |      
     |      Returns:
     |          Module: self
     |      
     |      Example::
     |      
     |          >>> def init_weights(m):
     |          >>>     print(m)
     |          >>>     if type(m) == nn.Linear:
     |          >>>         m.weight.data.fill_(1.0)
     |          >>>         print(m.weight)
     |          >>> net = nn.Sequential(nn.Linear(2, 2), nn.Linear(2, 2))
     |          >>> net.apply(init_weights)
     |          Linear(in_features=2, out_features=2, bias=True)
     |          Parameter containing:
     |          tensor([[ 1.,  1.],
     |                  [ 1.,  1.]])
     |          Linear(in_features=2, out_features=2, bias=True)
     |          Parameter containing:
     |          tensor([[ 1.,  1.],
     |                  [ 1.,  1.]])
     |          Sequential(
     |            (0): Linear(in_features=2, out_features=2, bias=True)
     |            (1): Linear(in_features=2, out_features=2, bias=True)
     |          )
     |          Sequential(
     |            (0): Linear(in_features=2, out_features=2, bias=True)
     |            (1): Linear(in_features=2, out_features=2, bias=True)
     |          )
     |  
     |  buffers(self, recurse=True)
     |      Returns an iterator over module buffers.
     |      
     |      Args:
     |          recurse (bool): if True, then yields buffers of this module
     |              and all submodules. Otherwise, yields only buffers that
     |              are direct members of this module.
     |      
     |      Yields:
     |          torch.Tensor: module buffer
     |      
     |      Example::
     |      
     |          >>> for buf in model.buffers():
     |          >>>     print(type(buf.data), buf.size())
     |          <class 'torch.FloatTensor'> (20L,)
     |          <class 'torch.FloatTensor'> (20L, 1L, 5L, 5L)
     |  
     |  children(self)
     |      Returns an iterator over immediate children modules.
     |      
     |      Yields:
     |          Module: a child module
     |  
     |  cpu(self)
     |      Moves all model parameters and buffers to the CPU.
     |      
     |      Returns:
     |          Module: self
     |  
     |  cuda(self, device=None)
     |      Moves all model parameters and buffers to the GPU.
     |      
     |      This also makes associated parameters and buffers different objects. So
     |      it should be called before constructing optimizer if the module will
     |      live on GPU while being optimized.
     |      
     |      Arguments:
     |          device (int, optional): if specified, all parameters will be
     |              copied to that device
     |      
     |      Returns:
     |          Module: self
     |  
     |  double(self)
     |      Casts all floating point parameters and buffers to ``double`` datatype.
     |      
     |      Returns:
     |          Module: self
     |  
     |  eval(self)
     |      Sets the module in evaluation mode.
     |      
     |      This has any effect only on certain modules. See documentations of
     |      particular modules for details of their behaviors in training/evaluation
     |      mode, if they are affected, e.g. :class:`Dropout`, :class:`BatchNorm`,
     |      etc.
     |      
     |      This is equivalent with :meth:`self.train(False) <torch.nn.Module.train>`.
     |      
     |      Returns:
     |          Module: self
     |  
     |  extra_repr(self)
     |      Set the extra representation of the module
     |      
     |      To print customized extra information, you should reimplement
     |      this method in your own modules. Both single-line and multi-line
     |      strings are acceptable.
     |  
     |  float(self)
     |      Casts all floating point parameters and buffers to float datatype.
     |      
     |      Returns:
     |          Module: self
     |  
     |  half(self)
     |      Casts all floating point parameters and buffers to ``half`` datatype.
     |      
     |      Returns:
     |          Module: self
     |  
     |  load_state_dict(self, state_dict, strict=True)
     |      Copies parameters and buffers from :attr:`state_dict` into
     |      this module and its descendants. If :attr:`strict` is ``True``, then
     |      the keys of :attr:`state_dict` must exactly match the keys returned
     |      by this module's :meth:`~torch.nn.Module.state_dict` function.
     |      
     |      Arguments:
     |          state_dict (dict): a dict containing parameters and
     |              persistent buffers.
     |          strict (bool, optional): whether to strictly enforce that the keys
     |              in :attr:`state_dict` match the keys returned by this module's
     |              :meth:`~torch.nn.Module.state_dict` function. Default: ``True``
     |      
     |      Returns:
     |          ``NamedTuple`` with ``missing_keys`` and ``unexpected_keys`` fields:
     |              * **missing_keys** is a list of str containing the missing keys
     |              * **unexpected_keys** is a list of str containing the unexpected keys
     |  
     |  modules(self)
     |      Returns an iterator over all modules in the network.
     |      
     |      Yields:
     |          Module: a module in the network
     |      
     |      Note:
     |          Duplicate modules are returned only once. In the following
     |          example, ``l`` will be returned only once.
     |      
     |      Example::
     |      
     |          >>> l = nn.Linear(2, 2)
     |          >>> net = nn.Sequential(l, l)
     |          >>> for idx, m in enumerate(net.modules()):
     |                  print(idx, '->', m)
     |      
     |          0 -> Sequential(
     |            (0): Linear(in_features=2, out_features=2, bias=True)
     |            (1): Linear(in_features=2, out_features=2, bias=True)
     |          )
     |          1 -> Linear(in_features=2, out_features=2, bias=True)
     |  
     |  named_buffers(self, prefix='', recurse=True)
     |      Returns an iterator over module buffers, yielding both the
     |      name of the buffer as well as the buffer itself.
     |      
     |      Args:
     |          prefix (str): prefix to prepend to all buffer names.
     |          recurse (bool): if True, then yields buffers of this module
     |              and all submodules. Otherwise, yields only buffers that
     |              are direct members of this module.
     |      
     |      Yields:
     |          (string, torch.Tensor): Tuple containing the name and buffer
     |      
     |      Example::
     |      
     |          >>> for name, buf in self.named_buffers():
     |          >>>    if name in ['running_var']:
     |          >>>        print(buf.size())
     |  
     |  named_children(self)
     |      Returns an iterator over immediate children modules, yielding both
     |      the name of the module as well as the module itself.
     |      
     |      Yields:
     |          (string, Module): Tuple containing a name and child module
     |      
     |      Example::
     |      
     |          >>> for name, module in model.named_children():
     |          >>>     if name in ['conv4', 'conv5']:
     |          >>>         print(module)
     |  
     |  named_modules(self, memo=None, prefix='')
     |      Returns an iterator over all modules in the network, yielding
     |      both the name of the module as well as the module itself.
     |      
     |      Yields:
     |          (string, Module): Tuple of name and module
     |      
     |      Note:
     |          Duplicate modules are returned only once. In the following
     |          example, ``l`` will be returned only once.
     |      
     |      Example::
     |      
     |          >>> l = nn.Linear(2, 2)
     |          >>> net = nn.Sequential(l, l)
     |          >>> for idx, m in enumerate(net.named_modules()):
     |                  print(idx, '->', m)
     |      
     |          0 -> ('', Sequential(
     |            (0): Linear(in_features=2, out_features=2, bias=True)
     |            (1): Linear(in_features=2, out_features=2, bias=True)
     |          ))
     |          1 -> ('0', Linear(in_features=2, out_features=2, bias=True))
     |  
     |  named_parameters(self, prefix='', recurse=True)
     |      Returns an iterator over module parameters, yielding both the
     |      name of the parameter as well as the parameter itself.
     |      
     |      Args:
     |          prefix (str): prefix to prepend to all parameter names.
     |          recurse (bool): if True, then yields parameters of this module
     |              and all submodules. Otherwise, yields only parameters that
     |              are direct members of this module.
     |      
     |      Yields:
     |          (string, Parameter): Tuple containing the name and parameter
     |      
     |      Example::
     |      
     |          >>> for name, param in self.named_parameters():
     |          >>>    if name in ['bias']:
     |          >>>        print(param.size())
     |  
     |  parameters(self, recurse=True)
     |      Returns an iterator over module parameters.
     |      
     |      This is typically passed to an optimizer.
     |      
     |      Args:
     |          recurse (bool): if True, then yields parameters of this module
     |              and all submodules. Otherwise, yields only parameters that
     |              are direct members of this module.
     |      
     |      Yields:
     |          Parameter: module parameter
     |      
     |      Example::
     |      
     |          >>> for param in model.parameters():
     |          >>>     print(type(param.data), param.size())
     |          <class 'torch.FloatTensor'> (20L,)
     |          <class 'torch.FloatTensor'> (20L, 1L, 5L, 5L)
     |  
     |  register_backward_hook(self, hook)
     |      Registers a backward hook on the module.
     |      
     |      The hook will be called every time the gradients with respect to module
     |      inputs are computed. The hook should have the following signature::
     |      
     |          hook(module, grad_input, grad_output) -> Tensor or None
     |      
     |      The :attr:`grad_input` and :attr:`grad_output` may be tuples if the
     |      module has multiple inputs or outputs. The hook should not modify its
     |      arguments, but it can optionally return a new gradient with respect to
     |      input that will be used in place of :attr:`grad_input` in subsequent
     |      computations.
     |      
     |      Returns:
     |          :class:`torch.utils.hooks.RemovableHandle`:
     |              a handle that can be used to remove the added hook by calling
     |              ``handle.remove()``
     |      
     |      .. warning ::
     |      
     |          The current implementation will not have the presented behavior
     |          for complex :class:`Module` that perform many operations.
     |          In some failure cases, :attr:`grad_input` and :attr:`grad_output` will only
     |          contain the gradients for a subset of the inputs and outputs.
     |          For such :class:`Module`, you should use :func:`torch.Tensor.register_hook`
     |          directly on a specific input or output to get the required gradients.
     |  
     |  register_buffer(self, name, tensor)
     |      Adds a persistent buffer to the module.
     |      
     |      This is typically used to register a buffer that should not to be
     |      considered a model parameter. For example, BatchNorm's ``running_mean``
     |      is not a parameter, but is part of the persistent state.
     |      
     |      Buffers can be accessed as attributes using given names.
     |      
     |      Args:
     |          name (string): name of the buffer. The buffer can be accessed
     |              from this module using the given name
     |          tensor (Tensor): buffer to be registered.
     |      
     |      Example::
     |      
     |          >>> self.register_buffer('running_mean', torch.zeros(num_features))
     |  
     |  register_forward_hook(self, hook)
     |      Registers a forward hook on the module.
     |      
     |      The hook will be called every time after :func:`forward` has computed an output.
     |      It should have the following signature::
     |      
     |          hook(module, input, output) -> None or modified output
     |      
     |      The hook can modify the output. It can modify the input inplace but
     |      it will not have effect on forward since this is called after
     |      :func:`forward` is called.
     |      
     |      Returns:
     |          :class:`torch.utils.hooks.RemovableHandle`:
     |              a handle that can be used to remove the added hook by calling
     |              ``handle.remove()``
     |  
     |  register_forward_pre_hook(self, hook)
     |      Registers a forward pre-hook on the module.
     |      
     |      The hook will be called every time before :func:`forward` is invoked.
     |      It should have the following signature::
     |      
     |          hook(module, input) -> None or modified input
     |      
     |      The hook can modify the input. User can either return a tuple or a
     |      single modified value in the hook. We will wrap the value into a tuple
     |      if a single value is returned(unless that value is already a tuple).
     |      
     |      Returns:
     |          :class:`torch.utils.hooks.RemovableHandle`:
     |              a handle that can be used to remove the added hook by calling
     |              ``handle.remove()``
     |  
     |  register_parameter(self, name, param)
     |      Adds a parameter to the module.
     |      
     |      The parameter can be accessed as an attribute using given name.
     |      
     |      Args:
     |          name (string): name of the parameter. The parameter can be accessed
     |              from this module using the given name
     |          param (Parameter): parameter to be added to the module.
     |  
     |  requires_grad_(self, requires_grad=True)
     |      Change if autograd should record operations on parameters in this
     |      module.
     |      
     |      This method sets the parameters' :attr:`requires_grad` attributes
     |      in-place.
     |      
     |      This method is helpful for freezing part of the module for finetuning
     |      or training parts of a model individually (e.g., GAN training).
     |      
     |      Args:
     |          requires_grad (bool): whether autograd should record operations on
     |                                parameters in this module. Default: ``True``.
     |      
     |      Returns:
     |          Module: self
     |  
     |  share_memory(self)
     |  
     |  state_dict(self, destination=None, prefix='', keep_vars=False)
     |      Returns a dictionary containing a whole state of the module.
     |      
     |      Both parameters and persistent buffers (e.g. running averages) are
     |      included. Keys are corresponding parameter and buffer names.
     |      
     |      Returns:
     |          dict:
     |              a dictionary containing a whole state of the module
     |      
     |      Example::
     |      
     |          >>> module.state_dict().keys()
     |          ['bias', 'weight']
     |  
     |  to(self, *args, **kwargs)
     |      Moves and/or casts the parameters and buffers.
     |      
     |      This can be called as
     |      
     |      .. function:: to(device=None, dtype=None, non_blocking=False)
     |      
     |      .. function:: to(dtype, non_blocking=False)
     |      
     |      .. function:: to(tensor, non_blocking=False)
     |      
     |      Its signature is similar to :meth:`torch.Tensor.to`, but only accepts
     |      floating point desired :attr:`dtype` s. In addition, this method will
     |      only cast the floating point parameters and buffers to :attr:`dtype`
     |      (if given). The integral parameters and buffers will be moved
     |      :attr:`device`, if that is given, but with dtypes unchanged. When
     |      :attr:`non_blocking` is set, it tries to convert/move asynchronously
     |      with respect to the host if possible, e.g., moving CPU Tensors with
     |      pinned memory to CUDA devices.
     |      
     |      See below for examples.
     |      
     |      .. note::
     |          This method modifies the module in-place.
     |      
     |      Args:
     |          device (:class:`torch.device`): the desired device of the parameters
     |              and buffers in this module
     |          dtype (:class:`torch.dtype`): the desired floating point type of
     |              the floating point parameters and buffers in this module
     |          tensor (torch.Tensor): Tensor whose dtype and device are the desired
     |              dtype and device for all parameters and buffers in this module
     |      
     |      Returns:
     |          Module: self
     |      
     |      Example::
     |      
     |          >>> linear = nn.Linear(2, 2)
     |          >>> linear.weight
     |          Parameter containing:
     |          tensor([[ 0.1913, -0.3420],
     |                  [-0.5113, -0.2325]])
     |          >>> linear.to(torch.double)
     |          Linear(in_features=2, out_features=2, bias=True)
     |          >>> linear.weight
     |          Parameter containing:
     |          tensor([[ 0.1913, -0.3420],
     |                  [-0.5113, -0.2325]], dtype=torch.float64)
     |          >>> gpu1 = torch.device("cuda:1")
     |          >>> linear.to(gpu1, dtype=torch.half, non_blocking=True)
     |          Linear(in_features=2, out_features=2, bias=True)
     |          >>> linear.weight
     |          Parameter containing:
     |          tensor([[ 0.1914, -0.3420],
     |                  [-0.5112, -0.2324]], dtype=torch.float16, device='cuda:1')
     |          >>> cpu = torch.device("cpu")
     |          >>> linear.to(cpu)
     |          Linear(in_features=2, out_features=2, bias=True)
     |          >>> linear.weight
     |          Parameter containing:
     |          tensor([[ 0.1914, -0.3420],
     |                  [-0.5112, -0.2324]], dtype=torch.float16)
     |  
     |  train(self, mode=True)
     |      Sets the module in training mode.
     |      
     |      This has any effect only on certain modules. See documentations of
     |      particular modules for details of their behaviors in training/evaluation
     |      mode, if they are affected, e.g. :class:`Dropout`, :class:`BatchNorm`,
     |      etc.
     |      
     |      Args:
     |          mode (bool): whether to set training mode (``True``) or evaluation
     |                       mode (``False``). Default: ``True``.
     |      
     |      Returns:
     |          Module: self
     |  
     |  type(self, dst_type)
     |      Casts all parameters and buffers to :attr:`dst_type`.
     |      
     |      Arguments:
     |          dst_type (type or string): the desired type
     |      
     |      Returns:
     |          Module: self
     |  
     |  zero_grad(self)
     |      Sets gradients of all model parameters to zero.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from torch.nn.modules.module.Module:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from torch.nn.modules.module.Module:
     |  
     |  dump_patches = False
    
    class Input(torch.nn.modules.module.Module)
     |  Input(assume, reorder=None, range=None, sizes=None, device=True, dtype=torch.float32)
     |  
     |  Base class for all neural network modules.
     |  
     |  Your models should also subclass this class.
     |  
     |  Modules can also contain other Modules, allowing to nest them in
     |  a tree structure. You can assign the submodules as regular attributes::
     |  
     |      import torch.nn as nn
     |      import torch.nn.functional as F
     |  
     |      class Model(nn.Module):
     |          def __init__(self):
     |              super(Model, self).__init__()
     |              self.conv1 = nn.Conv2d(1, 20, 5)
     |              self.conv2 = nn.Conv2d(20, 20, 5)
     |  
     |          def forward(self, x):
     |              x = F.relu(self.conv1(x))
     |              return F.relu(self.conv2(x))
     |  
     |  Submodules assigned in this way will be registered, and will have their
     |  parameters converted too when you call :meth:`to`, etc.
     |  
     |  Method resolution order:
     |      Input
     |      torch.nn.modules.module.Module
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, assume, reorder=None, range=None, sizes=None, device=True, dtype=torch.float32)
     |      Declares the input for a network.
     |      
     |      :param order: order of axes (e.g., BDL, BHWD, etc.)
     |      :param dtype: dtype to convert to
     |      :param range: tuple giving low/high values
     |      :param device: input device to move to (True = auto)
     |      :param assume: default input order (when tensor doesn't have order attribute; None=required)
     |  
     |  __repr__(self)
     |      Return repr(self).
     |  
     |  forward(self, x)
     |      Defines the computation performed at every call.
     |      
     |      Should be overridden by all subclasses.
     |      
     |      .. note::
     |          Although the recipe for forward pass needs to be defined within
     |          this function, one should call the :class:`Module` instance afterwards
     |          instead of this since the former takes care of running the
     |          registered hooks while the latter silently ignores them.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from torch.nn.modules.module.Module:
     |  
     |  __call__(self, *input, **kwargs)
     |      Call self as a function.
     |  
     |  __delattr__(self, name)
     |      Implement delattr(self, name).
     |  
     |  __dir__(self)
     |      Default dir() implementation.
     |  
     |  __getattr__(self, name)
     |  
     |  __setattr__(self, name, value)
     |      Implement setattr(self, name, value).
     |  
     |  __setstate__(self, state)
     |  
     |  add_module(self, name, module)
     |      Adds a child module to the current module.
     |      
     |      The module can be accessed as an attribute using the given name.
     |      
     |      Args:
     |          name (string): name of the child module. The child module can be
     |              accessed from this module using the given name
     |          module (Module): child module to be added to the module.
     |  
     |  apply(self, fn)
     |      Applies ``fn`` recursively to every submodule (as returned by ``.children()``)
     |      as well as self. Typical use includes initializing the parameters of a model
     |      (see also :ref:`nn-init-doc`).
     |      
     |      Args:
     |          fn (:class:`Module` -> None): function to be applied to each submodule
     |      
     |      Returns:
     |          Module: self
     |      
     |      Example::
     |      
     |          >>> def init_weights(m):
     |          >>>     print(m)
     |          >>>     if type(m) == nn.Linear:
     |          >>>         m.weight.data.fill_(1.0)
     |          >>>         print(m.weight)
     |          >>> net = nn.Sequential(nn.Linear(2, 2), nn.Linear(2, 2))
     |          >>> net.apply(init_weights)
     |          Linear(in_features=2, out_features=2, bias=True)
     |          Parameter containing:
     |          tensor([[ 1.,  1.],
     |                  [ 1.,  1.]])
     |          Linear(in_features=2, out_features=2, bias=True)
     |          Parameter containing:
     |          tensor([[ 1.,  1.],
     |                  [ 1.,  1.]])
     |          Sequential(
     |            (0): Linear(in_features=2, out_features=2, bias=True)
     |            (1): Linear(in_features=2, out_features=2, bias=True)
     |          )
     |          Sequential(
     |            (0): Linear(in_features=2, out_features=2, bias=True)
     |            (1): Linear(in_features=2, out_features=2, bias=True)
     |          )
     |  
     |  buffers(self, recurse=True)
     |      Returns an iterator over module buffers.
     |      
     |      Args:
     |          recurse (bool): if True, then yields buffers of this module
     |              and all submodules. Otherwise, yields only buffers that
     |              are direct members of this module.
     |      
     |      Yields:
     |          torch.Tensor: module buffer
     |      
     |      Example::
     |      
     |          >>> for buf in model.buffers():
     |          >>>     print(type(buf.data), buf.size())
     |          <class 'torch.FloatTensor'> (20L,)
     |          <class 'torch.FloatTensor'> (20L, 1L, 5L, 5L)
     |  
     |  children(self)
     |      Returns an iterator over immediate children modules.
     |      
     |      Yields:
     |          Module: a child module
     |  
     |  cpu(self)
     |      Moves all model parameters and buffers to the CPU.
     |      
     |      Returns:
     |          Module: self
     |  
     |  cuda(self, device=None)
     |      Moves all model parameters and buffers to the GPU.
     |      
     |      This also makes associated parameters and buffers different objects. So
     |      it should be called before constructing optimizer if the module will
     |      live on GPU while being optimized.
     |      
     |      Arguments:
     |          device (int, optional): if specified, all parameters will be
     |              copied to that device
     |      
     |      Returns:
     |          Module: self
     |  
     |  double(self)
     |      Casts all floating point parameters and buffers to ``double`` datatype.
     |      
     |      Returns:
     |          Module: self
     |  
     |  eval(self)
     |      Sets the module in evaluation mode.
     |      
     |      This has any effect only on certain modules. See documentations of
     |      particular modules for details of their behaviors in training/evaluation
     |      mode, if they are affected, e.g. :class:`Dropout`, :class:`BatchNorm`,
     |      etc.
     |      
     |      This is equivalent with :meth:`self.train(False) <torch.nn.Module.train>`.
     |      
     |      Returns:
     |          Module: self
     |  
     |  extra_repr(self)
     |      Set the extra representation of the module
     |      
     |      To print customized extra information, you should reimplement
     |      this method in your own modules. Both single-line and multi-line
     |      strings are acceptable.
     |  
     |  float(self)
     |      Casts all floating point parameters and buffers to float datatype.
     |      
     |      Returns:
     |          Module: self
     |  
     |  half(self)
     |      Casts all floating point parameters and buffers to ``half`` datatype.
     |      
     |      Returns:
     |          Module: self
     |  
     |  load_state_dict(self, state_dict, strict=True)
     |      Copies parameters and buffers from :attr:`state_dict` into
     |      this module and its descendants. If :attr:`strict` is ``True``, then
     |      the keys of :attr:`state_dict` must exactly match the keys returned
     |      by this module's :meth:`~torch.nn.Module.state_dict` function.
     |      
     |      Arguments:
     |          state_dict (dict): a dict containing parameters and
     |              persistent buffers.
     |          strict (bool, optional): whether to strictly enforce that the keys
     |              in :attr:`state_dict` match the keys returned by this module's
     |              :meth:`~torch.nn.Module.state_dict` function. Default: ``True``
     |      
     |      Returns:
     |          ``NamedTuple`` with ``missing_keys`` and ``unexpected_keys`` fields:
     |              * **missing_keys** is a list of str containing the missing keys
     |              * **unexpected_keys** is a list of str containing the unexpected keys
     |  
     |  modules(self)
     |      Returns an iterator over all modules in the network.
     |      
     |      Yields:
     |          Module: a module in the network
     |      
     |      Note:
     |          Duplicate modules are returned only once. In the following
     |          example, ``l`` will be returned only once.
     |      
     |      Example::
     |      
     |          >>> l = nn.Linear(2, 2)
     |          >>> net = nn.Sequential(l, l)
     |          >>> for idx, m in enumerate(net.modules()):
     |                  print(idx, '->', m)
     |      
     |          0 -> Sequential(
     |            (0): Linear(in_features=2, out_features=2, bias=True)
     |            (1): Linear(in_features=2, out_features=2, bias=True)
     |          )
     |          1 -> Linear(in_features=2, out_features=2, bias=True)
     |  
     |  named_buffers(self, prefix='', recurse=True)
     |      Returns an iterator over module buffers, yielding both the
     |      name of the buffer as well as the buffer itself.
     |      
     |      Args:
     |          prefix (str): prefix to prepend to all buffer names.
     |          recurse (bool): if True, then yields buffers of this module
     |              and all submodules. Otherwise, yields only buffers that
     |              are direct members of this module.
     |      
     |      Yields:
     |          (string, torch.Tensor): Tuple containing the name and buffer
     |      
     |      Example::
     |      
     |          >>> for name, buf in self.named_buffers():
     |          >>>    if name in ['running_var']:
     |          >>>        print(buf.size())
     |  
     |  named_children(self)
     |      Returns an iterator over immediate children modules, yielding both
     |      the name of the module as well as the module itself.
     |      
     |      Yields:
     |          (string, Module): Tuple containing a name and child module
     |      
     |      Example::
     |      
     |          >>> for name, module in model.named_children():
     |          >>>     if name in ['conv4', 'conv5']:
     |          >>>         print(module)
     |  
     |  named_modules(self, memo=None, prefix='')
     |      Returns an iterator over all modules in the network, yielding
     |      both the name of the module as well as the module itself.
     |      
     |      Yields:
     |          (string, Module): Tuple of name and module
     |      
     |      Note:
     |          Duplicate modules are returned only once. In the following
     |          example, ``l`` will be returned only once.
     |      
     |      Example::
     |      
     |          >>> l = nn.Linear(2, 2)
     |          >>> net = nn.Sequential(l, l)
     |          >>> for idx, m in enumerate(net.named_modules()):
     |                  print(idx, '->', m)
     |      
     |          0 -> ('', Sequential(
     |            (0): Linear(in_features=2, out_features=2, bias=True)
     |            (1): Linear(in_features=2, out_features=2, bias=True)
     |          ))
     |          1 -> ('0', Linear(in_features=2, out_features=2, bias=True))
     |  
     |  named_parameters(self, prefix='', recurse=True)
     |      Returns an iterator over module parameters, yielding both the
     |      name of the parameter as well as the parameter itself.
     |      
     |      Args:
     |          prefix (str): prefix to prepend to all parameter names.
     |          recurse (bool): if True, then yields parameters of this module
     |              and all submodules. Otherwise, yields only parameters that
     |              are direct members of this module.
     |      
     |      Yields:
     |          (string, Parameter): Tuple containing the name and parameter
     |      
     |      Example::
     |      
     |          >>> for name, param in self.named_parameters():
     |          >>>    if name in ['bias']:
     |          >>>        print(param.size())
     |  
     |  parameters(self, recurse=True)
     |      Returns an iterator over module parameters.
     |      
     |      This is typically passed to an optimizer.
     |      
     |      Args:
     |          recurse (bool): if True, then yields parameters of this module
     |              and all submodules. Otherwise, yields only parameters that
     |              are direct members of this module.
     |      
     |      Yields:
     |          Parameter: module parameter
     |      
     |      Example::
     |      
     |          >>> for param in model.parameters():
     |          >>>     print(type(param.data), param.size())
     |          <class 'torch.FloatTensor'> (20L,)
     |          <class 'torch.FloatTensor'> (20L, 1L, 5L, 5L)
     |  
     |  register_backward_hook(self, hook)
     |      Registers a backward hook on the module.
     |      
     |      The hook will be called every time the gradients with respect to module
     |      inputs are computed. The hook should have the following signature::
     |      
     |          hook(module, grad_input, grad_output) -> Tensor or None
     |      
     |      The :attr:`grad_input` and :attr:`grad_output` may be tuples if the
     |      module has multiple inputs or outputs. The hook should not modify its
     |      arguments, but it can optionally return a new gradient with respect to
     |      input that will be used in place of :attr:`grad_input` in subsequent
     |      computations.
     |      
     |      Returns:
     |          :class:`torch.utils.hooks.RemovableHandle`:
     |              a handle that can be used to remove the added hook by calling
     |              ``handle.remove()``
     |      
     |      .. warning ::
     |      
     |          The current implementation will not have the presented behavior
     |          for complex :class:`Module` that perform many operations.
     |          In some failure cases, :attr:`grad_input` and :attr:`grad_output` will only
     |          contain the gradients for a subset of the inputs and outputs.
     |          For such :class:`Module`, you should use :func:`torch.Tensor.register_hook`
     |          directly on a specific input or output to get the required gradients.
     |  
     |  register_buffer(self, name, tensor)
     |      Adds a persistent buffer to the module.
     |      
     |      This is typically used to register a buffer that should not to be
     |      considered a model parameter. For example, BatchNorm's ``running_mean``
     |      is not a parameter, but is part of the persistent state.
     |      
     |      Buffers can be accessed as attributes using given names.
     |      
     |      Args:
     |          name (string): name of the buffer. The buffer can be accessed
     |              from this module using the given name
     |          tensor (Tensor): buffer to be registered.
     |      
     |      Example::
     |      
     |          >>> self.register_buffer('running_mean', torch.zeros(num_features))
     |  
     |  register_forward_hook(self, hook)
     |      Registers a forward hook on the module.
     |      
     |      The hook will be called every time after :func:`forward` has computed an output.
     |      It should have the following signature::
     |      
     |          hook(module, input, output) -> None or modified output
     |      
     |      The hook can modify the output. It can modify the input inplace but
     |      it will not have effect on forward since this is called after
     |      :func:`forward` is called.
     |      
     |      Returns:
     |          :class:`torch.utils.hooks.RemovableHandle`:
     |              a handle that can be used to remove the added hook by calling
     |              ``handle.remove()``
     |  
     |  register_forward_pre_hook(self, hook)
     |      Registers a forward pre-hook on the module.
     |      
     |      The hook will be called every time before :func:`forward` is invoked.
     |      It should have the following signature::
     |      
     |          hook(module, input) -> None or modified input
     |      
     |      The hook can modify the input. User can either return a tuple or a
     |      single modified value in the hook. We will wrap the value into a tuple
     |      if a single value is returned(unless that value is already a tuple).
     |      
     |      Returns:
     |          :class:`torch.utils.hooks.RemovableHandle`:
     |              a handle that can be used to remove the added hook by calling
     |              ``handle.remove()``
     |  
     |  register_parameter(self, name, param)
     |      Adds a parameter to the module.
     |      
     |      The parameter can be accessed as an attribute using given name.
     |      
     |      Args:
     |          name (string): name of the parameter. The parameter can be accessed
     |              from this module using the given name
     |          param (Parameter): parameter to be added to the module.
     |  
     |  requires_grad_(self, requires_grad=True)
     |      Change if autograd should record operations on parameters in this
     |      module.
     |      
     |      This method sets the parameters' :attr:`requires_grad` attributes
     |      in-place.
     |      
     |      This method is helpful for freezing part of the module for finetuning
     |      or training parts of a model individually (e.g., GAN training).
     |      
     |      Args:
     |          requires_grad (bool): whether autograd should record operations on
     |                                parameters in this module. Default: ``True``.
     |      
     |      Returns:
     |          Module: self
     |  
     |  share_memory(self)
     |  
     |  state_dict(self, destination=None, prefix='', keep_vars=False)
     |      Returns a dictionary containing a whole state of the module.
     |      
     |      Both parameters and persistent buffers (e.g. running averages) are
     |      included. Keys are corresponding parameter and buffer names.
     |      
     |      Returns:
     |          dict:
     |              a dictionary containing a whole state of the module
     |      
     |      Example::
     |      
     |          >>> module.state_dict().keys()
     |          ['bias', 'weight']
     |  
     |  to(self, *args, **kwargs)
     |      Moves and/or casts the parameters and buffers.
     |      
     |      This can be called as
     |      
     |      .. function:: to(device=None, dtype=None, non_blocking=False)
     |      
     |      .. function:: to(dtype, non_blocking=False)
     |      
     |      .. function:: to(tensor, non_blocking=False)
     |      
     |      Its signature is similar to :meth:`torch.Tensor.to`, but only accepts
     |      floating point desired :attr:`dtype` s. In addition, this method will
     |      only cast the floating point parameters and buffers to :attr:`dtype`
     |      (if given). The integral parameters and buffers will be moved
     |      :attr:`device`, if that is given, but with dtypes unchanged. When
     |      :attr:`non_blocking` is set, it tries to convert/move asynchronously
     |      with respect to the host if possible, e.g., moving CPU Tensors with
     |      pinned memory to CUDA devices.
     |      
     |      See below for examples.
     |      
     |      .. note::
     |          This method modifies the module in-place.
     |      
     |      Args:
     |          device (:class:`torch.device`): the desired device of the parameters
     |              and buffers in this module
     |          dtype (:class:`torch.dtype`): the desired floating point type of
     |              the floating point parameters and buffers in this module
     |          tensor (torch.Tensor): Tensor whose dtype and device are the desired
     |              dtype and device for all parameters and buffers in this module
     |      
     |      Returns:
     |          Module: self
     |      
     |      Example::
     |      
     |          >>> linear = nn.Linear(2, 2)
     |          >>> linear.weight
     |          Parameter containing:
     |          tensor([[ 0.1913, -0.3420],
     |                  [-0.5113, -0.2325]])
     |          >>> linear.to(torch.double)
     |          Linear(in_features=2, out_features=2, bias=True)
     |          >>> linear.weight
     |          Parameter containing:
     |          tensor([[ 0.1913, -0.3420],
     |                  [-0.5113, -0.2325]], dtype=torch.float64)
     |          >>> gpu1 = torch.device("cuda:1")
     |          >>> linear.to(gpu1, dtype=torch.half, non_blocking=True)
     |          Linear(in_features=2, out_features=2, bias=True)
     |          >>> linear.weight
     |          Parameter containing:
     |          tensor([[ 0.1914, -0.3420],
     |                  [-0.5112, -0.2324]], dtype=torch.float16, device='cuda:1')
     |          >>> cpu = torch.device("cpu")
     |          >>> linear.to(cpu)
     |          Linear(in_features=2, out_features=2, bias=True)
     |          >>> linear.weight
     |          Parameter containing:
     |          tensor([[ 0.1914, -0.3420],
     |                  [-0.5112, -0.2324]], dtype=torch.float16)
     |  
     |  train(self, mode=True)
     |      Sets the module in training mode.
     |      
     |      This has any effect only on certain modules. See documentations of
     |      particular modules for details of their behaviors in training/evaluation
     |      mode, if they are affected, e.g. :class:`Dropout`, :class:`BatchNorm`,
     |      etc.
     |      
     |      Args:
     |          mode (bool): whether to set training mode (``True``) or evaluation
     |                       mode (``False``). Default: ``True``.
     |      
     |      Returns:
     |          Module: self
     |  
     |  type(self, dst_type)
     |      Casts all parameters and buffers to :attr:`dst_type`.
     |      
     |      Arguments:
     |          dst_type (type or string): the desired type
     |      
     |      Returns:
     |          Module: self
     |  
     |  zero_grad(self)
     |      Sets gradients of all model parameters to zero.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from torch.nn.modules.module.Module:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from torch.nn.modules.module.Module:
     |  
     |  dump_patches = False
    
    class KeepSize(torch.nn.modules.module.Module)
     |  KeepSize(mode='bilinear', sub=None, dims=None)
     |  
     |  Run layers, then upsample back to the original.
     |  
     |  Method resolution order:
     |      KeepSize
     |      torch.nn.modules.module.Module
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, mode='bilinear', sub=None, dims=None)
     |      Initializes internal Module state, shared by both nn.Module and ScriptModule.
     |  
     |  forward(self, x)
     |      Defines the computation performed at every call.
     |      
     |      Should be overridden by all subclasses.
     |      
     |      .. note::
     |          Although the recipe for forward pass needs to be defined within
     |          this function, one should call the :class:`Module` instance afterwards
     |          instead of this since the former takes care of running the
     |          registered hooks while the latter silently ignores them.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from torch.nn.modules.module.Module:
     |  
     |  __call__(self, *input, **kwargs)
     |      Call self as a function.
     |  
     |  __delattr__(self, name)
     |      Implement delattr(self, name).
     |  
     |  __dir__(self)
     |      Default dir() implementation.
     |  
     |  __getattr__(self, name)
     |  
     |  __repr__(self)
     |      Return repr(self).
     |  
     |  __setattr__(self, name, value)
     |      Implement setattr(self, name, value).
     |  
     |  __setstate__(self, state)
     |  
     |  add_module(self, name, module)
     |      Adds a child module to the current module.
     |      
     |      The module can be accessed as an attribute using the given name.
     |      
     |      Args:
     |          name (string): name of the child module. The child module can be
     |              accessed from this module using the given name
     |          module (Module): child module to be added to the module.
     |  
     |  apply(self, fn)
     |      Applies ``fn`` recursively to every submodule (as returned by ``.children()``)
     |      as well as self. Typical use includes initializing the parameters of a model
     |      (see also :ref:`nn-init-doc`).
     |      
     |      Args:
     |          fn (:class:`Module` -> None): function to be applied to each submodule
     |      
     |      Returns:
     |          Module: self
     |      
     |      Example::
     |      
     |          >>> def init_weights(m):
     |          >>>     print(m)
     |          >>>     if type(m) == nn.Linear:
     |          >>>         m.weight.data.fill_(1.0)
     |          >>>         print(m.weight)
     |          >>> net = nn.Sequential(nn.Linear(2, 2), nn.Linear(2, 2))
     |          >>> net.apply(init_weights)
     |          Linear(in_features=2, out_features=2, bias=True)
     |          Parameter containing:
     |          tensor([[ 1.,  1.],
     |                  [ 1.,  1.]])
     |          Linear(in_features=2, out_features=2, bias=True)
     |          Parameter containing:
     |          tensor([[ 1.,  1.],
     |                  [ 1.,  1.]])
     |          Sequential(
     |            (0): Linear(in_features=2, out_features=2, bias=True)
     |            (1): Linear(in_features=2, out_features=2, bias=True)
     |          )
     |          Sequential(
     |            (0): Linear(in_features=2, out_features=2, bias=True)
     |            (1): Linear(in_features=2, out_features=2, bias=True)
     |          )
     |  
     |  buffers(self, recurse=True)
     |      Returns an iterator over module buffers.
     |      
     |      Args:
     |          recurse (bool): if True, then yields buffers of this module
     |              and all submodules. Otherwise, yields only buffers that
     |              are direct members of this module.
     |      
     |      Yields:
     |          torch.Tensor: module buffer
     |      
     |      Example::
     |      
     |          >>> for buf in model.buffers():
     |          >>>     print(type(buf.data), buf.size())
     |          <class 'torch.FloatTensor'> (20L,)
     |          <class 'torch.FloatTensor'> (20L, 1L, 5L, 5L)
     |  
     |  children(self)
     |      Returns an iterator over immediate children modules.
     |      
     |      Yields:
     |          Module: a child module
     |  
     |  cpu(self)
     |      Moves all model parameters and buffers to the CPU.
     |      
     |      Returns:
     |          Module: self
     |  
     |  cuda(self, device=None)
     |      Moves all model parameters and buffers to the GPU.
     |      
     |      This also makes associated parameters and buffers different objects. So
     |      it should be called before constructing optimizer if the module will
     |      live on GPU while being optimized.
     |      
     |      Arguments:
     |          device (int, optional): if specified, all parameters will be
     |              copied to that device
     |      
     |      Returns:
     |          Module: self
     |  
     |  double(self)
     |      Casts all floating point parameters and buffers to ``double`` datatype.
     |      
     |      Returns:
     |          Module: self
     |  
     |  eval(self)
     |      Sets the module in evaluation mode.
     |      
     |      This has any effect only on certain modules. See documentations of
     |      particular modules for details of their behaviors in training/evaluation
     |      mode, if they are affected, e.g. :class:`Dropout`, :class:`BatchNorm`,
     |      etc.
     |      
     |      This is equivalent with :meth:`self.train(False) <torch.nn.Module.train>`.
     |      
     |      Returns:
     |          Module: self
     |  
     |  extra_repr(self)
     |      Set the extra representation of the module
     |      
     |      To print customized extra information, you should reimplement
     |      this method in your own modules. Both single-line and multi-line
     |      strings are acceptable.
     |  
     |  float(self)
     |      Casts all floating point parameters and buffers to float datatype.
     |      
     |      Returns:
     |          Module: self
     |  
     |  half(self)
     |      Casts all floating point parameters and buffers to ``half`` datatype.
     |      
     |      Returns:
     |          Module: self
     |  
     |  load_state_dict(self, state_dict, strict=True)
     |      Copies parameters and buffers from :attr:`state_dict` into
     |      this module and its descendants. If :attr:`strict` is ``True``, then
     |      the keys of :attr:`state_dict` must exactly match the keys returned
     |      by this module's :meth:`~torch.nn.Module.state_dict` function.
     |      
     |      Arguments:
     |          state_dict (dict): a dict containing parameters and
     |              persistent buffers.
     |          strict (bool, optional): whether to strictly enforce that the keys
     |              in :attr:`state_dict` match the keys returned by this module's
     |              :meth:`~torch.nn.Module.state_dict` function. Default: ``True``
     |      
     |      Returns:
     |          ``NamedTuple`` with ``missing_keys`` and ``unexpected_keys`` fields:
     |              * **missing_keys** is a list of str containing the missing keys
     |              * **unexpected_keys** is a list of str containing the unexpected keys
     |  
     |  modules(self)
     |      Returns an iterator over all modules in the network.
     |      
     |      Yields:
     |          Module: a module in the network
     |      
     |      Note:
     |          Duplicate modules are returned only once. In the following
     |          example, ``l`` will be returned only once.
     |      
     |      Example::
     |      
     |          >>> l = nn.Linear(2, 2)
     |          >>> net = nn.Sequential(l, l)
     |          >>> for idx, m in enumerate(net.modules()):
     |                  print(idx, '->', m)
     |      
     |          0 -> Sequential(
     |            (0): Linear(in_features=2, out_features=2, bias=True)
     |            (1): Linear(in_features=2, out_features=2, bias=True)
     |          )
     |          1 -> Linear(in_features=2, out_features=2, bias=True)
     |  
     |  named_buffers(self, prefix='', recurse=True)
     |      Returns an iterator over module buffers, yielding both the
     |      name of the buffer as well as the buffer itself.
     |      
     |      Args:
     |          prefix (str): prefix to prepend to all buffer names.
     |          recurse (bool): if True, then yields buffers of this module
     |              and all submodules. Otherwise, yields only buffers that
     |              are direct members of this module.
     |      
     |      Yields:
     |          (string, torch.Tensor): Tuple containing the name and buffer
     |      
     |      Example::
     |      
     |          >>> for name, buf in self.named_buffers():
     |          >>>    if name in ['running_var']:
     |          >>>        print(buf.size())
     |  
     |  named_children(self)
     |      Returns an iterator over immediate children modules, yielding both
     |      the name of the module as well as the module itself.
     |      
     |      Yields:
     |          (string, Module): Tuple containing a name and child module
     |      
     |      Example::
     |      
     |          >>> for name, module in model.named_children():
     |          >>>     if name in ['conv4', 'conv5']:
     |          >>>         print(module)
     |  
     |  named_modules(self, memo=None, prefix='')
     |      Returns an iterator over all modules in the network, yielding
     |      both the name of the module as well as the module itself.
     |      
     |      Yields:
     |          (string, Module): Tuple of name and module
     |      
     |      Note:
     |          Duplicate modules are returned only once. In the following
     |          example, ``l`` will be returned only once.
     |      
     |      Example::
     |      
     |          >>> l = nn.Linear(2, 2)
     |          >>> net = nn.Sequential(l, l)
     |          >>> for idx, m in enumerate(net.named_modules()):
     |                  print(idx, '->', m)
     |      
     |          0 -> ('', Sequential(
     |            (0): Linear(in_features=2, out_features=2, bias=True)
     |            (1): Linear(in_features=2, out_features=2, bias=True)
     |          ))
     |          1 -> ('0', Linear(in_features=2, out_features=2, bias=True))
     |  
     |  named_parameters(self, prefix='', recurse=True)
     |      Returns an iterator over module parameters, yielding both the
     |      name of the parameter as well as the parameter itself.
     |      
     |      Args:
     |          prefix (str): prefix to prepend to all parameter names.
     |          recurse (bool): if True, then yields parameters of this module
     |              and all submodules. Otherwise, yields only parameters that
     |              are direct members of this module.
     |      
     |      Yields:
     |          (string, Parameter): Tuple containing the name and parameter
     |      
     |      Example::
     |      
     |          >>> for name, param in self.named_parameters():
     |          >>>    if name in ['bias']:
     |          >>>        print(param.size())
     |  
     |  parameters(self, recurse=True)
     |      Returns an iterator over module parameters.
     |      
     |      This is typically passed to an optimizer.
     |      
     |      Args:
     |          recurse (bool): if True, then yields parameters of this module
     |              and all submodules. Otherwise, yields only parameters that
     |              are direct members of this module.
     |      
     |      Yields:
     |          Parameter: module parameter
     |      
     |      Example::
     |      
     |          >>> for param in model.parameters():
     |          >>>     print(type(param.data), param.size())
     |          <class 'torch.FloatTensor'> (20L,)
     |          <class 'torch.FloatTensor'> (20L, 1L, 5L, 5L)
     |  
     |  register_backward_hook(self, hook)
     |      Registers a backward hook on the module.
     |      
     |      The hook will be called every time the gradients with respect to module
     |      inputs are computed. The hook should have the following signature::
     |      
     |          hook(module, grad_input, grad_output) -> Tensor or None
     |      
     |      The :attr:`grad_input` and :attr:`grad_output` may be tuples if the
     |      module has multiple inputs or outputs. The hook should not modify its
     |      arguments, but it can optionally return a new gradient with respect to
     |      input that will be used in place of :attr:`grad_input` in subsequent
     |      computations.
     |      
     |      Returns:
     |          :class:`torch.utils.hooks.RemovableHandle`:
     |              a handle that can be used to remove the added hook by calling
     |              ``handle.remove()``
     |      
     |      .. warning ::
     |      
     |          The current implementation will not have the presented behavior
     |          for complex :class:`Module` that perform many operations.
     |          In some failure cases, :attr:`grad_input` and :attr:`grad_output` will only
     |          contain the gradients for a subset of the inputs and outputs.
     |          For such :class:`Module`, you should use :func:`torch.Tensor.register_hook`
     |          directly on a specific input or output to get the required gradients.
     |  
     |  register_buffer(self, name, tensor)
     |      Adds a persistent buffer to the module.
     |      
     |      This is typically used to register a buffer that should not to be
     |      considered a model parameter. For example, BatchNorm's ``running_mean``
     |      is not a parameter, but is part of the persistent state.
     |      
     |      Buffers can be accessed as attributes using given names.
     |      
     |      Args:
     |          name (string): name of the buffer. The buffer can be accessed
     |              from this module using the given name
     |          tensor (Tensor): buffer to be registered.
     |      
     |      Example::
     |      
     |          >>> self.register_buffer('running_mean', torch.zeros(num_features))
     |  
     |  register_forward_hook(self, hook)
     |      Registers a forward hook on the module.
     |      
     |      The hook will be called every time after :func:`forward` has computed an output.
     |      It should have the following signature::
     |      
     |          hook(module, input, output) -> None or modified output
     |      
     |      The hook can modify the output. It can modify the input inplace but
     |      it will not have effect on forward since this is called after
     |      :func:`forward` is called.
     |      
     |      Returns:
     |          :class:`torch.utils.hooks.RemovableHandle`:
     |              a handle that can be used to remove the added hook by calling
     |              ``handle.remove()``
     |  
     |  register_forward_pre_hook(self, hook)
     |      Registers a forward pre-hook on the module.
     |      
     |      The hook will be called every time before :func:`forward` is invoked.
     |      It should have the following signature::
     |      
     |          hook(module, input) -> None or modified input
     |      
     |      The hook can modify the input. User can either return a tuple or a
     |      single modified value in the hook. We will wrap the value into a tuple
     |      if a single value is returned(unless that value is already a tuple).
     |      
     |      Returns:
     |          :class:`torch.utils.hooks.RemovableHandle`:
     |              a handle that can be used to remove the added hook by calling
     |              ``handle.remove()``
     |  
     |  register_parameter(self, name, param)
     |      Adds a parameter to the module.
     |      
     |      The parameter can be accessed as an attribute using given name.
     |      
     |      Args:
     |          name (string): name of the parameter. The parameter can be accessed
     |              from this module using the given name
     |          param (Parameter): parameter to be added to the module.
     |  
     |  requires_grad_(self, requires_grad=True)
     |      Change if autograd should record operations on parameters in this
     |      module.
     |      
     |      This method sets the parameters' :attr:`requires_grad` attributes
     |      in-place.
     |      
     |      This method is helpful for freezing part of the module for finetuning
     |      or training parts of a model individually (e.g., GAN training).
     |      
     |      Args:
     |          requires_grad (bool): whether autograd should record operations on
     |                                parameters in this module. Default: ``True``.
     |      
     |      Returns:
     |          Module: self
     |  
     |  share_memory(self)
     |  
     |  state_dict(self, destination=None, prefix='', keep_vars=False)
     |      Returns a dictionary containing a whole state of the module.
     |      
     |      Both parameters and persistent buffers (e.g. running averages) are
     |      included. Keys are corresponding parameter and buffer names.
     |      
     |      Returns:
     |          dict:
     |              a dictionary containing a whole state of the module
     |      
     |      Example::
     |      
     |          >>> module.state_dict().keys()
     |          ['bias', 'weight']
     |  
     |  to(self, *args, **kwargs)
     |      Moves and/or casts the parameters and buffers.
     |      
     |      This can be called as
     |      
     |      .. function:: to(device=None, dtype=None, non_blocking=False)
     |      
     |      .. function:: to(dtype, non_blocking=False)
     |      
     |      .. function:: to(tensor, non_blocking=False)
     |      
     |      Its signature is similar to :meth:`torch.Tensor.to`, but only accepts
     |      floating point desired :attr:`dtype` s. In addition, this method will
     |      only cast the floating point parameters and buffers to :attr:`dtype`
     |      (if given). The integral parameters and buffers will be moved
     |      :attr:`device`, if that is given, but with dtypes unchanged. When
     |      :attr:`non_blocking` is set, it tries to convert/move asynchronously
     |      with respect to the host if possible, e.g., moving CPU Tensors with
     |      pinned memory to CUDA devices.
     |      
     |      See below for examples.
     |      
     |      .. note::
     |          This method modifies the module in-place.
     |      
     |      Args:
     |          device (:class:`torch.device`): the desired device of the parameters
     |              and buffers in this module
     |          dtype (:class:`torch.dtype`): the desired floating point type of
     |              the floating point parameters and buffers in this module
     |          tensor (torch.Tensor): Tensor whose dtype and device are the desired
     |              dtype and device for all parameters and buffers in this module
     |      
     |      Returns:
     |          Module: self
     |      
     |      Example::
     |      
     |          >>> linear = nn.Linear(2, 2)
     |          >>> linear.weight
     |          Parameter containing:
     |          tensor([[ 0.1913, -0.3420],
     |                  [-0.5113, -0.2325]])
     |          >>> linear.to(torch.double)
     |          Linear(in_features=2, out_features=2, bias=True)
     |          >>> linear.weight
     |          Parameter containing:
     |          tensor([[ 0.1913, -0.3420],
     |                  [-0.5113, -0.2325]], dtype=torch.float64)
     |          >>> gpu1 = torch.device("cuda:1")
     |          >>> linear.to(gpu1, dtype=torch.half, non_blocking=True)
     |          Linear(in_features=2, out_features=2, bias=True)
     |          >>> linear.weight
     |          Parameter containing:
     |          tensor([[ 0.1914, -0.3420],
     |                  [-0.5112, -0.2324]], dtype=torch.float16, device='cuda:1')
     |          >>> cpu = torch.device("cpu")
     |          >>> linear.to(cpu)
     |          Linear(in_features=2, out_features=2, bias=True)
     |          >>> linear.weight
     |          Parameter containing:
     |          tensor([[ 0.1914, -0.3420],
     |                  [-0.5112, -0.2324]], dtype=torch.float16)
     |  
     |  train(self, mode=True)
     |      Sets the module in training mode.
     |      
     |      This has any effect only on certain modules. See documentations of
     |      particular modules for details of their behaviors in training/evaluation
     |      mode, if they are affected, e.g. :class:`Dropout`, :class:`BatchNorm`,
     |      etc.
     |      
     |      Args:
     |          mode (bool): whether to set training mode (``True``) or evaluation
     |                       mode (``False``). Default: ``True``.
     |      
     |      Returns:
     |          Module: self
     |  
     |  type(self, dst_type)
     |      Casts all parameters and buffers to :attr:`dst_type`.
     |      
     |      Arguments:
     |          dst_type (type or string): the desired type
     |      
     |      Returns:
     |          Module: self
     |  
     |  zero_grad(self)
     |      Sets gradients of all model parameters to zero.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from torch.nn.modules.module.Module:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from torch.nn.modules.module.Module:
     |  
     |  dump_patches = False
    
    class LSTM(torch.nn.modules.module.Module)
     |  LSTM(*args, **kw)
     |  
     |  LSTM wrapper that discards the state.
     |  
     |  Method resolution order:
     |      LSTM
     |      torch.nn.modules.module.Module
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, *args, **kw)
     |      Initializes internal Module state, shared by both nn.Module and ScriptModule.
     |  
     |  forward(self, *args, **kw)
     |      Defines the computation performed at every call.
     |      
     |      Should be overridden by all subclasses.
     |      
     |      .. note::
     |          Although the recipe for forward pass needs to be defined within
     |          this function, one should call the :class:`Module` instance afterwards
     |          instead of this since the former takes care of running the
     |          registered hooks while the latter silently ignores them.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from torch.nn.modules.module.Module:
     |  
     |  __call__(self, *input, **kwargs)
     |      Call self as a function.
     |  
     |  __delattr__(self, name)
     |      Implement delattr(self, name).
     |  
     |  __dir__(self)
     |      Default dir() implementation.
     |  
     |  __getattr__(self, name)
     |  
     |  __repr__(self)
     |      Return repr(self).
     |  
     |  __setattr__(self, name, value)
     |      Implement setattr(self, name, value).
     |  
     |  __setstate__(self, state)
     |  
     |  add_module(self, name, module)
     |      Adds a child module to the current module.
     |      
     |      The module can be accessed as an attribute using the given name.
     |      
     |      Args:
     |          name (string): name of the child module. The child module can be
     |              accessed from this module using the given name
     |          module (Module): child module to be added to the module.
     |  
     |  apply(self, fn)
     |      Applies ``fn`` recursively to every submodule (as returned by ``.children()``)
     |      as well as self. Typical use includes initializing the parameters of a model
     |      (see also :ref:`nn-init-doc`).
     |      
     |      Args:
     |          fn (:class:`Module` -> None): function to be applied to each submodule
     |      
     |      Returns:
     |          Module: self
     |      
     |      Example::
     |      
     |          >>> def init_weights(m):
     |          >>>     print(m)
     |          >>>     if type(m) == nn.Linear:
     |          >>>         m.weight.data.fill_(1.0)
     |          >>>         print(m.weight)
     |          >>> net = nn.Sequential(nn.Linear(2, 2), nn.Linear(2, 2))
     |          >>> net.apply(init_weights)
     |          Linear(in_features=2, out_features=2, bias=True)
     |          Parameter containing:
     |          tensor([[ 1.,  1.],
     |                  [ 1.,  1.]])
     |          Linear(in_features=2, out_features=2, bias=True)
     |          Parameter containing:
     |          tensor([[ 1.,  1.],
     |                  [ 1.,  1.]])
     |          Sequential(
     |            (0): Linear(in_features=2, out_features=2, bias=True)
     |            (1): Linear(in_features=2, out_features=2, bias=True)
     |          )
     |          Sequential(
     |            (0): Linear(in_features=2, out_features=2, bias=True)
     |            (1): Linear(in_features=2, out_features=2, bias=True)
     |          )
     |  
     |  buffers(self, recurse=True)
     |      Returns an iterator over module buffers.
     |      
     |      Args:
     |          recurse (bool): if True, then yields buffers of this module
     |              and all submodules. Otherwise, yields only buffers that
     |              are direct members of this module.
     |      
     |      Yields:
     |          torch.Tensor: module buffer
     |      
     |      Example::
     |      
     |          >>> for buf in model.buffers():
     |          >>>     print(type(buf.data), buf.size())
     |          <class 'torch.FloatTensor'> (20L,)
     |          <class 'torch.FloatTensor'> (20L, 1L, 5L, 5L)
     |  
     |  children(self)
     |      Returns an iterator over immediate children modules.
     |      
     |      Yields:
     |          Module: a child module
     |  
     |  cpu(self)
     |      Moves all model parameters and buffers to the CPU.
     |      
     |      Returns:
     |          Module: self
     |  
     |  cuda(self, device=None)
     |      Moves all model parameters and buffers to the GPU.
     |      
     |      This also makes associated parameters and buffers different objects. So
     |      it should be called before constructing optimizer if the module will
     |      live on GPU while being optimized.
     |      
     |      Arguments:
     |          device (int, optional): if specified, all parameters will be
     |              copied to that device
     |      
     |      Returns:
     |          Module: self
     |  
     |  double(self)
     |      Casts all floating point parameters and buffers to ``double`` datatype.
     |      
     |      Returns:
     |          Module: self
     |  
     |  eval(self)
     |      Sets the module in evaluation mode.
     |      
     |      This has any effect only on certain modules. See documentations of
     |      particular modules for details of their behaviors in training/evaluation
     |      mode, if they are affected, e.g. :class:`Dropout`, :class:`BatchNorm`,
     |      etc.
     |      
     |      This is equivalent with :meth:`self.train(False) <torch.nn.Module.train>`.
     |      
     |      Returns:
     |          Module: self
     |  
     |  extra_repr(self)
     |      Set the extra representation of the module
     |      
     |      To print customized extra information, you should reimplement
     |      this method in your own modules. Both single-line and multi-line
     |      strings are acceptable.
     |  
     |  float(self)
     |      Casts all floating point parameters and buffers to float datatype.
     |      
     |      Returns:
     |          Module: self
     |  
     |  half(self)
     |      Casts all floating point parameters and buffers to ``half`` datatype.
     |      
     |      Returns:
     |          Module: self
     |  
     |  load_state_dict(self, state_dict, strict=True)
     |      Copies parameters and buffers from :attr:`state_dict` into
     |      this module and its descendants. If :attr:`strict` is ``True``, then
     |      the keys of :attr:`state_dict` must exactly match the keys returned
     |      by this module's :meth:`~torch.nn.Module.state_dict` function.
     |      
     |      Arguments:
     |          state_dict (dict): a dict containing parameters and
     |              persistent buffers.
     |          strict (bool, optional): whether to strictly enforce that the keys
     |              in :attr:`state_dict` match the keys returned by this module's
     |              :meth:`~torch.nn.Module.state_dict` function. Default: ``True``
     |      
     |      Returns:
     |          ``NamedTuple`` with ``missing_keys`` and ``unexpected_keys`` fields:
     |              * **missing_keys** is a list of str containing the missing keys
     |              * **unexpected_keys** is a list of str containing the unexpected keys
     |  
     |  modules(self)
     |      Returns an iterator over all modules in the network.
     |      
     |      Yields:
     |          Module: a module in the network
     |      
     |      Note:
     |          Duplicate modules are returned only once. In the following
     |          example, ``l`` will be returned only once.
     |      
     |      Example::
     |      
     |          >>> l = nn.Linear(2, 2)
     |          >>> net = nn.Sequential(l, l)
     |          >>> for idx, m in enumerate(net.modules()):
     |                  print(idx, '->', m)
     |      
     |          0 -> Sequential(
     |            (0): Linear(in_features=2, out_features=2, bias=True)
     |            (1): Linear(in_features=2, out_features=2, bias=True)
     |          )
     |          1 -> Linear(in_features=2, out_features=2, bias=True)
     |  
     |  named_buffers(self, prefix='', recurse=True)
     |      Returns an iterator over module buffers, yielding both the
     |      name of the buffer as well as the buffer itself.
     |      
     |      Args:
     |          prefix (str): prefix to prepend to all buffer names.
     |          recurse (bool): if True, then yields buffers of this module
     |              and all submodules. Otherwise, yields only buffers that
     |              are direct members of this module.
     |      
     |      Yields:
     |          (string, torch.Tensor): Tuple containing the name and buffer
     |      
     |      Example::
     |      
     |          >>> for name, buf in self.named_buffers():
     |          >>>    if name in ['running_var']:
     |          >>>        print(buf.size())
     |  
     |  named_children(self)
     |      Returns an iterator over immediate children modules, yielding both
     |      the name of the module as well as the module itself.
     |      
     |      Yields:
     |          (string, Module): Tuple containing a name and child module
     |      
     |      Example::
     |      
     |          >>> for name, module in model.named_children():
     |          >>>     if name in ['conv4', 'conv5']:
     |          >>>         print(module)
     |  
     |  named_modules(self, memo=None, prefix='')
     |      Returns an iterator over all modules in the network, yielding
     |      both the name of the module as well as the module itself.
     |      
     |      Yields:
     |          (string, Module): Tuple of name and module
     |      
     |      Note:
     |          Duplicate modules are returned only once. In the following
     |          example, ``l`` will be returned only once.
     |      
     |      Example::
     |      
     |          >>> l = nn.Linear(2, 2)
     |          >>> net = nn.Sequential(l, l)
     |          >>> for idx, m in enumerate(net.named_modules()):
     |                  print(idx, '->', m)
     |      
     |          0 -> ('', Sequential(
     |            (0): Linear(in_features=2, out_features=2, bias=True)
     |            (1): Linear(in_features=2, out_features=2, bias=True)
     |          ))
     |          1 -> ('0', Linear(in_features=2, out_features=2, bias=True))
     |  
     |  named_parameters(self, prefix='', recurse=True)
     |      Returns an iterator over module parameters, yielding both the
     |      name of the parameter as well as the parameter itself.
     |      
     |      Args:
     |          prefix (str): prefix to prepend to all parameter names.
     |          recurse (bool): if True, then yields parameters of this module
     |              and all submodules. Otherwise, yields only parameters that
     |              are direct members of this module.
     |      
     |      Yields:
     |          (string, Parameter): Tuple containing the name and parameter
     |      
     |      Example::
     |      
     |          >>> for name, param in self.named_parameters():
     |          >>>    if name in ['bias']:
     |          >>>        print(param.size())
     |  
     |  parameters(self, recurse=True)
     |      Returns an iterator over module parameters.
     |      
     |      This is typically passed to an optimizer.
     |      
     |      Args:
     |          recurse (bool): if True, then yields parameters of this module
     |              and all submodules. Otherwise, yields only parameters that
     |              are direct members of this module.
     |      
     |      Yields:
     |          Parameter: module parameter
     |      
     |      Example::
     |      
     |          >>> for param in model.parameters():
     |          >>>     print(type(param.data), param.size())
     |          <class 'torch.FloatTensor'> (20L,)
     |          <class 'torch.FloatTensor'> (20L, 1L, 5L, 5L)
     |  
     |  register_backward_hook(self, hook)
     |      Registers a backward hook on the module.
     |      
     |      The hook will be called every time the gradients with respect to module
     |      inputs are computed. The hook should have the following signature::
     |      
     |          hook(module, grad_input, grad_output) -> Tensor or None
     |      
     |      The :attr:`grad_input` and :attr:`grad_output` may be tuples if the
     |      module has multiple inputs or outputs. The hook should not modify its
     |      arguments, but it can optionally return a new gradient with respect to
     |      input that will be used in place of :attr:`grad_input` in subsequent
     |      computations.
     |      
     |      Returns:
     |          :class:`torch.utils.hooks.RemovableHandle`:
     |              a handle that can be used to remove the added hook by calling
     |              ``handle.remove()``
     |      
     |      .. warning ::
     |      
     |          The current implementation will not have the presented behavior
     |          for complex :class:`Module` that perform many operations.
     |          In some failure cases, :attr:`grad_input` and :attr:`grad_output` will only
     |          contain the gradients for a subset of the inputs and outputs.
     |          For such :class:`Module`, you should use :func:`torch.Tensor.register_hook`
     |          directly on a specific input or output to get the required gradients.
     |  
     |  register_buffer(self, name, tensor)
     |      Adds a persistent buffer to the module.
     |      
     |      This is typically used to register a buffer that should not to be
     |      considered a model parameter. For example, BatchNorm's ``running_mean``
     |      is not a parameter, but is part of the persistent state.
     |      
     |      Buffers can be accessed as attributes using given names.
     |      
     |      Args:
     |          name (string): name of the buffer. The buffer can be accessed
     |              from this module using the given name
     |          tensor (Tensor): buffer to be registered.
     |      
     |      Example::
     |      
     |          >>> self.register_buffer('running_mean', torch.zeros(num_features))
     |  
     |  register_forward_hook(self, hook)
     |      Registers a forward hook on the module.
     |      
     |      The hook will be called every time after :func:`forward` has computed an output.
     |      It should have the following signature::
     |      
     |          hook(module, input, output) -> None or modified output
     |      
     |      The hook can modify the output. It can modify the input inplace but
     |      it will not have effect on forward since this is called after
     |      :func:`forward` is called.
     |      
     |      Returns:
     |          :class:`torch.utils.hooks.RemovableHandle`:
     |              a handle that can be used to remove the added hook by calling
     |              ``handle.remove()``
     |  
     |  register_forward_pre_hook(self, hook)
     |      Registers a forward pre-hook on the module.
     |      
     |      The hook will be called every time before :func:`forward` is invoked.
     |      It should have the following signature::
     |      
     |          hook(module, input) -> None or modified input
     |      
     |      The hook can modify the input. User can either return a tuple or a
     |      single modified value in the hook. We will wrap the value into a tuple
     |      if a single value is returned(unless that value is already a tuple).
     |      
     |      Returns:
     |          :class:`torch.utils.hooks.RemovableHandle`:
     |              a handle that can be used to remove the added hook by calling
     |              ``handle.remove()``
     |  
     |  register_parameter(self, name, param)
     |      Adds a parameter to the module.
     |      
     |      The parameter can be accessed as an attribute using given name.
     |      
     |      Args:
     |          name (string): name of the parameter. The parameter can be accessed
     |              from this module using the given name
     |          param (Parameter): parameter to be added to the module.
     |  
     |  requires_grad_(self, requires_grad=True)
     |      Change if autograd should record operations on parameters in this
     |      module.
     |      
     |      This method sets the parameters' :attr:`requires_grad` attributes
     |      in-place.
     |      
     |      This method is helpful for freezing part of the module for finetuning
     |      or training parts of a model individually (e.g., GAN training).
     |      
     |      Args:
     |          requires_grad (bool): whether autograd should record operations on
     |                                parameters in this module. Default: ``True``.
     |      
     |      Returns:
     |          Module: self
     |  
     |  share_memory(self)
     |  
     |  state_dict(self, destination=None, prefix='', keep_vars=False)
     |      Returns a dictionary containing a whole state of the module.
     |      
     |      Both parameters and persistent buffers (e.g. running averages) are
     |      included. Keys are corresponding parameter and buffer names.
     |      
     |      Returns:
     |          dict:
     |              a dictionary containing a whole state of the module
     |      
     |      Example::
     |      
     |          >>> module.state_dict().keys()
     |          ['bias', 'weight']
     |  
     |  to(self, *args, **kwargs)
     |      Moves and/or casts the parameters and buffers.
     |      
     |      This can be called as
     |      
     |      .. function:: to(device=None, dtype=None, non_blocking=False)
     |      
     |      .. function:: to(dtype, non_blocking=False)
     |      
     |      .. function:: to(tensor, non_blocking=False)
     |      
     |      Its signature is similar to :meth:`torch.Tensor.to`, but only accepts
     |      floating point desired :attr:`dtype` s. In addition, this method will
     |      only cast the floating point parameters and buffers to :attr:`dtype`
     |      (if given). The integral parameters and buffers will be moved
     |      :attr:`device`, if that is given, but with dtypes unchanged. When
     |      :attr:`non_blocking` is set, it tries to convert/move asynchronously
     |      with respect to the host if possible, e.g., moving CPU Tensors with
     |      pinned memory to CUDA devices.
     |      
     |      See below for examples.
     |      
     |      .. note::
     |          This method modifies the module in-place.
     |      
     |      Args:
     |          device (:class:`torch.device`): the desired device of the parameters
     |              and buffers in this module
     |          dtype (:class:`torch.dtype`): the desired floating point type of
     |              the floating point parameters and buffers in this module
     |          tensor (torch.Tensor): Tensor whose dtype and device are the desired
     |              dtype and device for all parameters and buffers in this module
     |      
     |      Returns:
     |          Module: self
     |      
     |      Example::
     |      
     |          >>> linear = nn.Linear(2, 2)
     |          >>> linear.weight
     |          Parameter containing:
     |          tensor([[ 0.1913, -0.3420],
     |                  [-0.5113, -0.2325]])
     |          >>> linear.to(torch.double)
     |          Linear(in_features=2, out_features=2, bias=True)
     |          >>> linear.weight
     |          Parameter containing:
     |          tensor([[ 0.1913, -0.3420],
     |                  [-0.5113, -0.2325]], dtype=torch.float64)
     |          >>> gpu1 = torch.device("cuda:1")
     |          >>> linear.to(gpu1, dtype=torch.half, non_blocking=True)
     |          Linear(in_features=2, out_features=2, bias=True)
     |          >>> linear.weight
     |          Parameter containing:
     |          tensor([[ 0.1914, -0.3420],
     |                  [-0.5112, -0.2324]], dtype=torch.float16, device='cuda:1')
     |          >>> cpu = torch.device("cpu")
     |          >>> linear.to(cpu)
     |          Linear(in_features=2, out_features=2, bias=True)
     |          >>> linear.weight
     |          Parameter containing:
     |          tensor([[ 0.1914, -0.3420],
     |                  [-0.5112, -0.2324]], dtype=torch.float16)
     |  
     |  train(self, mode=True)
     |      Sets the module in training mode.
     |      
     |      This has any effect only on certain modules. See documentations of
     |      particular modules for details of their behaviors in training/evaluation
     |      mode, if they are affected, e.g. :class:`Dropout`, :class:`BatchNorm`,
     |      etc.
     |      
     |      Args:
     |          mode (bool): whether to set training mode (``True``) or evaluation
     |                       mode (``False``). Default: ``True``.
     |      
     |      Returns:
     |          Module: self
     |  
     |  type(self, dst_type)
     |      Casts all parameters and buffers to :attr:`dst_type`.
     |      
     |      Arguments:
     |          dst_type (type or string): the desired type
     |      
     |      Returns:
     |          Module: self
     |  
     |  zero_grad(self)
     |      Sets gradients of all model parameters to zero.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from torch.nn.modules.module.Module:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from torch.nn.modules.module.Module:
     |  
     |  dump_patches = False
    
    class NoopSub(torch.nn.modules.module.Module)
     |  NoopSub(*args, sub=None, **kw)
     |  
     |  Noop wrap-around module (for testing/exploration).
     |  
     |  Method resolution order:
     |      NoopSub
     |      torch.nn.modules.module.Module
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, *args, sub=None, **kw)
     |      Initializes internal Module state, shared by both nn.Module and ScriptModule.
     |  
     |  forward(self, x)
     |      Defines the computation performed at every call.
     |      
     |      Should be overridden by all subclasses.
     |      
     |      .. note::
     |          Although the recipe for forward pass needs to be defined within
     |          this function, one should call the :class:`Module` instance afterwards
     |          instead of this since the former takes care of running the
     |          registered hooks while the latter silently ignores them.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from torch.nn.modules.module.Module:
     |  
     |  __call__(self, *input, **kwargs)
     |      Call self as a function.
     |  
     |  __delattr__(self, name)
     |      Implement delattr(self, name).
     |  
     |  __dir__(self)
     |      Default dir() implementation.
     |  
     |  __getattr__(self, name)
     |  
     |  __repr__(self)
     |      Return repr(self).
     |  
     |  __setattr__(self, name, value)
     |      Implement setattr(self, name, value).
     |  
     |  __setstate__(self, state)
     |  
     |  add_module(self, name, module)
     |      Adds a child module to the current module.
     |      
     |      The module can be accessed as an attribute using the given name.
     |      
     |      Args:
     |          name (string): name of the child module. The child module can be
     |              accessed from this module using the given name
     |          module (Module): child module to be added to the module.
     |  
     |  apply(self, fn)
     |      Applies ``fn`` recursively to every submodule (as returned by ``.children()``)
     |      as well as self. Typical use includes initializing the parameters of a model
     |      (see also :ref:`nn-init-doc`).
     |      
     |      Args:
     |          fn (:class:`Module` -> None): function to be applied to each submodule
     |      
     |      Returns:
     |          Module: self
     |      
     |      Example::
     |      
     |          >>> def init_weights(m):
     |          >>>     print(m)
     |          >>>     if type(m) == nn.Linear:
     |          >>>         m.weight.data.fill_(1.0)
     |          >>>         print(m.weight)
     |          >>> net = nn.Sequential(nn.Linear(2, 2), nn.Linear(2, 2))
     |          >>> net.apply(init_weights)
     |          Linear(in_features=2, out_features=2, bias=True)
     |          Parameter containing:
     |          tensor([[ 1.,  1.],
     |                  [ 1.,  1.]])
     |          Linear(in_features=2, out_features=2, bias=True)
     |          Parameter containing:
     |          tensor([[ 1.,  1.],
     |                  [ 1.,  1.]])
     |          Sequential(
     |            (0): Linear(in_features=2, out_features=2, bias=True)
     |            (1): Linear(in_features=2, out_features=2, bias=True)
     |          )
     |          Sequential(
     |            (0): Linear(in_features=2, out_features=2, bias=True)
     |            (1): Linear(in_features=2, out_features=2, bias=True)
     |          )
     |  
     |  buffers(self, recurse=True)
     |      Returns an iterator over module buffers.
     |      
     |      Args:
     |          recurse (bool): if True, then yields buffers of this module
     |              and all submodules. Otherwise, yields only buffers that
     |              are direct members of this module.
     |      
     |      Yields:
     |          torch.Tensor: module buffer
     |      
     |      Example::
     |      
     |          >>> for buf in model.buffers():
     |          >>>     print(type(buf.data), buf.size())
     |          <class 'torch.FloatTensor'> (20L,)
     |          <class 'torch.FloatTensor'> (20L, 1L, 5L, 5L)
     |  
     |  children(self)
     |      Returns an iterator over immediate children modules.
     |      
     |      Yields:
     |          Module: a child module
     |  
     |  cpu(self)
     |      Moves all model parameters and buffers to the CPU.
     |      
     |      Returns:
     |          Module: self
     |  
     |  cuda(self, device=None)
     |      Moves all model parameters and buffers to the GPU.
     |      
     |      This also makes associated parameters and buffers different objects. So
     |      it should be called before constructing optimizer if the module will
     |      live on GPU while being optimized.
     |      
     |      Arguments:
     |          device (int, optional): if specified, all parameters will be
     |              copied to that device
     |      
     |      Returns:
     |          Module: self
     |  
     |  double(self)
     |      Casts all floating point parameters and buffers to ``double`` datatype.
     |      
     |      Returns:
     |          Module: self
     |  
     |  eval(self)
     |      Sets the module in evaluation mode.
     |      
     |      This has any effect only on certain modules. See documentations of
     |      particular modules for details of their behaviors in training/evaluation
     |      mode, if they are affected, e.g. :class:`Dropout`, :class:`BatchNorm`,
     |      etc.
     |      
     |      This is equivalent with :meth:`self.train(False) <torch.nn.Module.train>`.
     |      
     |      Returns:
     |          Module: self
     |  
     |  extra_repr(self)
     |      Set the extra representation of the module
     |      
     |      To print customized extra information, you should reimplement
     |      this method in your own modules. Both single-line and multi-line
     |      strings are acceptable.
     |  
     |  float(self)
     |      Casts all floating point parameters and buffers to float datatype.
     |      
     |      Returns:
     |          Module: self
     |  
     |  half(self)
     |      Casts all floating point parameters and buffers to ``half`` datatype.
     |      
     |      Returns:
     |          Module: self
     |  
     |  load_state_dict(self, state_dict, strict=True)
     |      Copies parameters and buffers from :attr:`state_dict` into
     |      this module and its descendants. If :attr:`strict` is ``True``, then
     |      the keys of :attr:`state_dict` must exactly match the keys returned
     |      by this module's :meth:`~torch.nn.Module.state_dict` function.
     |      
     |      Arguments:
     |          state_dict (dict): a dict containing parameters and
     |              persistent buffers.
     |          strict (bool, optional): whether to strictly enforce that the keys
     |              in :attr:`state_dict` match the keys returned by this module's
     |              :meth:`~torch.nn.Module.state_dict` function. Default: ``True``
     |      
     |      Returns:
     |          ``NamedTuple`` with ``missing_keys`` and ``unexpected_keys`` fields:
     |              * **missing_keys** is a list of str containing the missing keys
     |              * **unexpected_keys** is a list of str containing the unexpected keys
     |  
     |  modules(self)
     |      Returns an iterator over all modules in the network.
     |      
     |      Yields:
     |          Module: a module in the network
     |      
     |      Note:
     |          Duplicate modules are returned only once. In the following
     |          example, ``l`` will be returned only once.
     |      
     |      Example::
     |      
     |          >>> l = nn.Linear(2, 2)
     |          >>> net = nn.Sequential(l, l)
     |          >>> for idx, m in enumerate(net.modules()):
     |                  print(idx, '->', m)
     |      
     |          0 -> Sequential(
     |            (0): Linear(in_features=2, out_features=2, bias=True)
     |            (1): Linear(in_features=2, out_features=2, bias=True)
     |          )
     |          1 -> Linear(in_features=2, out_features=2, bias=True)
     |  
     |  named_buffers(self, prefix='', recurse=True)
     |      Returns an iterator over module buffers, yielding both the
     |      name of the buffer as well as the buffer itself.
     |      
     |      Args:
     |          prefix (str): prefix to prepend to all buffer names.
     |          recurse (bool): if True, then yields buffers of this module
     |              and all submodules. Otherwise, yields only buffers that
     |              are direct members of this module.
     |      
     |      Yields:
     |          (string, torch.Tensor): Tuple containing the name and buffer
     |      
     |      Example::
     |      
     |          >>> for name, buf in self.named_buffers():
     |          >>>    if name in ['running_var']:
     |          >>>        print(buf.size())
     |  
     |  named_children(self)
     |      Returns an iterator over immediate children modules, yielding both
     |      the name of the module as well as the module itself.
     |      
     |      Yields:
     |          (string, Module): Tuple containing a name and child module
     |      
     |      Example::
     |      
     |          >>> for name, module in model.named_children():
     |          >>>     if name in ['conv4', 'conv5']:
     |          >>>         print(module)
     |  
     |  named_modules(self, memo=None, prefix='')
     |      Returns an iterator over all modules in the network, yielding
     |      both the name of the module as well as the module itself.
     |      
     |      Yields:
     |          (string, Module): Tuple of name and module
     |      
     |      Note:
     |          Duplicate modules are returned only once. In the following
     |          example, ``l`` will be returned only once.
     |      
     |      Example::
     |      
     |          >>> l = nn.Linear(2, 2)
     |          >>> net = nn.Sequential(l, l)
     |          >>> for idx, m in enumerate(net.named_modules()):
     |                  print(idx, '->', m)
     |      
     |          0 -> ('', Sequential(
     |            (0): Linear(in_features=2, out_features=2, bias=True)
     |            (1): Linear(in_features=2, out_features=2, bias=True)
     |          ))
     |          1 -> ('0', Linear(in_features=2, out_features=2, bias=True))
     |  
     |  named_parameters(self, prefix='', recurse=True)
     |      Returns an iterator over module parameters, yielding both the
     |      name of the parameter as well as the parameter itself.
     |      
     |      Args:
     |          prefix (str): prefix to prepend to all parameter names.
     |          recurse (bool): if True, then yields parameters of this module
     |              and all submodules. Otherwise, yields only parameters that
     |              are direct members of this module.
     |      
     |      Yields:
     |          (string, Parameter): Tuple containing the name and parameter
     |      
     |      Example::
     |      
     |          >>> for name, param in self.named_parameters():
     |          >>>    if name in ['bias']:
     |          >>>        print(param.size())
     |  
     |  parameters(self, recurse=True)
     |      Returns an iterator over module parameters.
     |      
     |      This is typically passed to an optimizer.
     |      
     |      Args:
     |          recurse (bool): if True, then yields parameters of this module
     |              and all submodules. Otherwise, yields only parameters that
     |              are direct members of this module.
     |      
     |      Yields:
     |          Parameter: module parameter
     |      
     |      Example::
     |      
     |          >>> for param in model.parameters():
     |          >>>     print(type(param.data), param.size())
     |          <class 'torch.FloatTensor'> (20L,)
     |          <class 'torch.FloatTensor'> (20L, 1L, 5L, 5L)
     |  
     |  register_backward_hook(self, hook)
     |      Registers a backward hook on the module.
     |      
     |      The hook will be called every time the gradients with respect to module
     |      inputs are computed. The hook should have the following signature::
     |      
     |          hook(module, grad_input, grad_output) -> Tensor or None
     |      
     |      The :attr:`grad_input` and :attr:`grad_output` may be tuples if the
     |      module has multiple inputs or outputs. The hook should not modify its
     |      arguments, but it can optionally return a new gradient with respect to
     |      input that will be used in place of :attr:`grad_input` in subsequent
     |      computations.
     |      
     |      Returns:
     |          :class:`torch.utils.hooks.RemovableHandle`:
     |              a handle that can be used to remove the added hook by calling
     |              ``handle.remove()``
     |      
     |      .. warning ::
     |      
     |          The current implementation will not have the presented behavior
     |          for complex :class:`Module` that perform many operations.
     |          In some failure cases, :attr:`grad_input` and :attr:`grad_output` will only
     |          contain the gradients for a subset of the inputs and outputs.
     |          For such :class:`Module`, you should use :func:`torch.Tensor.register_hook`
     |          directly on a specific input or output to get the required gradients.
     |  
     |  register_buffer(self, name, tensor)
     |      Adds a persistent buffer to the module.
     |      
     |      This is typically used to register a buffer that should not to be
     |      considered a model parameter. For example, BatchNorm's ``running_mean``
     |      is not a parameter, but is part of the persistent state.
     |      
     |      Buffers can be accessed as attributes using given names.
     |      
     |      Args:
     |          name (string): name of the buffer. The buffer can be accessed
     |              from this module using the given name
     |          tensor (Tensor): buffer to be registered.
     |      
     |      Example::
     |      
     |          >>> self.register_buffer('running_mean', torch.zeros(num_features))
     |  
     |  register_forward_hook(self, hook)
     |      Registers a forward hook on the module.
     |      
     |      The hook will be called every time after :func:`forward` has computed an output.
     |      It should have the following signature::
     |      
     |          hook(module, input, output) -> None or modified output
     |      
     |      The hook can modify the output. It can modify the input inplace but
     |      it will not have effect on forward since this is called after
     |      :func:`forward` is called.
     |      
     |      Returns:
     |          :class:`torch.utils.hooks.RemovableHandle`:
     |              a handle that can be used to remove the added hook by calling
     |              ``handle.remove()``
     |  
     |  register_forward_pre_hook(self, hook)
     |      Registers a forward pre-hook on the module.
     |      
     |      The hook will be called every time before :func:`forward` is invoked.
     |      It should have the following signature::
     |      
     |          hook(module, input) -> None or modified input
     |      
     |      The hook can modify the input. User can either return a tuple or a
     |      single modified value in the hook. We will wrap the value into a tuple
     |      if a single value is returned(unless that value is already a tuple).
     |      
     |      Returns:
     |          :class:`torch.utils.hooks.RemovableHandle`:
     |              a handle that can be used to remove the added hook by calling
     |              ``handle.remove()``
     |  
     |  register_parameter(self, name, param)
     |      Adds a parameter to the module.
     |      
     |      The parameter can be accessed as an attribute using given name.
     |      
     |      Args:
     |          name (string): name of the parameter. The parameter can be accessed
     |              from this module using the given name
     |          param (Parameter): parameter to be added to the module.
     |  
     |  requires_grad_(self, requires_grad=True)
     |      Change if autograd should record operations on parameters in this
     |      module.
     |      
     |      This method sets the parameters' :attr:`requires_grad` attributes
     |      in-place.
     |      
     |      This method is helpful for freezing part of the module for finetuning
     |      or training parts of a model individually (e.g., GAN training).
     |      
     |      Args:
     |          requires_grad (bool): whether autograd should record operations on
     |                                parameters in this module. Default: ``True``.
     |      
     |      Returns:
     |          Module: self
     |  
     |  share_memory(self)
     |  
     |  state_dict(self, destination=None, prefix='', keep_vars=False)
     |      Returns a dictionary containing a whole state of the module.
     |      
     |      Both parameters and persistent buffers (e.g. running averages) are
     |      included. Keys are corresponding parameter and buffer names.
     |      
     |      Returns:
     |          dict:
     |              a dictionary containing a whole state of the module
     |      
     |      Example::
     |      
     |          >>> module.state_dict().keys()
     |          ['bias', 'weight']
     |  
     |  to(self, *args, **kwargs)
     |      Moves and/or casts the parameters and buffers.
     |      
     |      This can be called as
     |      
     |      .. function:: to(device=None, dtype=None, non_blocking=False)
     |      
     |      .. function:: to(dtype, non_blocking=False)
     |      
     |      .. function:: to(tensor, non_blocking=False)
     |      
     |      Its signature is similar to :meth:`torch.Tensor.to`, but only accepts
     |      floating point desired :attr:`dtype` s. In addition, this method will
     |      only cast the floating point parameters and buffers to :attr:`dtype`
     |      (if given). The integral parameters and buffers will be moved
     |      :attr:`device`, if that is given, but with dtypes unchanged. When
     |      :attr:`non_blocking` is set, it tries to convert/move asynchronously
     |      with respect to the host if possible, e.g., moving CPU Tensors with
     |      pinned memory to CUDA devices.
     |      
     |      See below for examples.
     |      
     |      .. note::
     |          This method modifies the module in-place.
     |      
     |      Args:
     |          device (:class:`torch.device`): the desired device of the parameters
     |              and buffers in this module
     |          dtype (:class:`torch.dtype`): the desired floating point type of
     |              the floating point parameters and buffers in this module
     |          tensor (torch.Tensor): Tensor whose dtype and device are the desired
     |              dtype and device for all parameters and buffers in this module
     |      
     |      Returns:
     |          Module: self
     |      
     |      Example::
     |      
     |          >>> linear = nn.Linear(2, 2)
     |          >>> linear.weight
     |          Parameter containing:
     |          tensor([[ 0.1913, -0.3420],
     |                  [-0.5113, -0.2325]])
     |          >>> linear.to(torch.double)
     |          Linear(in_features=2, out_features=2, bias=True)
     |          >>> linear.weight
     |          Parameter containing:
     |          tensor([[ 0.1913, -0.3420],
     |                  [-0.5113, -0.2325]], dtype=torch.float64)
     |          >>> gpu1 = torch.device("cuda:1")
     |          >>> linear.to(gpu1, dtype=torch.half, non_blocking=True)
     |          Linear(in_features=2, out_features=2, bias=True)
     |          >>> linear.weight
     |          Parameter containing:
     |          tensor([[ 0.1914, -0.3420],
     |                  [-0.5112, -0.2324]], dtype=torch.float16, device='cuda:1')
     |          >>> cpu = torch.device("cpu")
     |          >>> linear.to(cpu)
     |          Linear(in_features=2, out_features=2, bias=True)
     |          >>> linear.weight
     |          Parameter containing:
     |          tensor([[ 0.1914, -0.3420],
     |                  [-0.5112, -0.2324]], dtype=torch.float16)
     |  
     |  train(self, mode=True)
     |      Sets the module in training mode.
     |      
     |      This has any effect only on certain modules. See documentations of
     |      particular modules for details of their behaviors in training/evaluation
     |      mode, if they are affected, e.g. :class:`Dropout`, :class:`BatchNorm`,
     |      etc.
     |      
     |      Args:
     |          mode (bool): whether to set training mode (``True``) or evaluation
     |                       mode (``False``). Default: ``True``.
     |      
     |      Returns:
     |          Module: self
     |  
     |  type(self, dst_type)
     |      Casts all parameters and buffers to :attr:`dst_type`.
     |      
     |      Arguments:
     |          dst_type (type or string): the desired type
     |      
     |      Returns:
     |          Module: self
     |  
     |  zero_grad(self)
     |      Sets gradients of all model parameters to zero.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from torch.nn.modules.module.Module:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from torch.nn.modules.module.Module:
     |  
     |  dump_patches = False
    
    class Parallel(torch.nn.modules.module.Module)
     |  Parallel(*args, dim=1)
     |  
     |  Run modules in parallel and concatenate the results.
     |  
     |  Method resolution order:
     |      Parallel
     |      torch.nn.modules.module.Module
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, *args, dim=1)
     |      Initializes internal Module state, shared by both nn.Module and ScriptModule.
     |  
     |  forward(self, x)
     |      Defines the computation performed at every call.
     |      
     |      Should be overridden by all subclasses.
     |      
     |      .. note::
     |          Although the recipe for forward pass needs to be defined within
     |          this function, one should call the :class:`Module` instance afterwards
     |          instead of this since the former takes care of running the
     |          registered hooks while the latter silently ignores them.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from torch.nn.modules.module.Module:
     |  
     |  __call__(self, *input, **kwargs)
     |      Call self as a function.
     |  
     |  __delattr__(self, name)
     |      Implement delattr(self, name).
     |  
     |  __dir__(self)
     |      Default dir() implementation.
     |  
     |  __getattr__(self, name)
     |  
     |  __repr__(self)
     |      Return repr(self).
     |  
     |  __setattr__(self, name, value)
     |      Implement setattr(self, name, value).
     |  
     |  __setstate__(self, state)
     |  
     |  add_module(self, name, module)
     |      Adds a child module to the current module.
     |      
     |      The module can be accessed as an attribute using the given name.
     |      
     |      Args:
     |          name (string): name of the child module. The child module can be
     |              accessed from this module using the given name
     |          module (Module): child module to be added to the module.
     |  
     |  apply(self, fn)
     |      Applies ``fn`` recursively to every submodule (as returned by ``.children()``)
     |      as well as self. Typical use includes initializing the parameters of a model
     |      (see also :ref:`nn-init-doc`).
     |      
     |      Args:
     |          fn (:class:`Module` -> None): function to be applied to each submodule
     |      
     |      Returns:
     |          Module: self
     |      
     |      Example::
     |      
     |          >>> def init_weights(m):
     |          >>>     print(m)
     |          >>>     if type(m) == nn.Linear:
     |          >>>         m.weight.data.fill_(1.0)
     |          >>>         print(m.weight)
     |          >>> net = nn.Sequential(nn.Linear(2, 2), nn.Linear(2, 2))
     |          >>> net.apply(init_weights)
     |          Linear(in_features=2, out_features=2, bias=True)
     |          Parameter containing:
     |          tensor([[ 1.,  1.],
     |                  [ 1.,  1.]])
     |          Linear(in_features=2, out_features=2, bias=True)
     |          Parameter containing:
     |          tensor([[ 1.,  1.],
     |                  [ 1.,  1.]])
     |          Sequential(
     |            (0): Linear(in_features=2, out_features=2, bias=True)
     |            (1): Linear(in_features=2, out_features=2, bias=True)
     |          )
     |          Sequential(
     |            (0): Linear(in_features=2, out_features=2, bias=True)
     |            (1): Linear(in_features=2, out_features=2, bias=True)
     |          )
     |  
     |  buffers(self, recurse=True)
     |      Returns an iterator over module buffers.
     |      
     |      Args:
     |          recurse (bool): if True, then yields buffers of this module
     |              and all submodules. Otherwise, yields only buffers that
     |              are direct members of this module.
     |      
     |      Yields:
     |          torch.Tensor: module buffer
     |      
     |      Example::
     |      
     |          >>> for buf in model.buffers():
     |          >>>     print(type(buf.data), buf.size())
     |          <class 'torch.FloatTensor'> (20L,)
     |          <class 'torch.FloatTensor'> (20L, 1L, 5L, 5L)
     |  
     |  children(self)
     |      Returns an iterator over immediate children modules.
     |      
     |      Yields:
     |          Module: a child module
     |  
     |  cpu(self)
     |      Moves all model parameters and buffers to the CPU.
     |      
     |      Returns:
     |          Module: self
     |  
     |  cuda(self, device=None)
     |      Moves all model parameters and buffers to the GPU.
     |      
     |      This also makes associated parameters and buffers different objects. So
     |      it should be called before constructing optimizer if the module will
     |      live on GPU while being optimized.
     |      
     |      Arguments:
     |          device (int, optional): if specified, all parameters will be
     |              copied to that device
     |      
     |      Returns:
     |          Module: self
     |  
     |  double(self)
     |      Casts all floating point parameters and buffers to ``double`` datatype.
     |      
     |      Returns:
     |          Module: self
     |  
     |  eval(self)
     |      Sets the module in evaluation mode.
     |      
     |      This has any effect only on certain modules. See documentations of
     |      particular modules for details of their behaviors in training/evaluation
     |      mode, if they are affected, e.g. :class:`Dropout`, :class:`BatchNorm`,
     |      etc.
     |      
     |      This is equivalent with :meth:`self.train(False) <torch.nn.Module.train>`.
     |      
     |      Returns:
     |          Module: self
     |  
     |  extra_repr(self)
     |      Set the extra representation of the module
     |      
     |      To print customized extra information, you should reimplement
     |      this method in your own modules. Both single-line and multi-line
     |      strings are acceptable.
     |  
     |  float(self)
     |      Casts all floating point parameters and buffers to float datatype.
     |      
     |      Returns:
     |          Module: self
     |  
     |  half(self)
     |      Casts all floating point parameters and buffers to ``half`` datatype.
     |      
     |      Returns:
     |          Module: self
     |  
     |  load_state_dict(self, state_dict, strict=True)
     |      Copies parameters and buffers from :attr:`state_dict` into
     |      this module and its descendants. If :attr:`strict` is ``True``, then
     |      the keys of :attr:`state_dict` must exactly match the keys returned
     |      by this module's :meth:`~torch.nn.Module.state_dict` function.
     |      
     |      Arguments:
     |          state_dict (dict): a dict containing parameters and
     |              persistent buffers.
     |          strict (bool, optional): whether to strictly enforce that the keys
     |              in :attr:`state_dict` match the keys returned by this module's
     |              :meth:`~torch.nn.Module.state_dict` function. Default: ``True``
     |      
     |      Returns:
     |          ``NamedTuple`` with ``missing_keys`` and ``unexpected_keys`` fields:
     |              * **missing_keys** is a list of str containing the missing keys
     |              * **unexpected_keys** is a list of str containing the unexpected keys
     |  
     |  modules(self)
     |      Returns an iterator over all modules in the network.
     |      
     |      Yields:
     |          Module: a module in the network
     |      
     |      Note:
     |          Duplicate modules are returned only once. In the following
     |          example, ``l`` will be returned only once.
     |      
     |      Example::
     |      
     |          >>> l = nn.Linear(2, 2)
     |          >>> net = nn.Sequential(l, l)
     |          >>> for idx, m in enumerate(net.modules()):
     |                  print(idx, '->', m)
     |      
     |          0 -> Sequential(
     |            (0): Linear(in_features=2, out_features=2, bias=True)
     |            (1): Linear(in_features=2, out_features=2, bias=True)
     |          )
     |          1 -> Linear(in_features=2, out_features=2, bias=True)
     |  
     |  named_buffers(self, prefix='', recurse=True)
     |      Returns an iterator over module buffers, yielding both the
     |      name of the buffer as well as the buffer itself.
     |      
     |      Args:
     |          prefix (str): prefix to prepend to all buffer names.
     |          recurse (bool): if True, then yields buffers of this module
     |              and all submodules. Otherwise, yields only buffers that
     |              are direct members of this module.
     |      
     |      Yields:
     |          (string, torch.Tensor): Tuple containing the name and buffer
     |      
     |      Example::
     |      
     |          >>> for name, buf in self.named_buffers():
     |          >>>    if name in ['running_var']:
     |          >>>        print(buf.size())
     |  
     |  named_children(self)
     |      Returns an iterator over immediate children modules, yielding both
     |      the name of the module as well as the module itself.
     |      
     |      Yields:
     |          (string, Module): Tuple containing a name and child module
     |      
     |      Example::
     |      
     |          >>> for name, module in model.named_children():
     |          >>>     if name in ['conv4', 'conv5']:
     |          >>>         print(module)
     |  
     |  named_modules(self, memo=None, prefix='')
     |      Returns an iterator over all modules in the network, yielding
     |      both the name of the module as well as the module itself.
     |      
     |      Yields:
     |          (string, Module): Tuple of name and module
     |      
     |      Note:
     |          Duplicate modules are returned only once. In the following
     |          example, ``l`` will be returned only once.
     |      
     |      Example::
     |      
     |          >>> l = nn.Linear(2, 2)
     |          >>> net = nn.Sequential(l, l)
     |          >>> for idx, m in enumerate(net.named_modules()):
     |                  print(idx, '->', m)
     |      
     |          0 -> ('', Sequential(
     |            (0): Linear(in_features=2, out_features=2, bias=True)
     |            (1): Linear(in_features=2, out_features=2, bias=True)
     |          ))
     |          1 -> ('0', Linear(in_features=2, out_features=2, bias=True))
     |  
     |  named_parameters(self, prefix='', recurse=True)
     |      Returns an iterator over module parameters, yielding both the
     |      name of the parameter as well as the parameter itself.
     |      
     |      Args:
     |          prefix (str): prefix to prepend to all parameter names.
     |          recurse (bool): if True, then yields parameters of this module
     |              and all submodules. Otherwise, yields only parameters that
     |              are direct members of this module.
     |      
     |      Yields:
     |          (string, Parameter): Tuple containing the name and parameter
     |      
     |      Example::
     |      
     |          >>> for name, param in self.named_parameters():
     |          >>>    if name in ['bias']:
     |          >>>        print(param.size())
     |  
     |  parameters(self, recurse=True)
     |      Returns an iterator over module parameters.
     |      
     |      This is typically passed to an optimizer.
     |      
     |      Args:
     |          recurse (bool): if True, then yields parameters of this module
     |              and all submodules. Otherwise, yields only parameters that
     |              are direct members of this module.
     |      
     |      Yields:
     |          Parameter: module parameter
     |      
     |      Example::
     |      
     |          >>> for param in model.parameters():
     |          >>>     print(type(param.data), param.size())
     |          <class 'torch.FloatTensor'> (20L,)
     |          <class 'torch.FloatTensor'> (20L, 1L, 5L, 5L)
     |  
     |  register_backward_hook(self, hook)
     |      Registers a backward hook on the module.
     |      
     |      The hook will be called every time the gradients with respect to module
     |      inputs are computed. The hook should have the following signature::
     |      
     |          hook(module, grad_input, grad_output) -> Tensor or None
     |      
     |      The :attr:`grad_input` and :attr:`grad_output` may be tuples if the
     |      module has multiple inputs or outputs. The hook should not modify its
     |      arguments, but it can optionally return a new gradient with respect to
     |      input that will be used in place of :attr:`grad_input` in subsequent
     |      computations.
     |      
     |      Returns:
     |          :class:`torch.utils.hooks.RemovableHandle`:
     |              a handle that can be used to remove the added hook by calling
     |              ``handle.remove()``
     |      
     |      .. warning ::
     |      
     |          The current implementation will not have the presented behavior
     |          for complex :class:`Module` that perform many operations.
     |          In some failure cases, :attr:`grad_input` and :attr:`grad_output` will only
     |          contain the gradients for a subset of the inputs and outputs.
     |          For such :class:`Module`, you should use :func:`torch.Tensor.register_hook`
     |          directly on a specific input or output to get the required gradients.
     |  
     |  register_buffer(self, name, tensor)
     |      Adds a persistent buffer to the module.
     |      
     |      This is typically used to register a buffer that should not to be
     |      considered a model parameter. For example, BatchNorm's ``running_mean``
     |      is not a parameter, but is part of the persistent state.
     |      
     |      Buffers can be accessed as attributes using given names.
     |      
     |      Args:
     |          name (string): name of the buffer. The buffer can be accessed
     |              from this module using the given name
     |          tensor (Tensor): buffer to be registered.
     |      
     |      Example::
     |      
     |          >>> self.register_buffer('running_mean', torch.zeros(num_features))
     |  
     |  register_forward_hook(self, hook)
     |      Registers a forward hook on the module.
     |      
     |      The hook will be called every time after :func:`forward` has computed an output.
     |      It should have the following signature::
     |      
     |          hook(module, input, output) -> None or modified output
     |      
     |      The hook can modify the output. It can modify the input inplace but
     |      it will not have effect on forward since this is called after
     |      :func:`forward` is called.
     |      
     |      Returns:
     |          :class:`torch.utils.hooks.RemovableHandle`:
     |              a handle that can be used to remove the added hook by calling
     |              ``handle.remove()``
     |  
     |  register_forward_pre_hook(self, hook)
     |      Registers a forward pre-hook on the module.
     |      
     |      The hook will be called every time before :func:`forward` is invoked.
     |      It should have the following signature::
     |      
     |          hook(module, input) -> None or modified input
     |      
     |      The hook can modify the input. User can either return a tuple or a
     |      single modified value in the hook. We will wrap the value into a tuple
     |      if a single value is returned(unless that value is already a tuple).
     |      
     |      Returns:
     |          :class:`torch.utils.hooks.RemovableHandle`:
     |              a handle that can be used to remove the added hook by calling
     |              ``handle.remove()``
     |  
     |  register_parameter(self, name, param)
     |      Adds a parameter to the module.
     |      
     |      The parameter can be accessed as an attribute using given name.
     |      
     |      Args:
     |          name (string): name of the parameter. The parameter can be accessed
     |              from this module using the given name
     |          param (Parameter): parameter to be added to the module.
     |  
     |  requires_grad_(self, requires_grad=True)
     |      Change if autograd should record operations on parameters in this
     |      module.
     |      
     |      This method sets the parameters' :attr:`requires_grad` attributes
     |      in-place.
     |      
     |      This method is helpful for freezing part of the module for finetuning
     |      or training parts of a model individually (e.g., GAN training).
     |      
     |      Args:
     |          requires_grad (bool): whether autograd should record operations on
     |                                parameters in this module. Default: ``True``.
     |      
     |      Returns:
     |          Module: self
     |  
     |  share_memory(self)
     |  
     |  state_dict(self, destination=None, prefix='', keep_vars=False)
     |      Returns a dictionary containing a whole state of the module.
     |      
     |      Both parameters and persistent buffers (e.g. running averages) are
     |      included. Keys are corresponding parameter and buffer names.
     |      
     |      Returns:
     |          dict:
     |              a dictionary containing a whole state of the module
     |      
     |      Example::
     |      
     |          >>> module.state_dict().keys()
     |          ['bias', 'weight']
     |  
     |  to(self, *args, **kwargs)
     |      Moves and/or casts the parameters and buffers.
     |      
     |      This can be called as
     |      
     |      .. function:: to(device=None, dtype=None, non_blocking=False)
     |      
     |      .. function:: to(dtype, non_blocking=False)
     |      
     |      .. function:: to(tensor, non_blocking=False)
     |      
     |      Its signature is similar to :meth:`torch.Tensor.to`, but only accepts
     |      floating point desired :attr:`dtype` s. In addition, this method will
     |      only cast the floating point parameters and buffers to :attr:`dtype`
     |      (if given). The integral parameters and buffers will be moved
     |      :attr:`device`, if that is given, but with dtypes unchanged. When
     |      :attr:`non_blocking` is set, it tries to convert/move asynchronously
     |      with respect to the host if possible, e.g., moving CPU Tensors with
     |      pinned memory to CUDA devices.
     |      
     |      See below for examples.
     |      
     |      .. note::
     |          This method modifies the module in-place.
     |      
     |      Args:
     |          device (:class:`torch.device`): the desired device of the parameters
     |              and buffers in this module
     |          dtype (:class:`torch.dtype`): the desired floating point type of
     |              the floating point parameters and buffers in this module
     |          tensor (torch.Tensor): Tensor whose dtype and device are the desired
     |              dtype and device for all parameters and buffers in this module
     |      
     |      Returns:
     |          Module: self
     |      
     |      Example::
     |      
     |          >>> linear = nn.Linear(2, 2)
     |          >>> linear.weight
     |          Parameter containing:
     |          tensor([[ 0.1913, -0.3420],
     |                  [-0.5113, -0.2325]])
     |          >>> linear.to(torch.double)
     |          Linear(in_features=2, out_features=2, bias=True)
     |          >>> linear.weight
     |          Parameter containing:
     |          tensor([[ 0.1913, -0.3420],
     |                  [-0.5113, -0.2325]], dtype=torch.float64)
     |          >>> gpu1 = torch.device("cuda:1")
     |          >>> linear.to(gpu1, dtype=torch.half, non_blocking=True)
     |          Linear(in_features=2, out_features=2, bias=True)
     |          >>> linear.weight
     |          Parameter containing:
     |          tensor([[ 0.1914, -0.3420],
     |                  [-0.5112, -0.2324]], dtype=torch.float16, device='cuda:1')
     |          >>> cpu = torch.device("cpu")
     |          >>> linear.to(cpu)
     |          Linear(in_features=2, out_features=2, bias=True)
     |          >>> linear.weight
     |          Parameter containing:
     |          tensor([[ 0.1914, -0.3420],
     |                  [-0.5112, -0.2324]], dtype=torch.float16)
     |  
     |  train(self, mode=True)
     |      Sets the module in training mode.
     |      
     |      This has any effect only on certain modules. See documentations of
     |      particular modules for details of their behaviors in training/evaluation
     |      mode, if they are affected, e.g. :class:`Dropout`, :class:`BatchNorm`,
     |      etc.
     |      
     |      Args:
     |          mode (bool): whether to set training mode (``True``) or evaluation
     |                       mode (``False``). Default: ``True``.
     |      
     |      Returns:
     |          Module: self
     |  
     |  type(self, dst_type)
     |      Casts all parameters and buffers to :attr:`dst_type`.
     |      
     |      Arguments:
     |          dst_type (type or string): the desired type
     |      
     |      Returns:
     |          Module: self
     |  
     |  zero_grad(self)
     |      Sets gradients of all model parameters to zero.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from torch.nn.modules.module.Module:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from torch.nn.modules.module.Module:
     |  
     |  dump_patches = False
    
    class Permute(torch.nn.modules.module.Module)
     |  Permute(*args)
     |  
     |  Permute the dimensions of the input tensor.
     |  
     |  Method resolution order:
     |      Permute
     |      torch.nn.modules.module.Module
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, *args)
     |      Initializes internal Module state, shared by both nn.Module and ScriptModule.
     |  
     |  __repr__(self)
     |      Return repr(self).
     |  
     |  forward(self, x)
     |      Defines the computation performed at every call.
     |      
     |      Should be overridden by all subclasses.
     |      
     |      .. note::
     |          Although the recipe for forward pass needs to be defined within
     |          this function, one should call the :class:`Module` instance afterwards
     |          instead of this since the former takes care of running the
     |          registered hooks while the latter silently ignores them.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from torch.nn.modules.module.Module:
     |  
     |  __call__(self, *input, **kwargs)
     |      Call self as a function.
     |  
     |  __delattr__(self, name)
     |      Implement delattr(self, name).
     |  
     |  __dir__(self)
     |      Default dir() implementation.
     |  
     |  __getattr__(self, name)
     |  
     |  __setattr__(self, name, value)
     |      Implement setattr(self, name, value).
     |  
     |  __setstate__(self, state)
     |  
     |  add_module(self, name, module)
     |      Adds a child module to the current module.
     |      
     |      The module can be accessed as an attribute using the given name.
     |      
     |      Args:
     |          name (string): name of the child module. The child module can be
     |              accessed from this module using the given name
     |          module (Module): child module to be added to the module.
     |  
     |  apply(self, fn)
     |      Applies ``fn`` recursively to every submodule (as returned by ``.children()``)
     |      as well as self. Typical use includes initializing the parameters of a model
     |      (see also :ref:`nn-init-doc`).
     |      
     |      Args:
     |          fn (:class:`Module` -> None): function to be applied to each submodule
     |      
     |      Returns:
     |          Module: self
     |      
     |      Example::
     |      
     |          >>> def init_weights(m):
     |          >>>     print(m)
     |          >>>     if type(m) == nn.Linear:
     |          >>>         m.weight.data.fill_(1.0)
     |          >>>         print(m.weight)
     |          >>> net = nn.Sequential(nn.Linear(2, 2), nn.Linear(2, 2))
     |          >>> net.apply(init_weights)
     |          Linear(in_features=2, out_features=2, bias=True)
     |          Parameter containing:
     |          tensor([[ 1.,  1.],
     |                  [ 1.,  1.]])
     |          Linear(in_features=2, out_features=2, bias=True)
     |          Parameter containing:
     |          tensor([[ 1.,  1.],
     |                  [ 1.,  1.]])
     |          Sequential(
     |            (0): Linear(in_features=2, out_features=2, bias=True)
     |            (1): Linear(in_features=2, out_features=2, bias=True)
     |          )
     |          Sequential(
     |            (0): Linear(in_features=2, out_features=2, bias=True)
     |            (1): Linear(in_features=2, out_features=2, bias=True)
     |          )
     |  
     |  buffers(self, recurse=True)
     |      Returns an iterator over module buffers.
     |      
     |      Args:
     |          recurse (bool): if True, then yields buffers of this module
     |              and all submodules. Otherwise, yields only buffers that
     |              are direct members of this module.
     |      
     |      Yields:
     |          torch.Tensor: module buffer
     |      
     |      Example::
     |      
     |          >>> for buf in model.buffers():
     |          >>>     print(type(buf.data), buf.size())
     |          <class 'torch.FloatTensor'> (20L,)
     |          <class 'torch.FloatTensor'> (20L, 1L, 5L, 5L)
     |  
     |  children(self)
     |      Returns an iterator over immediate children modules.
     |      
     |      Yields:
     |          Module: a child module
     |  
     |  cpu(self)
     |      Moves all model parameters and buffers to the CPU.
     |      
     |      Returns:
     |          Module: self
     |  
     |  cuda(self, device=None)
     |      Moves all model parameters and buffers to the GPU.
     |      
     |      This also makes associated parameters and buffers different objects. So
     |      it should be called before constructing optimizer if the module will
     |      live on GPU while being optimized.
     |      
     |      Arguments:
     |          device (int, optional): if specified, all parameters will be
     |              copied to that device
     |      
     |      Returns:
     |          Module: self
     |  
     |  double(self)
     |      Casts all floating point parameters and buffers to ``double`` datatype.
     |      
     |      Returns:
     |          Module: self
     |  
     |  eval(self)
     |      Sets the module in evaluation mode.
     |      
     |      This has any effect only on certain modules. See documentations of
     |      particular modules for details of their behaviors in training/evaluation
     |      mode, if they are affected, e.g. :class:`Dropout`, :class:`BatchNorm`,
     |      etc.
     |      
     |      This is equivalent with :meth:`self.train(False) <torch.nn.Module.train>`.
     |      
     |      Returns:
     |          Module: self
     |  
     |  extra_repr(self)
     |      Set the extra representation of the module
     |      
     |      To print customized extra information, you should reimplement
     |      this method in your own modules. Both single-line and multi-line
     |      strings are acceptable.
     |  
     |  float(self)
     |      Casts all floating point parameters and buffers to float datatype.
     |      
     |      Returns:
     |          Module: self
     |  
     |  half(self)
     |      Casts all floating point parameters and buffers to ``half`` datatype.
     |      
     |      Returns:
     |          Module: self
     |  
     |  load_state_dict(self, state_dict, strict=True)
     |      Copies parameters and buffers from :attr:`state_dict` into
     |      this module and its descendants. If :attr:`strict` is ``True``, then
     |      the keys of :attr:`state_dict` must exactly match the keys returned
     |      by this module's :meth:`~torch.nn.Module.state_dict` function.
     |      
     |      Arguments:
     |          state_dict (dict): a dict containing parameters and
     |              persistent buffers.
     |          strict (bool, optional): whether to strictly enforce that the keys
     |              in :attr:`state_dict` match the keys returned by this module's
     |              :meth:`~torch.nn.Module.state_dict` function. Default: ``True``
     |      
     |      Returns:
     |          ``NamedTuple`` with ``missing_keys`` and ``unexpected_keys`` fields:
     |              * **missing_keys** is a list of str containing the missing keys
     |              * **unexpected_keys** is a list of str containing the unexpected keys
     |  
     |  modules(self)
     |      Returns an iterator over all modules in the network.
     |      
     |      Yields:
     |          Module: a module in the network
     |      
     |      Note:
     |          Duplicate modules are returned only once. In the following
     |          example, ``l`` will be returned only once.
     |      
     |      Example::
     |      
     |          >>> l = nn.Linear(2, 2)
     |          >>> net = nn.Sequential(l, l)
     |          >>> for idx, m in enumerate(net.modules()):
     |                  print(idx, '->', m)
     |      
     |          0 -> Sequential(
     |            (0): Linear(in_features=2, out_features=2, bias=True)
     |            (1): Linear(in_features=2, out_features=2, bias=True)
     |          )
     |          1 -> Linear(in_features=2, out_features=2, bias=True)
     |  
     |  named_buffers(self, prefix='', recurse=True)
     |      Returns an iterator over module buffers, yielding both the
     |      name of the buffer as well as the buffer itself.
     |      
     |      Args:
     |          prefix (str): prefix to prepend to all buffer names.
     |          recurse (bool): if True, then yields buffers of this module
     |              and all submodules. Otherwise, yields only buffers that
     |              are direct members of this module.
     |      
     |      Yields:
     |          (string, torch.Tensor): Tuple containing the name and buffer
     |      
     |      Example::
     |      
     |          >>> for name, buf in self.named_buffers():
     |          >>>    if name in ['running_var']:
     |          >>>        print(buf.size())
     |  
     |  named_children(self)
     |      Returns an iterator over immediate children modules, yielding both
     |      the name of the module as well as the module itself.
     |      
     |      Yields:
     |          (string, Module): Tuple containing a name and child module
     |      
     |      Example::
     |      
     |          >>> for name, module in model.named_children():
     |          >>>     if name in ['conv4', 'conv5']:
     |          >>>         print(module)
     |  
     |  named_modules(self, memo=None, prefix='')
     |      Returns an iterator over all modules in the network, yielding
     |      both the name of the module as well as the module itself.
     |      
     |      Yields:
     |          (string, Module): Tuple of name and module
     |      
     |      Note:
     |          Duplicate modules are returned only once. In the following
     |          example, ``l`` will be returned only once.
     |      
     |      Example::
     |      
     |          >>> l = nn.Linear(2, 2)
     |          >>> net = nn.Sequential(l, l)
     |          >>> for idx, m in enumerate(net.named_modules()):
     |                  print(idx, '->', m)
     |      
     |          0 -> ('', Sequential(
     |            (0): Linear(in_features=2, out_features=2, bias=True)
     |            (1): Linear(in_features=2, out_features=2, bias=True)
     |          ))
     |          1 -> ('0', Linear(in_features=2, out_features=2, bias=True))
     |  
     |  named_parameters(self, prefix='', recurse=True)
     |      Returns an iterator over module parameters, yielding both the
     |      name of the parameter as well as the parameter itself.
     |      
     |      Args:
     |          prefix (str): prefix to prepend to all parameter names.
     |          recurse (bool): if True, then yields parameters of this module
     |              and all submodules. Otherwise, yields only parameters that
     |              are direct members of this module.
     |      
     |      Yields:
     |          (string, Parameter): Tuple containing the name and parameter
     |      
     |      Example::
     |      
     |          >>> for name, param in self.named_parameters():
     |          >>>    if name in ['bias']:
     |          >>>        print(param.size())
     |  
     |  parameters(self, recurse=True)
     |      Returns an iterator over module parameters.
     |      
     |      This is typically passed to an optimizer.
     |      
     |      Args:
     |          recurse (bool): if True, then yields parameters of this module
     |              and all submodules. Otherwise, yields only parameters that
     |              are direct members of this module.
     |      
     |      Yields:
     |          Parameter: module parameter
     |      
     |      Example::
     |      
     |          >>> for param in model.parameters():
     |          >>>     print(type(param.data), param.size())
     |          <class 'torch.FloatTensor'> (20L,)
     |          <class 'torch.FloatTensor'> (20L, 1L, 5L, 5L)
     |  
     |  register_backward_hook(self, hook)
     |      Registers a backward hook on the module.
     |      
     |      The hook will be called every time the gradients with respect to module
     |      inputs are computed. The hook should have the following signature::
     |      
     |          hook(module, grad_input, grad_output) -> Tensor or None
     |      
     |      The :attr:`grad_input` and :attr:`grad_output` may be tuples if the
     |      module has multiple inputs or outputs. The hook should not modify its
     |      arguments, but it can optionally return a new gradient with respect to
     |      input that will be used in place of :attr:`grad_input` in subsequent
     |      computations.
     |      
     |      Returns:
     |          :class:`torch.utils.hooks.RemovableHandle`:
     |              a handle that can be used to remove the added hook by calling
     |              ``handle.remove()``
     |      
     |      .. warning ::
     |      
     |          The current implementation will not have the presented behavior
     |          for complex :class:`Module` that perform many operations.
     |          In some failure cases, :attr:`grad_input` and :attr:`grad_output` will only
     |          contain the gradients for a subset of the inputs and outputs.
     |          For such :class:`Module`, you should use :func:`torch.Tensor.register_hook`
     |          directly on a specific input or output to get the required gradients.
     |  
     |  register_buffer(self, name, tensor)
     |      Adds a persistent buffer to the module.
     |      
     |      This is typically used to register a buffer that should not to be
     |      considered a model parameter. For example, BatchNorm's ``running_mean``
     |      is not a parameter, but is part of the persistent state.
     |      
     |      Buffers can be accessed as attributes using given names.
     |      
     |      Args:
     |          name (string): name of the buffer. The buffer can be accessed
     |              from this module using the given name
     |          tensor (Tensor): buffer to be registered.
     |      
     |      Example::
     |      
     |          >>> self.register_buffer('running_mean', torch.zeros(num_features))
     |  
     |  register_forward_hook(self, hook)
     |      Registers a forward hook on the module.
     |      
     |      The hook will be called every time after :func:`forward` has computed an output.
     |      It should have the following signature::
     |      
     |          hook(module, input, output) -> None or modified output
     |      
     |      The hook can modify the output. It can modify the input inplace but
     |      it will not have effect on forward since this is called after
     |      :func:`forward` is called.
     |      
     |      Returns:
     |          :class:`torch.utils.hooks.RemovableHandle`:
     |              a handle that can be used to remove the added hook by calling
     |              ``handle.remove()``
     |  
     |  register_forward_pre_hook(self, hook)
     |      Registers a forward pre-hook on the module.
     |      
     |      The hook will be called every time before :func:`forward` is invoked.
     |      It should have the following signature::
     |      
     |          hook(module, input) -> None or modified input
     |      
     |      The hook can modify the input. User can either return a tuple or a
     |      single modified value in the hook. We will wrap the value into a tuple
     |      if a single value is returned(unless that value is already a tuple).
     |      
     |      Returns:
     |          :class:`torch.utils.hooks.RemovableHandle`:
     |              a handle that can be used to remove the added hook by calling
     |              ``handle.remove()``
     |  
     |  register_parameter(self, name, param)
     |      Adds a parameter to the module.
     |      
     |      The parameter can be accessed as an attribute using given name.
     |      
     |      Args:
     |          name (string): name of the parameter. The parameter can be accessed
     |              from this module using the given name
     |          param (Parameter): parameter to be added to the module.
     |  
     |  requires_grad_(self, requires_grad=True)
     |      Change if autograd should record operations on parameters in this
     |      module.
     |      
     |      This method sets the parameters' :attr:`requires_grad` attributes
     |      in-place.
     |      
     |      This method is helpful for freezing part of the module for finetuning
     |      or training parts of a model individually (e.g., GAN training).
     |      
     |      Args:
     |          requires_grad (bool): whether autograd should record operations on
     |                                parameters in this module. Default: ``True``.
     |      
     |      Returns:
     |          Module: self
     |  
     |  share_memory(self)
     |  
     |  state_dict(self, destination=None, prefix='', keep_vars=False)
     |      Returns a dictionary containing a whole state of the module.
     |      
     |      Both parameters and persistent buffers (e.g. running averages) are
     |      included. Keys are corresponding parameter and buffer names.
     |      
     |      Returns:
     |          dict:
     |              a dictionary containing a whole state of the module
     |      
     |      Example::
     |      
     |          >>> module.state_dict().keys()
     |          ['bias', 'weight']
     |  
     |  to(self, *args, **kwargs)
     |      Moves and/or casts the parameters and buffers.
     |      
     |      This can be called as
     |      
     |      .. function:: to(device=None, dtype=None, non_blocking=False)
     |      
     |      .. function:: to(dtype, non_blocking=False)
     |      
     |      .. function:: to(tensor, non_blocking=False)
     |      
     |      Its signature is similar to :meth:`torch.Tensor.to`, but only accepts
     |      floating point desired :attr:`dtype` s. In addition, this method will
     |      only cast the floating point parameters and buffers to :attr:`dtype`
     |      (if given). The integral parameters and buffers will be moved
     |      :attr:`device`, if that is given, but with dtypes unchanged. When
     |      :attr:`non_blocking` is set, it tries to convert/move asynchronously
     |      with respect to the host if possible, e.g., moving CPU Tensors with
     |      pinned memory to CUDA devices.
     |      
     |      See below for examples.
     |      
     |      .. note::
     |          This method modifies the module in-place.
     |      
     |      Args:
     |          device (:class:`torch.device`): the desired device of the parameters
     |              and buffers in this module
     |          dtype (:class:`torch.dtype`): the desired floating point type of
     |              the floating point parameters and buffers in this module
     |          tensor (torch.Tensor): Tensor whose dtype and device are the desired
     |              dtype and device for all parameters and buffers in this module
     |      
     |      Returns:
     |          Module: self
     |      
     |      Example::
     |      
     |          >>> linear = nn.Linear(2, 2)
     |          >>> linear.weight
     |          Parameter containing:
     |          tensor([[ 0.1913, -0.3420],
     |                  [-0.5113, -0.2325]])
     |          >>> linear.to(torch.double)
     |          Linear(in_features=2, out_features=2, bias=True)
     |          >>> linear.weight
     |          Parameter containing:
     |          tensor([[ 0.1913, -0.3420],
     |                  [-0.5113, -0.2325]], dtype=torch.float64)
     |          >>> gpu1 = torch.device("cuda:1")
     |          >>> linear.to(gpu1, dtype=torch.half, non_blocking=True)
     |          Linear(in_features=2, out_features=2, bias=True)
     |          >>> linear.weight
     |          Parameter containing:
     |          tensor([[ 0.1914, -0.3420],
     |                  [-0.5112, -0.2324]], dtype=torch.float16, device='cuda:1')
     |          >>> cpu = torch.device("cpu")
     |          >>> linear.to(cpu)
     |          Linear(in_features=2, out_features=2, bias=True)
     |          >>> linear.weight
     |          Parameter containing:
     |          tensor([[ 0.1914, -0.3420],
     |                  [-0.5112, -0.2324]], dtype=torch.float16)
     |  
     |  train(self, mode=True)
     |      Sets the module in training mode.
     |      
     |      This has any effect only on certain modules. See documentations of
     |      particular modules for details of their behaviors in training/evaluation
     |      mode, if they are affected, e.g. :class:`Dropout`, :class:`BatchNorm`,
     |      etc.
     |      
     |      Args:
     |          mode (bool): whether to set training mode (``True``) or evaluation
     |                       mode (``False``). Default: ``True``.
     |      
     |      Returns:
     |          Module: self
     |  
     |  type(self, dst_type)
     |      Casts all parameters and buffers to :attr:`dst_type`.
     |      
     |      Arguments:
     |          dst_type (type or string): the desired type
     |      
     |      Returns:
     |          Module: self
     |  
     |  zero_grad(self)
     |      Sets gradients of all model parameters to zero.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from torch.nn.modules.module.Module:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from torch.nn.modules.module.Module:
     |  
     |  dump_patches = False
    
    class Reorder(torch.nn.modules.module.Module)
     |  Reorder(old, new)
     |  
     |  Reorder the dimensions using the given arguments.
     |  
     |  Method resolution order:
     |      Reorder
     |      torch.nn.modules.module.Module
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, old, new)
     |      Initializes internal Module state, shared by both nn.Module and ScriptModule.
     |  
     |  __repr__(self)
     |      Return repr(self).
     |  
     |  forward(self, x)
     |      Defines the computation performed at every call.
     |      
     |      Should be overridden by all subclasses.
     |      
     |      .. note::
     |          Although the recipe for forward pass needs to be defined within
     |          this function, one should call the :class:`Module` instance afterwards
     |          instead of this since the former takes care of running the
     |          registered hooks while the latter silently ignores them.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from torch.nn.modules.module.Module:
     |  
     |  __call__(self, *input, **kwargs)
     |      Call self as a function.
     |  
     |  __delattr__(self, name)
     |      Implement delattr(self, name).
     |  
     |  __dir__(self)
     |      Default dir() implementation.
     |  
     |  __getattr__(self, name)
     |  
     |  __setattr__(self, name, value)
     |      Implement setattr(self, name, value).
     |  
     |  __setstate__(self, state)
     |  
     |  add_module(self, name, module)
     |      Adds a child module to the current module.
     |      
     |      The module can be accessed as an attribute using the given name.
     |      
     |      Args:
     |          name (string): name of the child module. The child module can be
     |              accessed from this module using the given name
     |          module (Module): child module to be added to the module.
     |  
     |  apply(self, fn)
     |      Applies ``fn`` recursively to every submodule (as returned by ``.children()``)
     |      as well as self. Typical use includes initializing the parameters of a model
     |      (see also :ref:`nn-init-doc`).
     |      
     |      Args:
     |          fn (:class:`Module` -> None): function to be applied to each submodule
     |      
     |      Returns:
     |          Module: self
     |      
     |      Example::
     |      
     |          >>> def init_weights(m):
     |          >>>     print(m)
     |          >>>     if type(m) == nn.Linear:
     |          >>>         m.weight.data.fill_(1.0)
     |          >>>         print(m.weight)
     |          >>> net = nn.Sequential(nn.Linear(2, 2), nn.Linear(2, 2))
     |          >>> net.apply(init_weights)
     |          Linear(in_features=2, out_features=2, bias=True)
     |          Parameter containing:
     |          tensor([[ 1.,  1.],
     |                  [ 1.,  1.]])
     |          Linear(in_features=2, out_features=2, bias=True)
     |          Parameter containing:
     |          tensor([[ 1.,  1.],
     |                  [ 1.,  1.]])
     |          Sequential(
     |            (0): Linear(in_features=2, out_features=2, bias=True)
     |            (1): Linear(in_features=2, out_features=2, bias=True)
     |          )
     |          Sequential(
     |            (0): Linear(in_features=2, out_features=2, bias=True)
     |            (1): Linear(in_features=2, out_features=2, bias=True)
     |          )
     |  
     |  buffers(self, recurse=True)
     |      Returns an iterator over module buffers.
     |      
     |      Args:
     |          recurse (bool): if True, then yields buffers of this module
     |              and all submodules. Otherwise, yields only buffers that
     |              are direct members of this module.
     |      
     |      Yields:
     |          torch.Tensor: module buffer
     |      
     |      Example::
     |      
     |          >>> for buf in model.buffers():
     |          >>>     print(type(buf.data), buf.size())
     |          <class 'torch.FloatTensor'> (20L,)
     |          <class 'torch.FloatTensor'> (20L, 1L, 5L, 5L)
     |  
     |  children(self)
     |      Returns an iterator over immediate children modules.
     |      
     |      Yields:
     |          Module: a child module
     |  
     |  cpu(self)
     |      Moves all model parameters and buffers to the CPU.
     |      
     |      Returns:
     |          Module: self
     |  
     |  cuda(self, device=None)
     |      Moves all model parameters and buffers to the GPU.
     |      
     |      This also makes associated parameters and buffers different objects. So
     |      it should be called before constructing optimizer if the module will
     |      live on GPU while being optimized.
     |      
     |      Arguments:
     |          device (int, optional): if specified, all parameters will be
     |              copied to that device
     |      
     |      Returns:
     |          Module: self
     |  
     |  double(self)
     |      Casts all floating point parameters and buffers to ``double`` datatype.
     |      
     |      Returns:
     |          Module: self
     |  
     |  eval(self)
     |      Sets the module in evaluation mode.
     |      
     |      This has any effect only on certain modules. See documentations of
     |      particular modules for details of their behaviors in training/evaluation
     |      mode, if they are affected, e.g. :class:`Dropout`, :class:`BatchNorm`,
     |      etc.
     |      
     |      This is equivalent with :meth:`self.train(False) <torch.nn.Module.train>`.
     |      
     |      Returns:
     |          Module: self
     |  
     |  extra_repr(self)
     |      Set the extra representation of the module
     |      
     |      To print customized extra information, you should reimplement
     |      this method in your own modules. Both single-line and multi-line
     |      strings are acceptable.
     |  
     |  float(self)
     |      Casts all floating point parameters and buffers to float datatype.
     |      
     |      Returns:
     |          Module: self
     |  
     |  half(self)
     |      Casts all floating point parameters and buffers to ``half`` datatype.
     |      
     |      Returns:
     |          Module: self
     |  
     |  load_state_dict(self, state_dict, strict=True)
     |      Copies parameters and buffers from :attr:`state_dict` into
     |      this module and its descendants. If :attr:`strict` is ``True``, then
     |      the keys of :attr:`state_dict` must exactly match the keys returned
     |      by this module's :meth:`~torch.nn.Module.state_dict` function.
     |      
     |      Arguments:
     |          state_dict (dict): a dict containing parameters and
     |              persistent buffers.
     |          strict (bool, optional): whether to strictly enforce that the keys
     |              in :attr:`state_dict` match the keys returned by this module's
     |              :meth:`~torch.nn.Module.state_dict` function. Default: ``True``
     |      
     |      Returns:
     |          ``NamedTuple`` with ``missing_keys`` and ``unexpected_keys`` fields:
     |              * **missing_keys** is a list of str containing the missing keys
     |              * **unexpected_keys** is a list of str containing the unexpected keys
     |  
     |  modules(self)
     |      Returns an iterator over all modules in the network.
     |      
     |      Yields:
     |          Module: a module in the network
     |      
     |      Note:
     |          Duplicate modules are returned only once. In the following
     |          example, ``l`` will be returned only once.
     |      
     |      Example::
     |      
     |          >>> l = nn.Linear(2, 2)
     |          >>> net = nn.Sequential(l, l)
     |          >>> for idx, m in enumerate(net.modules()):
     |                  print(idx, '->', m)
     |      
     |          0 -> Sequential(
     |            (0): Linear(in_features=2, out_features=2, bias=True)
     |            (1): Linear(in_features=2, out_features=2, bias=True)
     |          )
     |          1 -> Linear(in_features=2, out_features=2, bias=True)
     |  
     |  named_buffers(self, prefix='', recurse=True)
     |      Returns an iterator over module buffers, yielding both the
     |      name of the buffer as well as the buffer itself.
     |      
     |      Args:
     |          prefix (str): prefix to prepend to all buffer names.
     |          recurse (bool): if True, then yields buffers of this module
     |              and all submodules. Otherwise, yields only buffers that
     |              are direct members of this module.
     |      
     |      Yields:
     |          (string, torch.Tensor): Tuple containing the name and buffer
     |      
     |      Example::
     |      
     |          >>> for name, buf in self.named_buffers():
     |          >>>    if name in ['running_var']:
     |          >>>        print(buf.size())
     |  
     |  named_children(self)
     |      Returns an iterator over immediate children modules, yielding both
     |      the name of the module as well as the module itself.
     |      
     |      Yields:
     |          (string, Module): Tuple containing a name and child module
     |      
     |      Example::
     |      
     |          >>> for name, module in model.named_children():
     |          >>>     if name in ['conv4', 'conv5']:
     |          >>>         print(module)
     |  
     |  named_modules(self, memo=None, prefix='')
     |      Returns an iterator over all modules in the network, yielding
     |      both the name of the module as well as the module itself.
     |      
     |      Yields:
     |          (string, Module): Tuple of name and module
     |      
     |      Note:
     |          Duplicate modules are returned only once. In the following
     |          example, ``l`` will be returned only once.
     |      
     |      Example::
     |      
     |          >>> l = nn.Linear(2, 2)
     |          >>> net = nn.Sequential(l, l)
     |          >>> for idx, m in enumerate(net.named_modules()):
     |                  print(idx, '->', m)
     |      
     |          0 -> ('', Sequential(
     |            (0): Linear(in_features=2, out_features=2, bias=True)
     |            (1): Linear(in_features=2, out_features=2, bias=True)
     |          ))
     |          1 -> ('0', Linear(in_features=2, out_features=2, bias=True))
     |  
     |  named_parameters(self, prefix='', recurse=True)
     |      Returns an iterator over module parameters, yielding both the
     |      name of the parameter as well as the parameter itself.
     |      
     |      Args:
     |          prefix (str): prefix to prepend to all parameter names.
     |          recurse (bool): if True, then yields parameters of this module
     |              and all submodules. Otherwise, yields only parameters that
     |              are direct members of this module.
     |      
     |      Yields:
     |          (string, Parameter): Tuple containing the name and parameter
     |      
     |      Example::
     |      
     |          >>> for name, param in self.named_parameters():
     |          >>>    if name in ['bias']:
     |          >>>        print(param.size())
     |  
     |  parameters(self, recurse=True)
     |      Returns an iterator over module parameters.
     |      
     |      This is typically passed to an optimizer.
     |      
     |      Args:
     |          recurse (bool): if True, then yields parameters of this module
     |              and all submodules. Otherwise, yields only parameters that
     |              are direct members of this module.
     |      
     |      Yields:
     |          Parameter: module parameter
     |      
     |      Example::
     |      
     |          >>> for param in model.parameters():
     |          >>>     print(type(param.data), param.size())
     |          <class 'torch.FloatTensor'> (20L,)
     |          <class 'torch.FloatTensor'> (20L, 1L, 5L, 5L)
     |  
     |  register_backward_hook(self, hook)
     |      Registers a backward hook on the module.
     |      
     |      The hook will be called every time the gradients with respect to module
     |      inputs are computed. The hook should have the following signature::
     |      
     |          hook(module, grad_input, grad_output) -> Tensor or None
     |      
     |      The :attr:`grad_input` and :attr:`grad_output` may be tuples if the
     |      module has multiple inputs or outputs. The hook should not modify its
     |      arguments, but it can optionally return a new gradient with respect to
     |      input that will be used in place of :attr:`grad_input` in subsequent
     |      computations.
     |      
     |      Returns:
     |          :class:`torch.utils.hooks.RemovableHandle`:
     |              a handle that can be used to remove the added hook by calling
     |              ``handle.remove()``
     |      
     |      .. warning ::
     |      
     |          The current implementation will not have the presented behavior
     |          for complex :class:`Module` that perform many operations.
     |          In some failure cases, :attr:`grad_input` and :attr:`grad_output` will only
     |          contain the gradients for a subset of the inputs and outputs.
     |          For such :class:`Module`, you should use :func:`torch.Tensor.register_hook`
     |          directly on a specific input or output to get the required gradients.
     |  
     |  register_buffer(self, name, tensor)
     |      Adds a persistent buffer to the module.
     |      
     |      This is typically used to register a buffer that should not to be
     |      considered a model parameter. For example, BatchNorm's ``running_mean``
     |      is not a parameter, but is part of the persistent state.
     |      
     |      Buffers can be accessed as attributes using given names.
     |      
     |      Args:
     |          name (string): name of the buffer. The buffer can be accessed
     |              from this module using the given name
     |          tensor (Tensor): buffer to be registered.
     |      
     |      Example::
     |      
     |          >>> self.register_buffer('running_mean', torch.zeros(num_features))
     |  
     |  register_forward_hook(self, hook)
     |      Registers a forward hook on the module.
     |      
     |      The hook will be called every time after :func:`forward` has computed an output.
     |      It should have the following signature::
     |      
     |          hook(module, input, output) -> None or modified output
     |      
     |      The hook can modify the output. It can modify the input inplace but
     |      it will not have effect on forward since this is called after
     |      :func:`forward` is called.
     |      
     |      Returns:
     |          :class:`torch.utils.hooks.RemovableHandle`:
     |              a handle that can be used to remove the added hook by calling
     |              ``handle.remove()``
     |  
     |  register_forward_pre_hook(self, hook)
     |      Registers a forward pre-hook on the module.
     |      
     |      The hook will be called every time before :func:`forward` is invoked.
     |      It should have the following signature::
     |      
     |          hook(module, input) -> None or modified input
     |      
     |      The hook can modify the input. User can either return a tuple or a
     |      single modified value in the hook. We will wrap the value into a tuple
     |      if a single value is returned(unless that value is already a tuple).
     |      
     |      Returns:
     |          :class:`torch.utils.hooks.RemovableHandle`:
     |              a handle that can be used to remove the added hook by calling
     |              ``handle.remove()``
     |  
     |  register_parameter(self, name, param)
     |      Adds a parameter to the module.
     |      
     |      The parameter can be accessed as an attribute using given name.
     |      
     |      Args:
     |          name (string): name of the parameter. The parameter can be accessed
     |              from this module using the given name
     |          param (Parameter): parameter to be added to the module.
     |  
     |  requires_grad_(self, requires_grad=True)
     |      Change if autograd should record operations on parameters in this
     |      module.
     |      
     |      This method sets the parameters' :attr:`requires_grad` attributes
     |      in-place.
     |      
     |      This method is helpful for freezing part of the module for finetuning
     |      or training parts of a model individually (e.g., GAN training).
     |      
     |      Args:
     |          requires_grad (bool): whether autograd should record operations on
     |                                parameters in this module. Default: ``True``.
     |      
     |      Returns:
     |          Module: self
     |  
     |  share_memory(self)
     |  
     |  state_dict(self, destination=None, prefix='', keep_vars=False)
     |      Returns a dictionary containing a whole state of the module.
     |      
     |      Both parameters and persistent buffers (e.g. running averages) are
     |      included. Keys are corresponding parameter and buffer names.
     |      
     |      Returns:
     |          dict:
     |              a dictionary containing a whole state of the module
     |      
     |      Example::
     |      
     |          >>> module.state_dict().keys()
     |          ['bias', 'weight']
     |  
     |  to(self, *args, **kwargs)
     |      Moves and/or casts the parameters and buffers.
     |      
     |      This can be called as
     |      
     |      .. function:: to(device=None, dtype=None, non_blocking=False)
     |      
     |      .. function:: to(dtype, non_blocking=False)
     |      
     |      .. function:: to(tensor, non_blocking=False)
     |      
     |      Its signature is similar to :meth:`torch.Tensor.to`, but only accepts
     |      floating point desired :attr:`dtype` s. In addition, this method will
     |      only cast the floating point parameters and buffers to :attr:`dtype`
     |      (if given). The integral parameters and buffers will be moved
     |      :attr:`device`, if that is given, but with dtypes unchanged. When
     |      :attr:`non_blocking` is set, it tries to convert/move asynchronously
     |      with respect to the host if possible, e.g., moving CPU Tensors with
     |      pinned memory to CUDA devices.
     |      
     |      See below for examples.
     |      
     |      .. note::
     |          This method modifies the module in-place.
     |      
     |      Args:
     |          device (:class:`torch.device`): the desired device of the parameters
     |              and buffers in this module
     |          dtype (:class:`torch.dtype`): the desired floating point type of
     |              the floating point parameters and buffers in this module
     |          tensor (torch.Tensor): Tensor whose dtype and device are the desired
     |              dtype and device for all parameters and buffers in this module
     |      
     |      Returns:
     |          Module: self
     |      
     |      Example::
     |      
     |          >>> linear = nn.Linear(2, 2)
     |          >>> linear.weight
     |          Parameter containing:
     |          tensor([[ 0.1913, -0.3420],
     |                  [-0.5113, -0.2325]])
     |          >>> linear.to(torch.double)
     |          Linear(in_features=2, out_features=2, bias=True)
     |          >>> linear.weight
     |          Parameter containing:
     |          tensor([[ 0.1913, -0.3420],
     |                  [-0.5113, -0.2325]], dtype=torch.float64)
     |          >>> gpu1 = torch.device("cuda:1")
     |          >>> linear.to(gpu1, dtype=torch.half, non_blocking=True)
     |          Linear(in_features=2, out_features=2, bias=True)
     |          >>> linear.weight
     |          Parameter containing:
     |          tensor([[ 0.1914, -0.3420],
     |                  [-0.5112, -0.2324]], dtype=torch.float16, device='cuda:1')
     |          >>> cpu = torch.device("cpu")
     |          >>> linear.to(cpu)
     |          Linear(in_features=2, out_features=2, bias=True)
     |          >>> linear.weight
     |          Parameter containing:
     |          tensor([[ 0.1914, -0.3420],
     |                  [-0.5112, -0.2324]], dtype=torch.float16)
     |  
     |  train(self, mode=True)
     |      Sets the module in training mode.
     |      
     |      This has any effect only on certain modules. See documentations of
     |      particular modules for details of their behaviors in training/evaluation
     |      mode, if they are affected, e.g. :class:`Dropout`, :class:`BatchNorm`,
     |      etc.
     |      
     |      Args:
     |          mode (bool): whether to set training mode (``True``) or evaluation
     |                       mode (``False``). Default: ``True``.
     |      
     |      Returns:
     |          Module: self
     |  
     |  type(self, dst_type)
     |      Casts all parameters and buffers to :attr:`dst_type`.
     |      
     |      Arguments:
     |          dst_type (type or string): the desired type
     |      
     |      Returns:
     |          Module: self
     |  
     |  zero_grad(self)
     |      Sets gradients of all model parameters to zero.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from torch.nn.modules.module.Module:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from torch.nn.modules.module.Module:
     |  
     |  dump_patches = False
    
    class Reshape(torch.nn.modules.module.Module)
     |  Reshape(*args)
     |  
     |  Reshape an input tensor.
     |  
     |  Shapes can be specified as a list of integers and tuples.
     |  If specified as tuple, the corresponding input dimensions
     |  are collapsed into a single output dimension.
     |  
     |  Method resolution order:
     |      Reshape
     |      torch.nn.modules.module.Module
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, *args)
     |      Initializes internal Module state, shared by both nn.Module and ScriptModule.
     |  
     |  __repr__(self)
     |      Return repr(self).
     |  
     |  forward(self, x)
     |      Defines the computation performed at every call.
     |      
     |      Should be overridden by all subclasses.
     |      
     |      .. note::
     |          Although the recipe for forward pass needs to be defined within
     |          this function, one should call the :class:`Module` instance afterwards
     |          instead of this since the former takes care of running the
     |          registered hooks while the latter silently ignores them.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from torch.nn.modules.module.Module:
     |  
     |  __call__(self, *input, **kwargs)
     |      Call self as a function.
     |  
     |  __delattr__(self, name)
     |      Implement delattr(self, name).
     |  
     |  __dir__(self)
     |      Default dir() implementation.
     |  
     |  __getattr__(self, name)
     |  
     |  __setattr__(self, name, value)
     |      Implement setattr(self, name, value).
     |  
     |  __setstate__(self, state)
     |  
     |  add_module(self, name, module)
     |      Adds a child module to the current module.
     |      
     |      The module can be accessed as an attribute using the given name.
     |      
     |      Args:
     |          name (string): name of the child module. The child module can be
     |              accessed from this module using the given name
     |          module (Module): child module to be added to the module.
     |  
     |  apply(self, fn)
     |      Applies ``fn`` recursively to every submodule (as returned by ``.children()``)
     |      as well as self. Typical use includes initializing the parameters of a model
     |      (see also :ref:`nn-init-doc`).
     |      
     |      Args:
     |          fn (:class:`Module` -> None): function to be applied to each submodule
     |      
     |      Returns:
     |          Module: self
     |      
     |      Example::
     |      
     |          >>> def init_weights(m):
     |          >>>     print(m)
     |          >>>     if type(m) == nn.Linear:
     |          >>>         m.weight.data.fill_(1.0)
     |          >>>         print(m.weight)
     |          >>> net = nn.Sequential(nn.Linear(2, 2), nn.Linear(2, 2))
     |          >>> net.apply(init_weights)
     |          Linear(in_features=2, out_features=2, bias=True)
     |          Parameter containing:
     |          tensor([[ 1.,  1.],
     |                  [ 1.,  1.]])
     |          Linear(in_features=2, out_features=2, bias=True)
     |          Parameter containing:
     |          tensor([[ 1.,  1.],
     |                  [ 1.,  1.]])
     |          Sequential(
     |            (0): Linear(in_features=2, out_features=2, bias=True)
     |            (1): Linear(in_features=2, out_features=2, bias=True)
     |          )
     |          Sequential(
     |            (0): Linear(in_features=2, out_features=2, bias=True)
     |            (1): Linear(in_features=2, out_features=2, bias=True)
     |          )
     |  
     |  buffers(self, recurse=True)
     |      Returns an iterator over module buffers.
     |      
     |      Args:
     |          recurse (bool): if True, then yields buffers of this module
     |              and all submodules. Otherwise, yields only buffers that
     |              are direct members of this module.
     |      
     |      Yields:
     |          torch.Tensor: module buffer
     |      
     |      Example::
     |      
     |          >>> for buf in model.buffers():
     |          >>>     print(type(buf.data), buf.size())
     |          <class 'torch.FloatTensor'> (20L,)
     |          <class 'torch.FloatTensor'> (20L, 1L, 5L, 5L)
     |  
     |  children(self)
     |      Returns an iterator over immediate children modules.
     |      
     |      Yields:
     |          Module: a child module
     |  
     |  cpu(self)
     |      Moves all model parameters and buffers to the CPU.
     |      
     |      Returns:
     |          Module: self
     |  
     |  cuda(self, device=None)
     |      Moves all model parameters and buffers to the GPU.
     |      
     |      This also makes associated parameters and buffers different objects. So
     |      it should be called before constructing optimizer if the module will
     |      live on GPU while being optimized.
     |      
     |      Arguments:
     |          device (int, optional): if specified, all parameters will be
     |              copied to that device
     |      
     |      Returns:
     |          Module: self
     |  
     |  double(self)
     |      Casts all floating point parameters and buffers to ``double`` datatype.
     |      
     |      Returns:
     |          Module: self
     |  
     |  eval(self)
     |      Sets the module in evaluation mode.
     |      
     |      This has any effect only on certain modules. See documentations of
     |      particular modules for details of their behaviors in training/evaluation
     |      mode, if they are affected, e.g. :class:`Dropout`, :class:`BatchNorm`,
     |      etc.
     |      
     |      This is equivalent with :meth:`self.train(False) <torch.nn.Module.train>`.
     |      
     |      Returns:
     |          Module: self
     |  
     |  extra_repr(self)
     |      Set the extra representation of the module
     |      
     |      To print customized extra information, you should reimplement
     |      this method in your own modules. Both single-line and multi-line
     |      strings are acceptable.
     |  
     |  float(self)
     |      Casts all floating point parameters and buffers to float datatype.
     |      
     |      Returns:
     |          Module: self
     |  
     |  half(self)
     |      Casts all floating point parameters and buffers to ``half`` datatype.
     |      
     |      Returns:
     |          Module: self
     |  
     |  load_state_dict(self, state_dict, strict=True)
     |      Copies parameters and buffers from :attr:`state_dict` into
     |      this module and its descendants. If :attr:`strict` is ``True``, then
     |      the keys of :attr:`state_dict` must exactly match the keys returned
     |      by this module's :meth:`~torch.nn.Module.state_dict` function.
     |      
     |      Arguments:
     |          state_dict (dict): a dict containing parameters and
     |              persistent buffers.
     |          strict (bool, optional): whether to strictly enforce that the keys
     |              in :attr:`state_dict` match the keys returned by this module's
     |              :meth:`~torch.nn.Module.state_dict` function. Default: ``True``
     |      
     |      Returns:
     |          ``NamedTuple`` with ``missing_keys`` and ``unexpected_keys`` fields:
     |              * **missing_keys** is a list of str containing the missing keys
     |              * **unexpected_keys** is a list of str containing the unexpected keys
     |  
     |  modules(self)
     |      Returns an iterator over all modules in the network.
     |      
     |      Yields:
     |          Module: a module in the network
     |      
     |      Note:
     |          Duplicate modules are returned only once. In the following
     |          example, ``l`` will be returned only once.
     |      
     |      Example::
     |      
     |          >>> l = nn.Linear(2, 2)
     |          >>> net = nn.Sequential(l, l)
     |          >>> for idx, m in enumerate(net.modules()):
     |                  print(idx, '->', m)
     |      
     |          0 -> Sequential(
     |            (0): Linear(in_features=2, out_features=2, bias=True)
     |            (1): Linear(in_features=2, out_features=2, bias=True)
     |          )
     |          1 -> Linear(in_features=2, out_features=2, bias=True)
     |  
     |  named_buffers(self, prefix='', recurse=True)
     |      Returns an iterator over module buffers, yielding both the
     |      name of the buffer as well as the buffer itself.
     |      
     |      Args:
     |          prefix (str): prefix to prepend to all buffer names.
     |          recurse (bool): if True, then yields buffers of this module
     |              and all submodules. Otherwise, yields only buffers that
     |              are direct members of this module.
     |      
     |      Yields:
     |          (string, torch.Tensor): Tuple containing the name and buffer
     |      
     |      Example::
     |      
     |          >>> for name, buf in self.named_buffers():
     |          >>>    if name in ['running_var']:
     |          >>>        print(buf.size())
     |  
     |  named_children(self)
     |      Returns an iterator over immediate children modules, yielding both
     |      the name of the module as well as the module itself.
     |      
     |      Yields:
     |          (string, Module): Tuple containing a name and child module
     |      
     |      Example::
     |      
     |          >>> for name, module in model.named_children():
     |          >>>     if name in ['conv4', 'conv5']:
     |          >>>         print(module)
     |  
     |  named_modules(self, memo=None, prefix='')
     |      Returns an iterator over all modules in the network, yielding
     |      both the name of the module as well as the module itself.
     |      
     |      Yields:
     |          (string, Module): Tuple of name and module
     |      
     |      Note:
     |          Duplicate modules are returned only once. In the following
     |          example, ``l`` will be returned only once.
     |      
     |      Example::
     |      
     |          >>> l = nn.Linear(2, 2)
     |          >>> net = nn.Sequential(l, l)
     |          >>> for idx, m in enumerate(net.named_modules()):
     |                  print(idx, '->', m)
     |      
     |          0 -> ('', Sequential(
     |            (0): Linear(in_features=2, out_features=2, bias=True)
     |            (1): Linear(in_features=2, out_features=2, bias=True)
     |          ))
     |          1 -> ('0', Linear(in_features=2, out_features=2, bias=True))
     |  
     |  named_parameters(self, prefix='', recurse=True)
     |      Returns an iterator over module parameters, yielding both the
     |      name of the parameter as well as the parameter itself.
     |      
     |      Args:
     |          prefix (str): prefix to prepend to all parameter names.
     |          recurse (bool): if True, then yields parameters of this module
     |              and all submodules. Otherwise, yields only parameters that
     |              are direct members of this module.
     |      
     |      Yields:
     |          (string, Parameter): Tuple containing the name and parameter
     |      
     |      Example::
     |      
     |          >>> for name, param in self.named_parameters():
     |          >>>    if name in ['bias']:
     |          >>>        print(param.size())
     |  
     |  parameters(self, recurse=True)
     |      Returns an iterator over module parameters.
     |      
     |      This is typically passed to an optimizer.
     |      
     |      Args:
     |          recurse (bool): if True, then yields parameters of this module
     |              and all submodules. Otherwise, yields only parameters that
     |              are direct members of this module.
     |      
     |      Yields:
     |          Parameter: module parameter
     |      
     |      Example::
     |      
     |          >>> for param in model.parameters():
     |          >>>     print(type(param.data), param.size())
     |          <class 'torch.FloatTensor'> (20L,)
     |          <class 'torch.FloatTensor'> (20L, 1L, 5L, 5L)
     |  
     |  register_backward_hook(self, hook)
     |      Registers a backward hook on the module.
     |      
     |      The hook will be called every time the gradients with respect to module
     |      inputs are computed. The hook should have the following signature::
     |      
     |          hook(module, grad_input, grad_output) -> Tensor or None
     |      
     |      The :attr:`grad_input` and :attr:`grad_output` may be tuples if the
     |      module has multiple inputs or outputs. The hook should not modify its
     |      arguments, but it can optionally return a new gradient with respect to
     |      input that will be used in place of :attr:`grad_input` in subsequent
     |      computations.
     |      
     |      Returns:
     |          :class:`torch.utils.hooks.RemovableHandle`:
     |              a handle that can be used to remove the added hook by calling
     |              ``handle.remove()``
     |      
     |      .. warning ::
     |      
     |          The current implementation will not have the presented behavior
     |          for complex :class:`Module` that perform many operations.
     |          In some failure cases, :attr:`grad_input` and :attr:`grad_output` will only
     |          contain the gradients for a subset of the inputs and outputs.
     |          For such :class:`Module`, you should use :func:`torch.Tensor.register_hook`
     |          directly on a specific input or output to get the required gradients.
     |  
     |  register_buffer(self, name, tensor)
     |      Adds a persistent buffer to the module.
     |      
     |      This is typically used to register a buffer that should not to be
     |      considered a model parameter. For example, BatchNorm's ``running_mean``
     |      is not a parameter, but is part of the persistent state.
     |      
     |      Buffers can be accessed as attributes using given names.
     |      
     |      Args:
     |          name (string): name of the buffer. The buffer can be accessed
     |              from this module using the given name
     |          tensor (Tensor): buffer to be registered.
     |      
     |      Example::
     |      
     |          >>> self.register_buffer('running_mean', torch.zeros(num_features))
     |  
     |  register_forward_hook(self, hook)
     |      Registers a forward hook on the module.
     |      
     |      The hook will be called every time after :func:`forward` has computed an output.
     |      It should have the following signature::
     |      
     |          hook(module, input, output) -> None or modified output
     |      
     |      The hook can modify the output. It can modify the input inplace but
     |      it will not have effect on forward since this is called after
     |      :func:`forward` is called.
     |      
     |      Returns:
     |          :class:`torch.utils.hooks.RemovableHandle`:
     |              a handle that can be used to remove the added hook by calling
     |              ``handle.remove()``
     |  
     |  register_forward_pre_hook(self, hook)
     |      Registers a forward pre-hook on the module.
     |      
     |      The hook will be called every time before :func:`forward` is invoked.
     |      It should have the following signature::
     |      
     |          hook(module, input) -> None or modified input
     |      
     |      The hook can modify the input. User can either return a tuple or a
     |      single modified value in the hook. We will wrap the value into a tuple
     |      if a single value is returned(unless that value is already a tuple).
     |      
     |      Returns:
     |          :class:`torch.utils.hooks.RemovableHandle`:
     |              a handle that can be used to remove the added hook by calling
     |              ``handle.remove()``
     |  
     |  register_parameter(self, name, param)
     |      Adds a parameter to the module.
     |      
     |      The parameter can be accessed as an attribute using given name.
     |      
     |      Args:
     |          name (string): name of the parameter. The parameter can be accessed
     |              from this module using the given name
     |          param (Parameter): parameter to be added to the module.
     |  
     |  requires_grad_(self, requires_grad=True)
     |      Change if autograd should record operations on parameters in this
     |      module.
     |      
     |      This method sets the parameters' :attr:`requires_grad` attributes
     |      in-place.
     |      
     |      This method is helpful for freezing part of the module for finetuning
     |      or training parts of a model individually (e.g., GAN training).
     |      
     |      Args:
     |          requires_grad (bool): whether autograd should record operations on
     |                                parameters in this module. Default: ``True``.
     |      
     |      Returns:
     |          Module: self
     |  
     |  share_memory(self)
     |  
     |  state_dict(self, destination=None, prefix='', keep_vars=False)
     |      Returns a dictionary containing a whole state of the module.
     |      
     |      Both parameters and persistent buffers (e.g. running averages) are
     |      included. Keys are corresponding parameter and buffer names.
     |      
     |      Returns:
     |          dict:
     |              a dictionary containing a whole state of the module
     |      
     |      Example::
     |      
     |          >>> module.state_dict().keys()
     |          ['bias', 'weight']
     |  
     |  to(self, *args, **kwargs)
     |      Moves and/or casts the parameters and buffers.
     |      
     |      This can be called as
     |      
     |      .. function:: to(device=None, dtype=None, non_blocking=False)
     |      
     |      .. function:: to(dtype, non_blocking=False)
     |      
     |      .. function:: to(tensor, non_blocking=False)
     |      
     |      Its signature is similar to :meth:`torch.Tensor.to`, but only accepts
     |      floating point desired :attr:`dtype` s. In addition, this method will
     |      only cast the floating point parameters and buffers to :attr:`dtype`
     |      (if given). The integral parameters and buffers will be moved
     |      :attr:`device`, if that is given, but with dtypes unchanged. When
     |      :attr:`non_blocking` is set, it tries to convert/move asynchronously
     |      with respect to the host if possible, e.g., moving CPU Tensors with
     |      pinned memory to CUDA devices.
     |      
     |      See below for examples.
     |      
     |      .. note::
     |          This method modifies the module in-place.
     |      
     |      Args:
     |          device (:class:`torch.device`): the desired device of the parameters
     |              and buffers in this module
     |          dtype (:class:`torch.dtype`): the desired floating point type of
     |              the floating point parameters and buffers in this module
     |          tensor (torch.Tensor): Tensor whose dtype and device are the desired
     |              dtype and device for all parameters and buffers in this module
     |      
     |      Returns:
     |          Module: self
     |      
     |      Example::
     |      
     |          >>> linear = nn.Linear(2, 2)
     |          >>> linear.weight
     |          Parameter containing:
     |          tensor([[ 0.1913, -0.3420],
     |                  [-0.5113, -0.2325]])
     |          >>> linear.to(torch.double)
     |          Linear(in_features=2, out_features=2, bias=True)
     |          >>> linear.weight
     |          Parameter containing:
     |          tensor([[ 0.1913, -0.3420],
     |                  [-0.5113, -0.2325]], dtype=torch.float64)
     |          >>> gpu1 = torch.device("cuda:1")
     |          >>> linear.to(gpu1, dtype=torch.half, non_blocking=True)
     |          Linear(in_features=2, out_features=2, bias=True)
     |          >>> linear.weight
     |          Parameter containing:
     |          tensor([[ 0.1914, -0.3420],
     |                  [-0.5112, -0.2324]], dtype=torch.float16, device='cuda:1')
     |          >>> cpu = torch.device("cpu")
     |          >>> linear.to(cpu)
     |          Linear(in_features=2, out_features=2, bias=True)
     |          >>> linear.weight
     |          Parameter containing:
     |          tensor([[ 0.1914, -0.3420],
     |                  [-0.5112, -0.2324]], dtype=torch.float16)
     |  
     |  train(self, mode=True)
     |      Sets the module in training mode.
     |      
     |      This has any effect only on certain modules. See documentations of
     |      particular modules for details of their behaviors in training/evaluation
     |      mode, if they are affected, e.g. :class:`Dropout`, :class:`BatchNorm`,
     |      etc.
     |      
     |      Args:
     |          mode (bool): whether to set training mode (``True``) or evaluation
     |                       mode (``False``). Default: ``True``.
     |      
     |      Returns:
     |          Module: self
     |  
     |  type(self, dst_type)
     |      Casts all parameters and buffers to :attr:`dst_type`.
     |      
     |      Arguments:
     |          dst_type (type or string): the desired type
     |      
     |      Returns:
     |          Module: self
     |  
     |  zero_grad(self)
     |      Sets gradients of all model parameters to zero.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from torch.nn.modules.module.Module:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from torch.nn.modules.module.Module:
     |  
     |  dump_patches = False
    
    class SimplePooling2d(torch.nn.modules.module.Module)
     |  SimplePooling2d(sub, mp=2, **kw)
     |  
     |  Perform max pooling/unpooling
     |  
     |  Method resolution order:
     |      SimplePooling2d
     |      torch.nn.modules.module.Module
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, sub, mp=2, **kw)
     |      Initializes internal Module state, shared by both nn.Module and ScriptModule.
     |  
     |  __repr__(self)
     |      Return repr(self).
     |  
     |  forward(self, x)
     |      Defines the computation performed at every call.
     |      
     |      Should be overridden by all subclasses.
     |      
     |      .. note::
     |          Although the recipe for forward pass needs to be defined within
     |          this function, one should call the :class:`Module` instance afterwards
     |          instead of this since the former takes care of running the
     |          registered hooks while the latter silently ignores them.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from torch.nn.modules.module.Module:
     |  
     |  __call__(self, *input, **kwargs)
     |      Call self as a function.
     |  
     |  __delattr__(self, name)
     |      Implement delattr(self, name).
     |  
     |  __dir__(self)
     |      Default dir() implementation.
     |  
     |  __getattr__(self, name)
     |  
     |  __setattr__(self, name, value)
     |      Implement setattr(self, name, value).
     |  
     |  __setstate__(self, state)
     |  
     |  add_module(self, name, module)
     |      Adds a child module to the current module.
     |      
     |      The module can be accessed as an attribute using the given name.
     |      
     |      Args:
     |          name (string): name of the child module. The child module can be
     |              accessed from this module using the given name
     |          module (Module): child module to be added to the module.
     |  
     |  apply(self, fn)
     |      Applies ``fn`` recursively to every submodule (as returned by ``.children()``)
     |      as well as self. Typical use includes initializing the parameters of a model
     |      (see also :ref:`nn-init-doc`).
     |      
     |      Args:
     |          fn (:class:`Module` -> None): function to be applied to each submodule
     |      
     |      Returns:
     |          Module: self
     |      
     |      Example::
     |      
     |          >>> def init_weights(m):
     |          >>>     print(m)
     |          >>>     if type(m) == nn.Linear:
     |          >>>         m.weight.data.fill_(1.0)
     |          >>>         print(m.weight)
     |          >>> net = nn.Sequential(nn.Linear(2, 2), nn.Linear(2, 2))
     |          >>> net.apply(init_weights)
     |          Linear(in_features=2, out_features=2, bias=True)
     |          Parameter containing:
     |          tensor([[ 1.,  1.],
     |                  [ 1.,  1.]])
     |          Linear(in_features=2, out_features=2, bias=True)
     |          Parameter containing:
     |          tensor([[ 1.,  1.],
     |                  [ 1.,  1.]])
     |          Sequential(
     |            (0): Linear(in_features=2, out_features=2, bias=True)
     |            (1): Linear(in_features=2, out_features=2, bias=True)
     |          )
     |          Sequential(
     |            (0): Linear(in_features=2, out_features=2, bias=True)
     |            (1): Linear(in_features=2, out_features=2, bias=True)
     |          )
     |  
     |  buffers(self, recurse=True)
     |      Returns an iterator over module buffers.
     |      
     |      Args:
     |          recurse (bool): if True, then yields buffers of this module
     |              and all submodules. Otherwise, yields only buffers that
     |              are direct members of this module.
     |      
     |      Yields:
     |          torch.Tensor: module buffer
     |      
     |      Example::
     |      
     |          >>> for buf in model.buffers():
     |          >>>     print(type(buf.data), buf.size())
     |          <class 'torch.FloatTensor'> (20L,)
     |          <class 'torch.FloatTensor'> (20L, 1L, 5L, 5L)
     |  
     |  children(self)
     |      Returns an iterator over immediate children modules.
     |      
     |      Yields:
     |          Module: a child module
     |  
     |  cpu(self)
     |      Moves all model parameters and buffers to the CPU.
     |      
     |      Returns:
     |          Module: self
     |  
     |  cuda(self, device=None)
     |      Moves all model parameters and buffers to the GPU.
     |      
     |      This also makes associated parameters and buffers different objects. So
     |      it should be called before constructing optimizer if the module will
     |      live on GPU while being optimized.
     |      
     |      Arguments:
     |          device (int, optional): if specified, all parameters will be
     |              copied to that device
     |      
     |      Returns:
     |          Module: self
     |  
     |  double(self)
     |      Casts all floating point parameters and buffers to ``double`` datatype.
     |      
     |      Returns:
     |          Module: self
     |  
     |  eval(self)
     |      Sets the module in evaluation mode.
     |      
     |      This has any effect only on certain modules. See documentations of
     |      particular modules for details of their behaviors in training/evaluation
     |      mode, if they are affected, e.g. :class:`Dropout`, :class:`BatchNorm`,
     |      etc.
     |      
     |      This is equivalent with :meth:`self.train(False) <torch.nn.Module.train>`.
     |      
     |      Returns:
     |          Module: self
     |  
     |  extra_repr(self)
     |      Set the extra representation of the module
     |      
     |      To print customized extra information, you should reimplement
     |      this method in your own modules. Both single-line and multi-line
     |      strings are acceptable.
     |  
     |  float(self)
     |      Casts all floating point parameters and buffers to float datatype.
     |      
     |      Returns:
     |          Module: self
     |  
     |  half(self)
     |      Casts all floating point parameters and buffers to ``half`` datatype.
     |      
     |      Returns:
     |          Module: self
     |  
     |  load_state_dict(self, state_dict, strict=True)
     |      Copies parameters and buffers from :attr:`state_dict` into
     |      this module and its descendants. If :attr:`strict` is ``True``, then
     |      the keys of :attr:`state_dict` must exactly match the keys returned
     |      by this module's :meth:`~torch.nn.Module.state_dict` function.
     |      
     |      Arguments:
     |          state_dict (dict): a dict containing parameters and
     |              persistent buffers.
     |          strict (bool, optional): whether to strictly enforce that the keys
     |              in :attr:`state_dict` match the keys returned by this module's
     |              :meth:`~torch.nn.Module.state_dict` function. Default: ``True``
     |      
     |      Returns:
     |          ``NamedTuple`` with ``missing_keys`` and ``unexpected_keys`` fields:
     |              * **missing_keys** is a list of str containing the missing keys
     |              * **unexpected_keys** is a list of str containing the unexpected keys
     |  
     |  modules(self)
     |      Returns an iterator over all modules in the network.
     |      
     |      Yields:
     |          Module: a module in the network
     |      
     |      Note:
     |          Duplicate modules are returned only once. In the following
     |          example, ``l`` will be returned only once.
     |      
     |      Example::
     |      
     |          >>> l = nn.Linear(2, 2)
     |          >>> net = nn.Sequential(l, l)
     |          >>> for idx, m in enumerate(net.modules()):
     |                  print(idx, '->', m)
     |      
     |          0 -> Sequential(
     |            (0): Linear(in_features=2, out_features=2, bias=True)
     |            (1): Linear(in_features=2, out_features=2, bias=True)
     |          )
     |          1 -> Linear(in_features=2, out_features=2, bias=True)
     |  
     |  named_buffers(self, prefix='', recurse=True)
     |      Returns an iterator over module buffers, yielding both the
     |      name of the buffer as well as the buffer itself.
     |      
     |      Args:
     |          prefix (str): prefix to prepend to all buffer names.
     |          recurse (bool): if True, then yields buffers of this module
     |              and all submodules. Otherwise, yields only buffers that
     |              are direct members of this module.
     |      
     |      Yields:
     |          (string, torch.Tensor): Tuple containing the name and buffer
     |      
     |      Example::
     |      
     |          >>> for name, buf in self.named_buffers():
     |          >>>    if name in ['running_var']:
     |          >>>        print(buf.size())
     |  
     |  named_children(self)
     |      Returns an iterator over immediate children modules, yielding both
     |      the name of the module as well as the module itself.
     |      
     |      Yields:
     |          (string, Module): Tuple containing a name and child module
     |      
     |      Example::
     |      
     |          >>> for name, module in model.named_children():
     |          >>>     if name in ['conv4', 'conv5']:
     |          >>>         print(module)
     |  
     |  named_modules(self, memo=None, prefix='')
     |      Returns an iterator over all modules in the network, yielding
     |      both the name of the module as well as the module itself.
     |      
     |      Yields:
     |          (string, Module): Tuple of name and module
     |      
     |      Note:
     |          Duplicate modules are returned only once. In the following
     |          example, ``l`` will be returned only once.
     |      
     |      Example::
     |      
     |          >>> l = nn.Linear(2, 2)
     |          >>> net = nn.Sequential(l, l)
     |          >>> for idx, m in enumerate(net.named_modules()):
     |                  print(idx, '->', m)
     |      
     |          0 -> ('', Sequential(
     |            (0): Linear(in_features=2, out_features=2, bias=True)
     |            (1): Linear(in_features=2, out_features=2, bias=True)
     |          ))
     |          1 -> ('0', Linear(in_features=2, out_features=2, bias=True))
     |  
     |  named_parameters(self, prefix='', recurse=True)
     |      Returns an iterator over module parameters, yielding both the
     |      name of the parameter as well as the parameter itself.
     |      
     |      Args:
     |          prefix (str): prefix to prepend to all parameter names.
     |          recurse (bool): if True, then yields parameters of this module
     |              and all submodules. Otherwise, yields only parameters that
     |              are direct members of this module.
     |      
     |      Yields:
     |          (string, Parameter): Tuple containing the name and parameter
     |      
     |      Example::
     |      
     |          >>> for name, param in self.named_parameters():
     |          >>>    if name in ['bias']:
     |          >>>        print(param.size())
     |  
     |  parameters(self, recurse=True)
     |      Returns an iterator over module parameters.
     |      
     |      This is typically passed to an optimizer.
     |      
     |      Args:
     |          recurse (bool): if True, then yields parameters of this module
     |              and all submodules. Otherwise, yields only parameters that
     |              are direct members of this module.
     |      
     |      Yields:
     |          Parameter: module parameter
     |      
     |      Example::
     |      
     |          >>> for param in model.parameters():
     |          >>>     print(type(param.data), param.size())
     |          <class 'torch.FloatTensor'> (20L,)
     |          <class 'torch.FloatTensor'> (20L, 1L, 5L, 5L)
     |  
     |  register_backward_hook(self, hook)
     |      Registers a backward hook on the module.
     |      
     |      The hook will be called every time the gradients with respect to module
     |      inputs are computed. The hook should have the following signature::
     |      
     |          hook(module, grad_input, grad_output) -> Tensor or None
     |      
     |      The :attr:`grad_input` and :attr:`grad_output` may be tuples if the
     |      module has multiple inputs or outputs. The hook should not modify its
     |      arguments, but it can optionally return a new gradient with respect to
     |      input that will be used in place of :attr:`grad_input` in subsequent
     |      computations.
     |      
     |      Returns:
     |          :class:`torch.utils.hooks.RemovableHandle`:
     |              a handle that can be used to remove the added hook by calling
     |              ``handle.remove()``
     |      
     |      .. warning ::
     |      
     |          The current implementation will not have the presented behavior
     |          for complex :class:`Module` that perform many operations.
     |          In some failure cases, :attr:`grad_input` and :attr:`grad_output` will only
     |          contain the gradients for a subset of the inputs and outputs.
     |          For such :class:`Module`, you should use :func:`torch.Tensor.register_hook`
     |          directly on a specific input or output to get the required gradients.
     |  
     |  register_buffer(self, name, tensor)
     |      Adds a persistent buffer to the module.
     |      
     |      This is typically used to register a buffer that should not to be
     |      considered a model parameter. For example, BatchNorm's ``running_mean``
     |      is not a parameter, but is part of the persistent state.
     |      
     |      Buffers can be accessed as attributes using given names.
     |      
     |      Args:
     |          name (string): name of the buffer. The buffer can be accessed
     |              from this module using the given name
     |          tensor (Tensor): buffer to be registered.
     |      
     |      Example::
     |      
     |          >>> self.register_buffer('running_mean', torch.zeros(num_features))
     |  
     |  register_forward_hook(self, hook)
     |      Registers a forward hook on the module.
     |      
     |      The hook will be called every time after :func:`forward` has computed an output.
     |      It should have the following signature::
     |      
     |          hook(module, input, output) -> None or modified output
     |      
     |      The hook can modify the output. It can modify the input inplace but
     |      it will not have effect on forward since this is called after
     |      :func:`forward` is called.
     |      
     |      Returns:
     |          :class:`torch.utils.hooks.RemovableHandle`:
     |              a handle that can be used to remove the added hook by calling
     |              ``handle.remove()``
     |  
     |  register_forward_pre_hook(self, hook)
     |      Registers a forward pre-hook on the module.
     |      
     |      The hook will be called every time before :func:`forward` is invoked.
     |      It should have the following signature::
     |      
     |          hook(module, input) -> None or modified input
     |      
     |      The hook can modify the input. User can either return a tuple or a
     |      single modified value in the hook. We will wrap the value into a tuple
     |      if a single value is returned(unless that value is already a tuple).
     |      
     |      Returns:
     |          :class:`torch.utils.hooks.RemovableHandle`:
     |              a handle that can be used to remove the added hook by calling
     |              ``handle.remove()``
     |  
     |  register_parameter(self, name, param)
     |      Adds a parameter to the module.
     |      
     |      The parameter can be accessed as an attribute using given name.
     |      
     |      Args:
     |          name (string): name of the parameter. The parameter can be accessed
     |              from this module using the given name
     |          param (Parameter): parameter to be added to the module.
     |  
     |  requires_grad_(self, requires_grad=True)
     |      Change if autograd should record operations on parameters in this
     |      module.
     |      
     |      This method sets the parameters' :attr:`requires_grad` attributes
     |      in-place.
     |      
     |      This method is helpful for freezing part of the module for finetuning
     |      or training parts of a model individually (e.g., GAN training).
     |      
     |      Args:
     |          requires_grad (bool): whether autograd should record operations on
     |                                parameters in this module. Default: ``True``.
     |      
     |      Returns:
     |          Module: self
     |  
     |  share_memory(self)
     |  
     |  state_dict(self, destination=None, prefix='', keep_vars=False)
     |      Returns a dictionary containing a whole state of the module.
     |      
     |      Both parameters and persistent buffers (e.g. running averages) are
     |      included. Keys are corresponding parameter and buffer names.
     |      
     |      Returns:
     |          dict:
     |              a dictionary containing a whole state of the module
     |      
     |      Example::
     |      
     |          >>> module.state_dict().keys()
     |          ['bias', 'weight']
     |  
     |  to(self, *args, **kwargs)
     |      Moves and/or casts the parameters and buffers.
     |      
     |      This can be called as
     |      
     |      .. function:: to(device=None, dtype=None, non_blocking=False)
     |      
     |      .. function:: to(dtype, non_blocking=False)
     |      
     |      .. function:: to(tensor, non_blocking=False)
     |      
     |      Its signature is similar to :meth:`torch.Tensor.to`, but only accepts
     |      floating point desired :attr:`dtype` s. In addition, this method will
     |      only cast the floating point parameters and buffers to :attr:`dtype`
     |      (if given). The integral parameters and buffers will be moved
     |      :attr:`device`, if that is given, but with dtypes unchanged. When
     |      :attr:`non_blocking` is set, it tries to convert/move asynchronously
     |      with respect to the host if possible, e.g., moving CPU Tensors with
     |      pinned memory to CUDA devices.
     |      
     |      See below for examples.
     |      
     |      .. note::
     |          This method modifies the module in-place.
     |      
     |      Args:
     |          device (:class:`torch.device`): the desired device of the parameters
     |              and buffers in this module
     |          dtype (:class:`torch.dtype`): the desired floating point type of
     |              the floating point parameters and buffers in this module
     |          tensor (torch.Tensor): Tensor whose dtype and device are the desired
     |              dtype and device for all parameters and buffers in this module
     |      
     |      Returns:
     |          Module: self
     |      
     |      Example::
     |      
     |          >>> linear = nn.Linear(2, 2)
     |          >>> linear.weight
     |          Parameter containing:
     |          tensor([[ 0.1913, -0.3420],
     |                  [-0.5113, -0.2325]])
     |          >>> linear.to(torch.double)
     |          Linear(in_features=2, out_features=2, bias=True)
     |          >>> linear.weight
     |          Parameter containing:
     |          tensor([[ 0.1913, -0.3420],
     |                  [-0.5113, -0.2325]], dtype=torch.float64)
     |          >>> gpu1 = torch.device("cuda:1")
     |          >>> linear.to(gpu1, dtype=torch.half, non_blocking=True)
     |          Linear(in_features=2, out_features=2, bias=True)
     |          >>> linear.weight
     |          Parameter containing:
     |          tensor([[ 0.1914, -0.3420],
     |                  [-0.5112, -0.2324]], dtype=torch.float16, device='cuda:1')
     |          >>> cpu = torch.device("cpu")
     |          >>> linear.to(cpu)
     |          Linear(in_features=2, out_features=2, bias=True)
     |          >>> linear.weight
     |          Parameter containing:
     |          tensor([[ 0.1914, -0.3420],
     |                  [-0.5112, -0.2324]], dtype=torch.float16)
     |  
     |  train(self, mode=True)
     |      Sets the module in training mode.
     |      
     |      This has any effect only on certain modules. See documentations of
     |      particular modules for details of their behaviors in training/evaluation
     |      mode, if they are affected, e.g. :class:`Dropout`, :class:`BatchNorm`,
     |      etc.
     |      
     |      Args:
     |          mode (bool): whether to set training mode (``True``) or evaluation
     |                       mode (``False``). Default: ``True``.
     |      
     |      Returns:
     |          Module: self
     |  
     |  type(self, dst_type)
     |      Casts all parameters and buffers to :attr:`dst_type`.
     |      
     |      Arguments:
     |          dst_type (type or string): the desired type
     |      
     |      Returns:
     |          Module: self
     |  
     |  zero_grad(self)
     |      Sets gradients of all model parameters to zero.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from torch.nn.modules.module.Module:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from torch.nn.modules.module.Module:
     |  
     |  dump_patches = False
    
    class Viewer(torch.nn.modules.module.Module)
     |  Viewer(*args)
     |  
     |  Module equivalent of x.view(*args)
     |  
     |  Method resolution order:
     |      Viewer
     |      torch.nn.modules.module.Module
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, *args)
     |      Initializes internal Module state, shared by both nn.Module and ScriptModule.
     |  
     |  __repr__(self)
     |      Return repr(self).
     |  
     |  forward(self, x)
     |      Defines the computation performed at every call.
     |      
     |      Should be overridden by all subclasses.
     |      
     |      .. note::
     |          Although the recipe for forward pass needs to be defined within
     |          this function, one should call the :class:`Module` instance afterwards
     |          instead of this since the former takes care of running the
     |          registered hooks while the latter silently ignores them.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from torch.nn.modules.module.Module:
     |  
     |  __call__(self, *input, **kwargs)
     |      Call self as a function.
     |  
     |  __delattr__(self, name)
     |      Implement delattr(self, name).
     |  
     |  __dir__(self)
     |      Default dir() implementation.
     |  
     |  __getattr__(self, name)
     |  
     |  __setattr__(self, name, value)
     |      Implement setattr(self, name, value).
     |  
     |  __setstate__(self, state)
     |  
     |  add_module(self, name, module)
     |      Adds a child module to the current module.
     |      
     |      The module can be accessed as an attribute using the given name.
     |      
     |      Args:
     |          name (string): name of the child module. The child module can be
     |              accessed from this module using the given name
     |          module (Module): child module to be added to the module.
     |  
     |  apply(self, fn)
     |      Applies ``fn`` recursively to every submodule (as returned by ``.children()``)
     |      as well as self. Typical use includes initializing the parameters of a model
     |      (see also :ref:`nn-init-doc`).
     |      
     |      Args:
     |          fn (:class:`Module` -> None): function to be applied to each submodule
     |      
     |      Returns:
     |          Module: self
     |      
     |      Example::
     |      
     |          >>> def init_weights(m):
     |          >>>     print(m)
     |          >>>     if type(m) == nn.Linear:
     |          >>>         m.weight.data.fill_(1.0)
     |          >>>         print(m.weight)
     |          >>> net = nn.Sequential(nn.Linear(2, 2), nn.Linear(2, 2))
     |          >>> net.apply(init_weights)
     |          Linear(in_features=2, out_features=2, bias=True)
     |          Parameter containing:
     |          tensor([[ 1.,  1.],
     |                  [ 1.,  1.]])
     |          Linear(in_features=2, out_features=2, bias=True)
     |          Parameter containing:
     |          tensor([[ 1.,  1.],
     |                  [ 1.,  1.]])
     |          Sequential(
     |            (0): Linear(in_features=2, out_features=2, bias=True)
     |            (1): Linear(in_features=2, out_features=2, bias=True)
     |          )
     |          Sequential(
     |            (0): Linear(in_features=2, out_features=2, bias=True)
     |            (1): Linear(in_features=2, out_features=2, bias=True)
     |          )
     |  
     |  buffers(self, recurse=True)
     |      Returns an iterator over module buffers.
     |      
     |      Args:
     |          recurse (bool): if True, then yields buffers of this module
     |              and all submodules. Otherwise, yields only buffers that
     |              are direct members of this module.
     |      
     |      Yields:
     |          torch.Tensor: module buffer
     |      
     |      Example::
     |      
     |          >>> for buf in model.buffers():
     |          >>>     print(type(buf.data), buf.size())
     |          <class 'torch.FloatTensor'> (20L,)
     |          <class 'torch.FloatTensor'> (20L, 1L, 5L, 5L)
     |  
     |  children(self)
     |      Returns an iterator over immediate children modules.
     |      
     |      Yields:
     |          Module: a child module
     |  
     |  cpu(self)
     |      Moves all model parameters and buffers to the CPU.
     |      
     |      Returns:
     |          Module: self
     |  
     |  cuda(self, device=None)
     |      Moves all model parameters and buffers to the GPU.
     |      
     |      This also makes associated parameters and buffers different objects. So
     |      it should be called before constructing optimizer if the module will
     |      live on GPU while being optimized.
     |      
     |      Arguments:
     |          device (int, optional): if specified, all parameters will be
     |              copied to that device
     |      
     |      Returns:
     |          Module: self
     |  
     |  double(self)
     |      Casts all floating point parameters and buffers to ``double`` datatype.
     |      
     |      Returns:
     |          Module: self
     |  
     |  eval(self)
     |      Sets the module in evaluation mode.
     |      
     |      This has any effect only on certain modules. See documentations of
     |      particular modules for details of their behaviors in training/evaluation
     |      mode, if they are affected, e.g. :class:`Dropout`, :class:`BatchNorm`,
     |      etc.
     |      
     |      This is equivalent with :meth:`self.train(False) <torch.nn.Module.train>`.
     |      
     |      Returns:
     |          Module: self
     |  
     |  extra_repr(self)
     |      Set the extra representation of the module
     |      
     |      To print customized extra information, you should reimplement
     |      this method in your own modules. Both single-line and multi-line
     |      strings are acceptable.
     |  
     |  float(self)
     |      Casts all floating point parameters and buffers to float datatype.
     |      
     |      Returns:
     |          Module: self
     |  
     |  half(self)
     |      Casts all floating point parameters and buffers to ``half`` datatype.
     |      
     |      Returns:
     |          Module: self
     |  
     |  load_state_dict(self, state_dict, strict=True)
     |      Copies parameters and buffers from :attr:`state_dict` into
     |      this module and its descendants. If :attr:`strict` is ``True``, then
     |      the keys of :attr:`state_dict` must exactly match the keys returned
     |      by this module's :meth:`~torch.nn.Module.state_dict` function.
     |      
     |      Arguments:
     |          state_dict (dict): a dict containing parameters and
     |              persistent buffers.
     |          strict (bool, optional): whether to strictly enforce that the keys
     |              in :attr:`state_dict` match the keys returned by this module's
     |              :meth:`~torch.nn.Module.state_dict` function. Default: ``True``
     |      
     |      Returns:
     |          ``NamedTuple`` with ``missing_keys`` and ``unexpected_keys`` fields:
     |              * **missing_keys** is a list of str containing the missing keys
     |              * **unexpected_keys** is a list of str containing the unexpected keys
     |  
     |  modules(self)
     |      Returns an iterator over all modules in the network.
     |      
     |      Yields:
     |          Module: a module in the network
     |      
     |      Note:
     |          Duplicate modules are returned only once. In the following
     |          example, ``l`` will be returned only once.
     |      
     |      Example::
     |      
     |          >>> l = nn.Linear(2, 2)
     |          >>> net = nn.Sequential(l, l)
     |          >>> for idx, m in enumerate(net.modules()):
     |                  print(idx, '->', m)
     |      
     |          0 -> Sequential(
     |            (0): Linear(in_features=2, out_features=2, bias=True)
     |            (1): Linear(in_features=2, out_features=2, bias=True)
     |          )
     |          1 -> Linear(in_features=2, out_features=2, bias=True)
     |  
     |  named_buffers(self, prefix='', recurse=True)
     |      Returns an iterator over module buffers, yielding both the
     |      name of the buffer as well as the buffer itself.
     |      
     |      Args:
     |          prefix (str): prefix to prepend to all buffer names.
     |          recurse (bool): if True, then yields buffers of this module
     |              and all submodules. Otherwise, yields only buffers that
     |              are direct members of this module.
     |      
     |      Yields:
     |          (string, torch.Tensor): Tuple containing the name and buffer
     |      
     |      Example::
     |      
     |          >>> for name, buf in self.named_buffers():
     |          >>>    if name in ['running_var']:
     |          >>>        print(buf.size())
     |  
     |  named_children(self)
     |      Returns an iterator over immediate children modules, yielding both
     |      the name of the module as well as the module itself.
     |      
     |      Yields:
     |          (string, Module): Tuple containing a name and child module
     |      
     |      Example::
     |      
     |          >>> for name, module in model.named_children():
     |          >>>     if name in ['conv4', 'conv5']:
     |          >>>         print(module)
     |  
     |  named_modules(self, memo=None, prefix='')
     |      Returns an iterator over all modules in the network, yielding
     |      both the name of the module as well as the module itself.
     |      
     |      Yields:
     |          (string, Module): Tuple of name and module
     |      
     |      Note:
     |          Duplicate modules are returned only once. In the following
     |          example, ``l`` will be returned only once.
     |      
     |      Example::
     |      
     |          >>> l = nn.Linear(2, 2)
     |          >>> net = nn.Sequential(l, l)
     |          >>> for idx, m in enumerate(net.named_modules()):
     |                  print(idx, '->', m)
     |      
     |          0 -> ('', Sequential(
     |            (0): Linear(in_features=2, out_features=2, bias=True)
     |            (1): Linear(in_features=2, out_features=2, bias=True)
     |          ))
     |          1 -> ('0', Linear(in_features=2, out_features=2, bias=True))
     |  
     |  named_parameters(self, prefix='', recurse=True)
     |      Returns an iterator over module parameters, yielding both the
     |      name of the parameter as well as the parameter itself.
     |      
     |      Args:
     |          prefix (str): prefix to prepend to all parameter names.
     |          recurse (bool): if True, then yields parameters of this module
     |              and all submodules. Otherwise, yields only parameters that
     |              are direct members of this module.
     |      
     |      Yields:
     |          (string, Parameter): Tuple containing the name and parameter
     |      
     |      Example::
     |      
     |          >>> for name, param in self.named_parameters():
     |          >>>    if name in ['bias']:
     |          >>>        print(param.size())
     |  
     |  parameters(self, recurse=True)
     |      Returns an iterator over module parameters.
     |      
     |      This is typically passed to an optimizer.
     |      
     |      Args:
     |          recurse (bool): if True, then yields parameters of this module
     |              and all submodules. Otherwise, yields only parameters that
     |              are direct members of this module.
     |      
     |      Yields:
     |          Parameter: module parameter
     |      
     |      Example::
     |      
     |          >>> for param in model.parameters():
     |          >>>     print(type(param.data), param.size())
     |          <class 'torch.FloatTensor'> (20L,)
     |          <class 'torch.FloatTensor'> (20L, 1L, 5L, 5L)
     |  
     |  register_backward_hook(self, hook)
     |      Registers a backward hook on the module.
     |      
     |      The hook will be called every time the gradients with respect to module
     |      inputs are computed. The hook should have the following signature::
     |      
     |          hook(module, grad_input, grad_output) -> Tensor or None
     |      
     |      The :attr:`grad_input` and :attr:`grad_output` may be tuples if the
     |      module has multiple inputs or outputs. The hook should not modify its
     |      arguments, but it can optionally return a new gradient with respect to
     |      input that will be used in place of :attr:`grad_input` in subsequent
     |      computations.
     |      
     |      Returns:
     |          :class:`torch.utils.hooks.RemovableHandle`:
     |              a handle that can be used to remove the added hook by calling
     |              ``handle.remove()``
     |      
     |      .. warning ::
     |      
     |          The current implementation will not have the presented behavior
     |          for complex :class:`Module` that perform many operations.
     |          In some failure cases, :attr:`grad_input` and :attr:`grad_output` will only
     |          contain the gradients for a subset of the inputs and outputs.
     |          For such :class:`Module`, you should use :func:`torch.Tensor.register_hook`
     |          directly on a specific input or output to get the required gradients.
     |  
     |  register_buffer(self, name, tensor)
     |      Adds a persistent buffer to the module.
     |      
     |      This is typically used to register a buffer that should not to be
     |      considered a model parameter. For example, BatchNorm's ``running_mean``
     |      is not a parameter, but is part of the persistent state.
     |      
     |      Buffers can be accessed as attributes using given names.
     |      
     |      Args:
     |          name (string): name of the buffer. The buffer can be accessed
     |              from this module using the given name
     |          tensor (Tensor): buffer to be registered.
     |      
     |      Example::
     |      
     |          >>> self.register_buffer('running_mean', torch.zeros(num_features))
     |  
     |  register_forward_hook(self, hook)
     |      Registers a forward hook on the module.
     |      
     |      The hook will be called every time after :func:`forward` has computed an output.
     |      It should have the following signature::
     |      
     |          hook(module, input, output) -> None or modified output
     |      
     |      The hook can modify the output. It can modify the input inplace but
     |      it will not have effect on forward since this is called after
     |      :func:`forward` is called.
     |      
     |      Returns:
     |          :class:`torch.utils.hooks.RemovableHandle`:
     |              a handle that can be used to remove the added hook by calling
     |              ``handle.remove()``
     |  
     |  register_forward_pre_hook(self, hook)
     |      Registers a forward pre-hook on the module.
     |      
     |      The hook will be called every time before :func:`forward` is invoked.
     |      It should have the following signature::
     |      
     |          hook(module, input) -> None or modified input
     |      
     |      The hook can modify the input. User can either return a tuple or a
     |      single modified value in the hook. We will wrap the value into a tuple
     |      if a single value is returned(unless that value is already a tuple).
     |      
     |      Returns:
     |          :class:`torch.utils.hooks.RemovableHandle`:
     |              a handle that can be used to remove the added hook by calling
     |              ``handle.remove()``
     |  
     |  register_parameter(self, name, param)
     |      Adds a parameter to the module.
     |      
     |      The parameter can be accessed as an attribute using given name.
     |      
     |      Args:
     |          name (string): name of the parameter. The parameter can be accessed
     |              from this module using the given name
     |          param (Parameter): parameter to be added to the module.
     |  
     |  requires_grad_(self, requires_grad=True)
     |      Change if autograd should record operations on parameters in this
     |      module.
     |      
     |      This method sets the parameters' :attr:`requires_grad` attributes
     |      in-place.
     |      
     |      This method is helpful for freezing part of the module for finetuning
     |      or training parts of a model individually (e.g., GAN training).
     |      
     |      Args:
     |          requires_grad (bool): whether autograd should record operations on
     |                                parameters in this module. Default: ``True``.
     |      
     |      Returns:
     |          Module: self
     |  
     |  share_memory(self)
     |  
     |  state_dict(self, destination=None, prefix='', keep_vars=False)
     |      Returns a dictionary containing a whole state of the module.
     |      
     |      Both parameters and persistent buffers (e.g. running averages) are
     |      included. Keys are corresponding parameter and buffer names.
     |      
     |      Returns:
     |          dict:
     |              a dictionary containing a whole state of the module
     |      
     |      Example::
     |      
     |          >>> module.state_dict().keys()
     |          ['bias', 'weight']
     |  
     |  to(self, *args, **kwargs)
     |      Moves and/or casts the parameters and buffers.
     |      
     |      This can be called as
     |      
     |      .. function:: to(device=None, dtype=None, non_blocking=False)
     |      
     |      .. function:: to(dtype, non_blocking=False)
     |      
     |      .. function:: to(tensor, non_blocking=False)
     |      
     |      Its signature is similar to :meth:`torch.Tensor.to`, but only accepts
     |      floating point desired :attr:`dtype` s. In addition, this method will
     |      only cast the floating point parameters and buffers to :attr:`dtype`
     |      (if given). The integral parameters and buffers will be moved
     |      :attr:`device`, if that is given, but with dtypes unchanged. When
     |      :attr:`non_blocking` is set, it tries to convert/move asynchronously
     |      with respect to the host if possible, e.g., moving CPU Tensors with
     |      pinned memory to CUDA devices.
     |      
     |      See below for examples.
     |      
     |      .. note::
     |          This method modifies the module in-place.
     |      
     |      Args:
     |          device (:class:`torch.device`): the desired device of the parameters
     |              and buffers in this module
     |          dtype (:class:`torch.dtype`): the desired floating point type of
     |              the floating point parameters and buffers in this module
     |          tensor (torch.Tensor): Tensor whose dtype and device are the desired
     |              dtype and device for all parameters and buffers in this module
     |      
     |      Returns:
     |          Module: self
     |      
     |      Example::
     |      
     |          >>> linear = nn.Linear(2, 2)
     |          >>> linear.weight
     |          Parameter containing:
     |          tensor([[ 0.1913, -0.3420],
     |                  [-0.5113, -0.2325]])
     |          >>> linear.to(torch.double)
     |          Linear(in_features=2, out_features=2, bias=True)
     |          >>> linear.weight
     |          Parameter containing:
     |          tensor([[ 0.1913, -0.3420],
     |                  [-0.5113, -0.2325]], dtype=torch.float64)
     |          >>> gpu1 = torch.device("cuda:1")
     |          >>> linear.to(gpu1, dtype=torch.half, non_blocking=True)
     |          Linear(in_features=2, out_features=2, bias=True)
     |          >>> linear.weight
     |          Parameter containing:
     |          tensor([[ 0.1914, -0.3420],
     |                  [-0.5112, -0.2324]], dtype=torch.float16, device='cuda:1')
     |          >>> cpu = torch.device("cpu")
     |          >>> linear.to(cpu)
     |          Linear(in_features=2, out_features=2, bias=True)
     |          >>> linear.weight
     |          Parameter containing:
     |          tensor([[ 0.1914, -0.3420],
     |                  [-0.5112, -0.2324]], dtype=torch.float16)
     |  
     |  train(self, mode=True)
     |      Sets the module in training mode.
     |      
     |      This has any effect only on certain modules. See documentations of
     |      particular modules for details of their behaviors in training/evaluation
     |      mode, if they are affected, e.g. :class:`Dropout`, :class:`BatchNorm`,
     |      etc.
     |      
     |      Args:
     |          mode (bool): whether to set training mode (``True``) or evaluation
     |                       mode (``False``). Default: ``True``.
     |      
     |      Returns:
     |          Module: self
     |  
     |  type(self, dst_type)
     |      Casts all parameters and buffers to :attr:`dst_type`.
     |      
     |      Arguments:
     |          dst_type (type or string): the desired type
     |      
     |      Returns:
     |          Module: self
     |  
     |  zero_grad(self)
     |      Sets gradients of all model parameters to zero.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from torch.nn.modules.module.Module:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from torch.nn.modules.module.Module:
     |  
     |  dump_patches = False
    
    class WeightedGrad(torch.autograd.function.Function)
     |  Reweight the gradient using the given weights.
     |  
     |  Method resolution order:
     |      WeightedGrad
     |      torch.autograd.function.Function
     |      torch._C._FunctionBase
     |      torch.autograd.function._ContextMethodMixin
     |      torch.autograd.function._HookMixin
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  backward(self, grad_output)
     |      Defines a formula for differentiating the operation.
     |      
     |      This function is to be overridden by all subclasses.
     |      
     |      It must accept a context :attr:`ctx` as the first argument, followed by
     |      as many outputs did :func:`forward` return, and it should return as many
     |      tensors, as there were inputs to :func:`forward`. Each argument is the
     |      gradient w.r.t the given output, and each returned value should be the
     |      gradient w.r.t. the corresponding input.
     |      
     |      The context can be used to retrieve tensors saved during the forward
     |      pass. It also has an attribute :attr:`ctx.needs_input_grad` as a tuple
     |      of booleans representing whether each input needs gradient. E.g.,
     |      :func:`backward` will have ``ctx.needs_input_grad[0] = True`` if the
     |      first input to :func:`forward` needs gradient computated w.r.t. the
     |      output.
     |  
     |  forward(self, input, weights)
     |      Performs the operation.
     |      
     |      This function is to be overridden by all subclasses.
     |      
     |      It must accept a context ctx as the first argument, followed by any
     |      number of arguments (tensors or other types).
     |      
     |      The context can be used to store tensors that can be then retrieved
     |      during the backward pass.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from torch.autograd.function.Function:
     |  
     |  __call__ = _do_forward(...)
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from torch.autograd.function.Function:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from torch.autograd.function.Function:
     |  
     |  is_traceable = False
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from torch._C._FunctionBase:
     |  
     |  register_hook(...)
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from torch._C._FunctionBase:
     |  
     |  apply(...) from torch.autograd.function.FunctionMeta
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from torch._C._FunctionBase:
     |  
     |  __new__(*args, **kwargs) from builtins.type
     |      Create and return a new object.  See help(type) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from torch._C._FunctionBase:
     |  
     |  dirty_tensors
     |  
     |  metadata
     |  
     |  needs_input_grad
     |  
     |  next_functions
     |  
     |  non_differentiable
     |  
     |  requires_grad
     |  
     |  saved_tensors
     |  
     |  saved_variables
     |  
     |  to_save
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from torch.autograd.function._ContextMethodMixin:
     |  
     |  mark_dirty(self, *args)
     |      Marks given tensors as modified in an in-place operation.
     |      
     |      **This should be called at most once, only from inside the**
     |      :func:`forward` **method, and all arguments should be inputs.**
     |      
     |      Every tensor that's been modified in-place in a call to :func:`forward`
     |      should be given to this function, to ensure correctness of our checks.
     |      It doesn't matter whether the function is called before or after
     |      modification.
     |  
     |  mark_non_differentiable(self, *args)
     |      Marks outputs as non-differentiable.
     |      
     |      **This should be called at most once, only from inside the**
     |      :func:`forward` **method, and all arguments should be outputs.**
     |      
     |      This will mark outputs as not requiring gradients, increasing the
     |      efficiency of backward computation. You still need to accept a gradient
     |      for each output in :meth:`~Function.backward`, but it's always going to
     |      be a zero tensor with the same shape as the shape of a corresponding
     |      output.
     |      
     |      This is used e.g. for indices returned from a max :class:`Function`.
     |  
     |  mark_shared_storage(self, *pairs)
     |  
     |  save_for_backward(self, *tensors)
     |      Saves given tensors for a future call to :func:`~Function.backward`.
     |      
     |      **This should be called at most once, and only from inside the**
     |      :func:`forward` **method.**
     |      
     |      Later, saved tensors can be accessed through the :attr:`saved_tensors`
     |      attribute. Before returning them to the user, a check is made to ensure
     |      they weren't used in any in-place operation that modified their content.
     |      
     |      Arguments can also be ``None``.

FUNCTIONS
    check_order(x, order)
    
    conform(*args, slop=None, dims=True)
        Trim all args to the size of the smallest arg.
    
    conform1(a, *args, slop=None, dims=True)
        Trim the remaining args down to the size of the first.
    
    deprecated(f)
    
    reorder(x, old, new, set_order=True)
        Reorder dimensions according to strings.
        
        E.g., reorder(x, "BLD", "LBD")
    
    weighted_grad(x, y)

FILE
    /home/tmb/proj/torchmore/torchmore/layers.py


```

# module `torchmore.localimport`

```
Help on module torchmore.localimport in torchmore:

NAME
    torchmore.localimport

DESCRIPTION
    # Copyright (c) 2017-2019 TBD. All rights reserved.
    # This file is part of TBD (see TBD).
    # See the LICENSE file for licensing terms (TBD).
    #

CLASSES
    builtins.object
        LocalImport
    
    class LocalImport(builtins.object)
     |  LocalImport(names)
     |  
     |  Methods defined here:
     |  
     |  __enter__(self)
     |  
     |  __exit__(self, some_type, value, traceback)
     |  
     |  __init__(self, names)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)

FILE
    /home/tmb/proj/torchmore/torchmore/localimport.py


```

